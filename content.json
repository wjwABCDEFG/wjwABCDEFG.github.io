{"pages":[],"posts":[{"title":"1011-在D天内送达包裹的能力","text":"力扣1208 https://leetcode-cn.com/problems/get-equal-substrings-within-budget/ 第一直觉就是有一个dis数组记录了s[i]和t[i]的差距，也确实是这么做的，接下来一开始以为直接对dis排序即可，后来才发现是子字符串，所以是要连续的，因此这道题是一道滑动窗口题 1234567891011121314151617181920212223242526public int equalSubstring(String s, String t, int maxCost) { int res = 0; int[] dis = new int[s.length()]; char[] sArr = s.toCharArray(); char[] tArr = t.toCharArray(); //统计s[i]和t[i]的差距 for (int i = 0; i &lt; s.length(); i++) { dis[i] = Math.abs(sArr[i] - tArr[i]); } //因为子字符串要求连续，所以滑动窗口 int l = 0, r = 0, len = 0; while (r &lt; s.length()){ if ((len + dis[r]) &lt;= maxCost){ len += dis[r]; r++; }else { len -= dis[l]; l++; } res = Math.max(res, r - l); } return res;} python实现 12345678910111213141516def equalSubstring(self, s: str, t: str, maxCost: int) -&gt; int: # 统计s[i]和t[i]的差距 dis = [abs(ord(s[i]) - ord(t[i])) for i in range(len(s))] # 因为子字符串要求连续，所以滑动窗口 l, r, max_len, res = 0, 0, 0, 0 while r &lt; len(s): if max_len + dis[r] &lt;= maxCost: max_len += dis[r] r += 1 else: max_len -= dis[l] l += 1 res = max(res, r - l) return res 其他滑动窗口类型的题目可以点击这里","link":"/algorithms/get-equal-substrings-within-budget/"},{"title":"113-路径总和II","text":"力扣113 https://leetcode-cn.com/problems/path-sum-ii/ 虽然树和回溯本质上都是DFS，但我更愿意把这个选择+递归+撤销的模式归为回溯 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { if (root == null) return res; findPath(root, sum, new ArrayList&lt;&gt;()); return res;}private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public void findPath(TreeNode root, int remain, List&lt;Integer&gt; path) { //结束条件 if (root == null) return ; //选择 path.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; remain - root.val == 0){ res.add(new ArrayList&lt;&gt;(path)); } //递归 findPath(root.left, remain - root.val, path); findPath(root.right, remain - root.val, path); //撤销 path.remove(path.size() - 1);} 其他回溯系列题目可以点击这里","link":"/algorithms/path-sum-ii/"},{"title":"11-盛水最多的容器","text":"力扣11 https://leetcode-cn.com/problems/container-with-most-water/ 单调栈860ms问题在于左边不只是一个栈的问题，而是单增的，比如121，最右的1要和左边的1和2都要比，否则不知道，因此右边递减，左边递增，这种情况是不适合用单调栈的 12345678910111213141516171819202122232425public int maxArea(int[] height) { if (height.length &lt; 2) return 0; int res = 0; List&lt;Integer&gt; leftList = new ArrayList&lt;&gt;(); Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); stack.offerLast(0); leftList.add(0); for (int i = 1; i &lt; height.length; i++) { if (height[i] &gt; height[leftList.get(leftList.size() - 1)]) leftList.add(i); while (!stack.isEmpty() &amp;&amp; height[i] &gt;= height[stack.peekLast()]){ stack.pollLast(); } stack.offerLast(i); } //剩余的 while (!stack.isEmpty()){ Integer right = stack.pollLast(); for (Integer left : leftList) { if (left &gt; right) break; int minHeight = Math.min(height[right], height[left]); res = Math.max(res, minHeight * (right - left)); } } return res;} 双指针4ms 1234567891011public int maxArea_other(int[] height) { if(height.length &lt;= 1) return -1; int i = 0, j = height.length - 1, res = 0; while(i &lt; j){ int h = Math.min(height[i], height[j]); res = Math.max(res, h * (j - i)); if(height[i] &lt; height[j]) ++i; else --j; } return res;} 其他双指针类型的题目点击这里","link":"/algorithms/container-with-most-water/"},{"title":"10月事记","text":"[DONE] 云之家实习结束 浙江大华offer 拒绝浙江大华offer 开启学校实训 [TODO] 补招 补知识 十月已过，这个月可以说是很开心的一个月，实习结束了，校企实训开始了，走之前offer也拿到了。 写这篇文章的时候是11.6，策略终究是高估了自己，还想着一个保底offer，要价很低，结果就这一个！！！总之拒了，现在还是0offer状态…… 发现自己缺少很多必要基础知识，现在正在狂补。同时在进行补招和等待春招，看着周围的同学都慢慢上岸了，自己内心还是有一点慌乱的。不知道前路如何，但是不能放弃，加油吧少年","link":"/life/10%E6%9C%88%E4%BA%8B%E8%AE%B0/"},{"title":"116/117-填充每个节点的下一个右侧节点指针","text":"力扣116/117 https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/ https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/ 两题的区别在于树是否是完全二叉树 先看116 由于题目要求空间复杂度为常量，因此不能用BFS，否则队列有大小造成空间复杂度为O(n)。因此只能使用递归，这题其实思路上来说比较清晰，root.left连到root.right上，root.right连到root.next.left上 12345 o / \\ o------&gt;o / \\ / \\ o--&gt;o--&gt;o o 为了方便，直接给出ide上可以跑的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243public class one_one_six_填充每个节点的下一个右侧节点指针 { @Test public void test(){ Node root = new Node(1); root.left = new Node(2); root.left.left = new Node(4); root.left.right = new Node(5); root.right = new Node(3); root.right.left = new Node(6); root.right.right = new Node(7); Node res = connect(root); } public Node connect(Node root) { if (root == null || root.left == null) return root; root.left.next = root.right; //右是空也没关系，就直接为null if (root.next != null) root.right.next = root.next.left; //要有递归累积的思想，表面上看起来无法连接其他子树，实际上之前已经连接好了 connect(root.left); connect(root.right); return root; } class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }} 117题的区别在于不一定是完全二叉树，也就是存在右节点为空的情况，那么左节点就要直接next到另一颗子树 12345 o / \\ o--&gt;o / / \\ o--&gt;o o 那么加上这个判断就行 还有就是必须先递归右子树再递归左子树，原因如下图 12345678910为什么要先递归右子树，如下图 先递归左子树 先递归右子树 o o / \\ / \\ o —— o o —— o / / \\ / / \\ o —— o o o —— o---o / / \\ / / \\ o o o o--------o o也就是说，先递归左子树的话第三层的虚线next数据尚未产生，第四层getNext()时也就找不到第四层的虚线next数据 为了方便测试，直接贴ide下的完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class one_one_seven_填充每个节点的下一个右侧节点指针II { @Test public void test(){ Node root = new Node(1); root.left = new Node(2); root.left.left = new Node(4); root.right = new Node(3); root.right.right = new Node(5);// root.right.left = new Node(6);// root.right.right = new Node(7); connect(root); } public Node connect(Node root) { if(root == null) return null; if (root.left != null){ //root的左子树：可能连接到右子树也可能连接到root的兄弟树的left/right if(root.right != null){ root.left.next = root.right; //右子树不为空，则左子树连接右子树 }else { root.left.next = getNext(root.next); //右子树为空，连接到兄弟树的left/right } } if(root.right != null) { //root的右子树：连接到root的兄弟树的left/right root.right.next = getNext(root.next); } connect(root.right); connect(root.left); return root; } private Node getNext(Node node){ if (node == null) return null; if (node.left != null) return node.left; if (node.right != null) return node.right; if (node.next != null) return getNext(node.next); return null; } class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }} 这份代码非常精炼，尤其是getNext函数 其实这道题逻辑上是比较清晰的（root.left.next = root.right;那段），但是递归那段是很难想到的（root.right.next = getNext(root.next);那段）。反正我是这样，递归的题真的头大，尤其是分治，除了回溯中的递归我总结了套路，其他的依题意太灵活，起码我觉得没有做过相似的题目时我是写不出来的，逃~ 其他树的题目点击这里","link":"/algorithms/populating-next-right-pointers-in-each-node/"},{"title":"1208-尽可能使字符串相等","text":"力扣1208 https://leetcode-cn.com/problems/get-equal-substrings-within-budget/ 第一直觉就是有一个dis数组记录了s[i]和t[i]的差距，也确实是这么做的，接下来一开始以为直接对dis排序即可，后来才发现是子字符串，所以是要连续的，因此这道题是一道滑动窗口题 1234567891011121314151617181920212223242526public int equalSubstring(String s, String t, int maxCost) { int res = 0; int[] dis = new int[s.length()]; char[] sArr = s.toCharArray(); char[] tArr = t.toCharArray(); //统计s[i]和t[i]的差距 for (int i = 0; i &lt; s.length(); i++) { dis[i] = Math.abs(sArr[i] - tArr[i]); } //因为子字符串要求连续，所以滑动窗口 int l = 0, r = 0, len = 0; while (r &lt; s.length()){ if ((len + dis[r]) &lt;= maxCost){ len += dis[r]; r++; }else { len -= dis[l]; l++; } res = Math.max(res, r - l); } return res;} python实现 12345678910111213141516def equalSubstring(self, s: str, t: str, maxCost: int) -&gt; int: # 统计s[i]和t[i]的差距 dis = [abs(ord(s[i]) - ord(t[i])) for i in range(len(s))] # 因为子字符串要求连续，所以滑动窗口 l, r, max_len, res = 0, 0, 0, 0 while r &lt; len(s): if max_len + dis[r] &lt;= maxCost: max_len += dis[r] r += 1 else: max_len -= dis[l] l += 1 res = max(res, r - l) return res 其他滑动窗口类型的题目可以点击这里","link":"/algorithms/get-equal-substrings-within-budget/"},{"title":"1219 黄金矿工","text":"力扣1219 https://leetcode-cn.com/problems/path-with-maximum-gold/ 另一种回溯类型：枚举型 以前都是for循环里面递归的，但是有时候因为情况少（比如四个方向），for循环写起来反而麻烦 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class one_two_one_nine_黄金矿工 { @Test public void test(){ int[][] grid = {{0,6,0}, {5,8,7}, {0,9,0}}; int result = getMaximumGold(grid); System.out.println(result); } private int res = 0; public int getMaximumGold(int[][] grid) { for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[i].length; j++) { backtrace(grid, i, j, 0); } } return res; } public void backtrace(int[][] grid, int x, int y, int money){ if (!check(grid, x, y)) return ; if (grid[x][y] == 0){ //结束条件：四面为0，实际上是踏过去之后所在地为0 res = Math.max(res, money); return ; } //做选择 int stored = grid[x][y]; money += stored; grid[x][y] = 0; //不走回头路 //for循环有限，枚举代替递归 backtrace(grid, x - 1, y, money); backtrace(grid, x, y - 1, money); backtrace(grid, x + 1, y, money); backtrace(grid, x, y + 1, money); //撤销 money -= stored; grid[x][y] = stored; } public boolean check(int[][] grid, int x, int y){ return (x &gt;= 0 &amp;&amp; x &lt; grid.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; grid[0].length ); }} 对比以前的回溯，仍然使用一个变量保存之前的状态，只是将for改成了枚举，并在枚举递归之后撤销之前的状态。同样的还有另一道题 2020度小满金融秋招笔试题–坚强的小昆虫 直接给出java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class duxiaoman_002_坚强的小昆虫 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int group = sc.nextInt(); sc.nextLine(); for (int i = 0; i &lt; group; i++) { //每一组 flag = false; res = Integer.MAX_VALUE; String[] temp = sc.nextLine().split(\" \"); int n = Integer.parseInt(temp[0]); int m = Integer.parseInt(temp[1]); int x = 0, y = 0; //初始位置 char[][] matrix = new char[n][m]; for (int j = 0; j &lt; n; j++) { matrix[j] = sc.nextLine().toCharArray(); for (int k = 0; k &lt; matrix[j].length; k++) { if (matrix[j][k] == '@'){ x = j; y = k; } } } //处理完输入，进入正式逻辑 backtrace(matrix, x, y, 0); if (!flag) res = -1; System.out.println(res); } } private static int res = Integer.MAX_VALUE; private static boolean flag = false; /** * 回溯 * @param matrix */ public static void backtrace(char[][] matrix, int x, int y, int num){ if (matrix[x][y] == '#') return ; if (matrix[x][y] == '*') num++; //结束条件 if (x == 0 || y == 0 || x == matrix.length - 1 || y == matrix[0].length - 1){ res = Math.min(res, num); flag = true; return ; } //四次枚举代替for循环 char stored = matrix[x][y] == '@' ? '.' : matrix[x][y]; matrix[x][y] = '#'; //不走回头路！ backtrace(matrix, x - 1, y, num); //上 backtrace(matrix, x, y - 1, num); //左 backtrace(matrix, x + 1, y, num); //下 backtrace(matrix, x, y + 1, num); //右 matrix[x][y] = stored; }} 同样的也是使用stored保存之前的状态，相比传统的回溯，要注意的改动并不多 其他回溯系列题目可以点击这里","link":"/algorithms/path-with-maximum-gold/"},{"title":"121-买卖股票的最佳时机","text":"力扣第121题 剑指offer第63题 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路： 经典的动态规划题 dp数组含义：dp[i]代表到第i天最佳利润，则dp[n]就是最终最大利润 初始条件：dp[0] = 0，没买入卖出之前默认利润为0 关系式：dp[i] = Math.max(今天卖出去的话获得的最大利润, 之前卖的话最大利润即dp[i-1]); 12345678910111213141516171819202122232425public class one_two_one_买卖股票的最佳时机 { @Test public void test(){ int[] prices = {2,6,1,7}; int res = maxProfit(prices); System.out.println(res); } public int maxProfit(int[] prices) { if (prices.length == 0){ return 0; } int n = prices.length; int[] dp = new int[n]; //dp[i]代表到第i天为止最佳收入 int buy = 0; //当前最佳买入日期 for (int i = 1; i &lt; n; i++) { if (prices[i] &lt; prices[buy]){ buy = i; } dp[i] = Math.max(prices[i] - prices[buy], dp[i - 1]); } return dp[n - 1]; }} 经典的动态规划题，跟着3步走就完事儿~ 可以优化一下：dp[i]只和dp[i-1]有关，所以可以不用数组而只用一个变量保存 123456789101112131415public int maxProfit(int[] prices) { if (prices.length == 0){ return 0; } int n = prices.length; int res = 0; int buy = 0; //当前最佳买入日期 for (int i = 1; i &lt; n; i++) { if (prices[i] &lt; prices[buy]){ buy = i; } res = Math.max(prices[i] - prices[buy], res); } return res;} 时间也由2ms变为1ms 其他动态规划的题目可以点击这里","link":"/algorithms/best-time-to-buy-and-sell-stock/"},{"title":"131-分割回文串","text":"力扣131 https://leetcode-cn.com/problems/palindrome-partitioning/ 回溯问题，一开始看到样例的结果是单个的在最后面，导致想复杂了 贴完整代码 123456789101112131415161718192021222324252627282930313233343536373839public class one_three_one_分割回文串 { @Test public void test(){ String s = \"\"; partition(s); System.out.println(res.toString()); } private List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) { backtrace(s, new ArrayList&lt;&gt;(), 0); return res; } public void backtrace(String s, List&lt;String&gt; path, int splitIndex){ if (splitIndex == s.length()){ //结束条件：分割到底 res.add(new ArrayList&lt;&gt;(path)); return ; } for (int i = splitIndex; i &lt; s.length(); i++) { String a = s.substring(splitIndex, i + 1); //做选择 path.add(a); if (check(a)){ //条件递归 backtrace(s, path, i + 1); } path.remove(path.size() - 1); //撤销选择 } } //检验回文 public boolean check(String str){ for (int i = 0; i &lt; str.length() / 2; i++) { if (str.charAt(i) != str.charAt(str.length() - i - 1)) return false; } return true; }} 13ms 剪枝：将判断添加在add（做选择前），可以减少多次add remove操作，提升到5-8ms 其他不变，只贴有变动的backtrace函数 12345678910111213public void backtrace(String s, List&lt;String&gt; path, int splitIndex){ if (splitIndex == s.length()){ res.add(new ArrayList&lt;&gt;(path)); return ; } for (int i = splitIndex; i &lt; s.length(); i++) { String a = s.substring(splitIndex, i + 1); if (!check(a)) continue; //先判断不回文，减少一次add和remove操作 path.add(a); backtrace(s, path, i + 1); path.remove(path.size() - 1); }} 其他回溯的题目可以点击这里","link":"/algorithms/palindrome-partitioning/"},{"title":"1291-顺次数","text":"力扣1291 https://leetcode-cn.com/problems/sequential-digits/ 乍一看有点怪，看似回溯又不像。其实是回溯，但是没有123 124 125这样的过程，每一次for循环还在，但是每次递归进入一次后就被剪枝了（判断12后面必须跟3） 12345678910111213141516171819202122232425public List&lt;Integer&gt; sequentialDigits(int low, int high) { backtrace(low, high, 0, 1); Collections.sort(res); return res;}private List&lt;Integer&gt; res = new ArrayList&lt;&gt;();public void backtrace(int low, int high, int path, int index){ //结束条件 if (path &gt; high) return ; if (path &gt;= low &amp;&amp; path &lt;= high){ res.add(path); } //选择列表实际为起始数字 for (int i = index; i &lt;= 9; i++) { //剪枝 if (path != 0 &amp;&amp; path % 10 + 1 != i) return; //选择 path = path * 10 + i; //递归 backtrace(low, high, path, i + 1); //撤销 path = path / 10; }} 其他回溯系列题目可以点击这里","link":"/algorithms/sequential-digits/"},{"title":"15-三数之和","text":"力扣15 https://leetcode-cn.com/problems/3sum/ 思路：这题的关键在于排序+双指针，虽然有三个指针，但核心是j, k指针 因为排好序了，所以指针k从i+1开始向右走，k从末尾往前走 -3 | -2 -1 0 2 4 7 此时i指向-3，那么j指向下一个-2，k指向末尾7，然后用|两端表示j, k -3 | -2 -1 0 2 4 7| 然后计算-3 + -2 + 7 &gt; 0，k– -3 | -2 -1 0 2 4 | 7 然后计算-3 + -2 + 4 &lt; 0，j++ -3 -2 | -1 0 2 4 | 7 然后计算-3 + -1 + 4 = 0，说名-3, -1, 4是一组结果 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); int n = nums.length; if(n &lt; 3){ return new ArrayList&lt;&gt;(res); } Arrays.sort(nums); for (int i = 0; i &lt; n - 2; i++) { int j = i + 1; int k = n - 1; while (j &lt; k){ if (nums[i] + nums[j] + nums[k] &gt; 0){ k--; }else if (nums[i] + nums[j] + nums[k] &lt; 0){ j++; }else { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(nums[k]); res.add(list); j++; k--; } } } return new ArrayList&lt;&gt;(res);} 其他双指针类型的题目点击这里","link":"/algorithms/3sum/"},{"title":"152-乘积最大子数组","text":"力扣152 https://leetcode-cn.com/problems/maximum-product-subarray/ 这题不是普通的动态规划题，借助了最大最小两个数组来进行动态规划 动态规划解法可以参考官方题解 https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/ 在评论区看到一个很妙的思路，动态规划的关键在哪里？关键就在于 只要相乘不为0，绝对值就会增大。如果数组的数是负数，那么会导致最大的变最小的，最小的变最大的，最大最小保存起来交换即可 1234567891011121314public int maxProduct2(int[] nums) { int max = Integer.MIN_VALUE, imax = 1, imin = 1; //一个保存最大的，一个保存最小的。 for(int i=0; i&lt;nums.length; i++){ if(nums[i] &lt; 0){ //如果数组的数是负数，那么会导致最大的变最小的，最小的变最大的。因此交换两个的值。 int temp = imax; imax = imin; imin = temp; } imax = Math.max(imax*nums[i], nums[i]); imin = Math.min(imin*nums[i], nums[i]); max = Math.max(max, imax); } return max;} 太强了，这辈子想不出了… 不过这道题可以有一个更加容易思考的解法： 记录一个当前乘积product，一个当前最大max 1如果有0，则会以0为分界点，将product重置为1重新计算 2如果没有0，分为两种情况： 2.1负数为偶数，一直乘到底 2.2负数为奇数，从左边开始乘到最后一个负数前有一个最大值，从右边开始乘也有一个最大值，比较即可 明白了这一点后可以简化： 2.2中所说“最后一个负数前”其实不需要考虑，直接乘到底，因为我们记录了max，就算乘到底也不会比max大（负数&lt;正数） 2.1可以包含在2.2中，只不过左右两次结果一样罢了 1可以包含在2.2中，只需要判断当前是否为0重置product即可 所以代码如下： 123456789101112131415161718public int maxProduct(int[] nums) { int product = 1; int max = nums[0]; //从左往右 for (int i = 0; i &lt; nums.length; i++) { product *= nums[i]; max = Math.max(max, product); if (nums[i] == 0) product = 1; } //从右往左 product = 1; for (int i = nums.length - 1; i &gt;= 0; i--) { product *= nums[i]; max = Math.max(max, product); if (nums[i] == 0) product = 1; } return max;} 其他动态规划的题目可以点击这里","link":"/algorithms/maximum-product-subarray/"},{"title":"160-相交链表","text":"力扣160 / 剑指offer52 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 这题有坑，题目描述的不清楚。这题意思是节点地址相同（而不只是值）。 思路：让A末尾接上B组成（AB），B的末尾接上A（组成BA），这样两个链表长度就相同了，遍历他们得到相同的节点就是交点 1234567891011121314151617181920212223242526272829303132333435public class one_six_zero_相交链表 { @Test public void test(){ ListNode commons = new ListNode(8); commons.next= new ListNode(4); commons.next.next = new ListNode(5); ListNode headA = new ListNode(4); headA.next = new ListNode(1); headA.next.next = commons; ListNode headB = new ListNode(5); headB.next = new ListNode(0); headB.next.next = new ListNode(1); headB.next.next.next = commons; ListNode res = getIntersectionNode(headA, headB); System.out.println(res.val); } public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) { return null; } ListNode n1 = headA; ListNode n2 = headB; while(n1 != n2){ n1 = n1 == null ? headB : n1.next; n2 = n2 == null ? headA : n2.next; } return n1; }} 需要注意的是n1 == null而不是n1.next == null，也就是说两个节点都有一次null的机会，否则如果两个链表没有交点，就直接死循环了 评论区看到文艺版解释： 两个结点不断的去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇❤ 我哭了，程序都比我懂浪漫🙁 其他链表类型的题目点击这里","link":"/algorithms/intersection-of-two-linked-lists/"},{"title":"19-删除链表的倒数第n个节点","text":"力扣19 https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 双指针经典题 前后指针，一遍扫描前面的指针先走n个，然后前后指针一起移动，在要删除的节点前面停下，也就是pre.next != null然后删掉第n个：post.next = post.next.next 1234567891011121314151617public ListNode removeNthFromEnd2(ListNode head, int n) { if (head == null) return null; ListNode root = new ListNode(0); root.next = head; ListNode pre = root, post = root; while (n-- != 0) { pre = pre.next; } while (pre != null &amp;&amp; pre.next != null){ pre = pre.next; post = post.next; } if (post != null &amp;&amp; post.next != null) post.next = post.next.next; return root.next;} 其他链表类型的题目点击这里 其他双指针类型的题目点击这里","link":"/algorithms/remove-nth-node-from-end-of-list/"},{"title":"179-最大数","text":"力扣179 https://leetcode-cn.com/problems/largest-number/ 害，网易的题没做出来，还是牛客原题，是一道字符串问题，字符串拼接后保证数最大，考的是sort的重写Comparator 12345678910111213141516public String largestNumber(int[] nums) { String[] strArr = new String[nums.length]; for (int i = 0; i &lt; strArr.length; i++) { strArr[i] = String.valueOf(nums[i]); } Arrays.sort(strArr, (o1, o2) -&gt; (int) (Long.parseLong(o1 + o2) - Long.parseLong(o2 + o1))); //就这句,这里的o1 + o2是字符串拼接 StringBuilder sb = new StringBuilder(); boolean flag = true; for(int i = strArr.length - 1; i &gt;= 0; i--){ sb.append(strArr[i]); if (!\"0\".equals(strArr[i])) flag = false; } if (flag) return \"0\"; return sb.toString();} 或者直接调用字符串的compareTo方法 12345678910111213141516public String largestNumber(int[] nums) { String[] strArr = new String[nums.length]; for (int i = 0; i &lt; strArr.length; i++) { strArr[i] = String.valueOf(nums[i]); } Arrays.sort(strArr, (o1, o2) -&gt; (o1 + o2).compareTo(o2 + o1)); StringBuilder sb = new StringBuilder(); boolean flag = true; for(int i = strArr.length - 1; i &gt;= 0; i--){ sb.append(strArr[i]); if (!\"0\".equals(strArr[i])) flag = false; } if (flag) return \"0\"; return sb.toString();} 其他字符串类型的题目可以点击这里","link":"/algorithms/largest-number/"},{"title":"206-反转链表","text":"力扣206 https://leetcode-cn.com/problems/reverse-linked-list/ 简单题，链表题指针不怕多！！ 1234567891011public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode pre = head, post = null, temp = null; while (pre != null) { temp = pre.next; pre.next = post; post = pre; pre = temp; } return post;} 其他链表类型的题目点击这里","link":"/algorithms/reverse-linked-list/"},{"title":"20-有效的括号","text":"力扣20 https://leetcode-cn.com/problems/valid-parentheses/ 之前的文章说过这种括号匹配的题目一般都是栈做，但是笔试的话为了追求效率，可以考虑用一些字符串api 巧妙的字符串替换(不推荐) 1234567891011/** * 字符串替换，成功匹配那么每次一定会有一对直到为空 */public boolean isValid(String s) { while (s.contains(\"()\") || s.contains(\"[]\") || s.contains(\"{}\")){ s = s.replace(\"()\", \"\"); s = s.replace(\"[]\", \"\"); s = s.replace(\"{}\", \"\"); } return s.length() == 0;} 巧妙的栈做法(推荐)，这个栈设计的很巧妙，写起来比字符串替换更简单，推荐 1234567891011121314/** * 巧妙的栈，只存了应该出栈的右括号，很棒的思路，很快，写起来比字符串替换更简单 */public boolean isValid(String s) { char[] chars = s.toCharArray(); Deque&lt;Character&gt; stack = new LinkedList&lt;&gt;(); for (char c : chars) { if (c == '{') stack.offerLast('}'); else if (c == '[') stack.offerLast(']'); else if (c == '(') stack.offerLast(')'); else while (stack.isEmpty() || stack.pollLast() != c) return false; } return stack.isEmpty();} 其他字符串类型的题目可以点击这里","link":"/algorithms/valid-parentheses/"},{"title":"136-137-260-只出现一次的数字","text":"136-只出现一次的数字 https://leetcode-cn.com/problems/single-number/ 137-只出现一次的数字II https://leetcode-cn.com/problems/single-number-ii/ 260-只出现一次的数字III https://leetcode-cn.com/problems/single-number-iii/ 先看136，位运算的经典题，知乎凡是有吹位运算的回答的，没有不拿这题开刀的。 原理是a ^ b ^ b = a 1234567public int singleNumber(int[] nums) { int res = nums[0]; for(int i = 1; i &lt; nums.length; i++){ res ^= nums[i]; } return res;} 跳过137，先看260题，相比136题它从一个数变成了两个数，难度大了很多 思路： 我们假设只出现一次的两个数为a, b，按照136题的思路，遍历异或，得到的结果应该是res = a ^ b res中二进制为1的位就是a和b二进制不一样的位，不管哪个1，我们可以将这个位为1的所有数和这个位为0的所有数分开，那么就可以得到两组数 a, c, c b, d, d 又成为了136题的情况 1234567891011121314151617181920212223242526272829public int[] singleNumber(int[] nums) { int[] res = new int[2]; int orRes = nums[0]; //orRes = a ^ b for (int i = 1; i &lt; nums.length; i++) { orRes ^= nums[i]; } int lowBit1 = findLow1(orRes); //用lowBit1这一位分成两组，分别进行异或，和136题一样 for (int i = 0; i &lt; nums.length; i++) { if ((nums[i] &gt;&gt; lowBit1 &amp; 1) == 1){ res[0] ^= nums[i]; }else { res[1] ^= nums[i]; } } return res;}//找一位1，哪一位都行，我这里取得是最低位，方便public int findLow1(int num){ int i = 0; while (num != 0 &amp;&amp; (num &amp; 1) != 1){ num = num &gt;&gt; 1; i++; } return i;} 137题 这题放到最后讲是因为说实话比较难，难在前面的是其他元素出现两次，而“异或”这个位运算刚好使得b^b=0。这题难在出现了3次，意味着我们需要设计一个“运算”，使得b★b★b=0 评论区的代码大多是这样的，却没解释清楚 12345678public int singleNumber(int[] nums) { int a = 0, b = 0; for (int x : nums) { a = (a ^ x) &amp; ~b; b = (b ^ x) &amp; ~a; } return a;} 我认为解释的最好的是题解的这一篇 https://leetcode-cn.com/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/ 简单解释就是3种状态需要两位，所以从00，01，10，11四个中任选3个，比如00，01，10，那么需要画真值表使其满足00-&gt;01, 01-&gt;10, 10-&gt;00 Z是什么，Z为1代表这个数出现了，那么 一开始为00，Z第一次出现00-&gt;01，第二次出现01-&gt;10，第三次出现10-&gt;00 那么就可以写表达式了，根据数电的知识，写x_new只看x_new为1的 事实上，我认为到这一步就够了，化简什么的一时半会写不出来，那么我们就以这个为例，写的时候要注意，不要直接变x而是用x_new存起来，否则计算y_new时改变了x的值。当然，python可以a, b = b, a另说 123456789public int singleNumber(int[] nums) { int x = 0, y = 0; for (int z : nums) { int x_new = (x &amp; ~y &amp; ~z) | (~x &amp; y &amp; z); int y_new = (~x &amp; ~y &amp; z) | (~x &amp; y &amp; ~z); x = x_new; y = y_new; } return y;} 至于化简完，就是前面贴的那个样子了，我数电不好，靠你们了 其他题目点击这里","link":"/algorithms/single-number/"},{"title":"21-合并两个有序链表","text":"力扣21 https://leetcode-cn.com/problems/merge-two-sorted-lists/ 123456789101112131415161718public ListNode mergeTwoLists(ListNode l1, ListNode l2) { //虚拟头部 ListNode root = new ListNode(), cur = root; //先合并公共长度部分 while (l1 != null &amp;&amp; l2 != null){ if (l1.val &lt;= l2.val) { cur.next = l1; l1 = l1.next; }else { cur.next = l2; l2 = l2.next; } cur = cur.next; } //剩下的直接接上 cur.next = (l1 == null) ? l2 : l1; return root.next;} 其他链表类型的题目点击这里","link":"/algorithms/merge-two-sorted-lists/"},{"title":"252-会议室","text":"力扣252 / lintcode920 / 字节原题 会议室 https://www.lintcode.com/problem/meeting-rooms/description 给定一系列的会议时间间隔，包括起始和结束时间[[s1,e1]，[s2,e2]，…(si &lt; ei)，确定一个人是否可以参加所有会议。 示例1 1234输入: intervals = [(0,30),(5,10),(15,20)]输出: false解释:(0,30), (5,10) 和 (0,30),(15,20) 这两对会议会冲突 示例2 1234输入: intervals = [(5,8),(9,15)]输出: true解释:这两个时间段不会冲突 思路：曾经做过合并区间，用了两种方法，当时提过一定要以代码量少/速度快为前提（这是笔试题），因此一定要按开始时间排序，排序完就简单多了，遍历判断后一个的开始时间是否大于前一个的结束时间 12345678910111213141516171819202122232425262728293031323334public class nine_two_zero_会议室 { @Test public void test(){ List&lt;Interval&gt; intervals = new ArrayList&lt;&gt;(); intervals.add(new Interval(5,8)); intervals.add(new Interval(9,20)); boolean res = canAttendMeetings(intervals); System.out.println(res); } public boolean canAttendMeetings(List&lt;Interval&gt; intervals) { if (intervals == null || intervals.size() == 0){ return true; } Collections.sort(intervals, (o1, o2) -&gt; (o1.start - o2.start)); int preEnd = -1; for (Interval interval : intervals) { if (interval.start &lt; preEnd){ return false; } preEnd = interval.end; } return true; } public class Interval { int start, end; Interval(int start, int end) { this.start = start; this.end = end; } }} 其他排序的题目点击这里","link":"/algorithms/meeting-rooms/"},{"title":"24-两两交换链表中的节点","text":"力扣24 https://leetcode-cn.com/problems/swap-nodes-in-pairs/ 链表题还是做太少了呀 1234567891011121314151617public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode post = head, pre = post, temp = null; head = head.next; while (pre != null &amp;&amp; pre.next != null){ //交换 pre = post.next.next; post.next.next = post; //两段连接 if (temp != null) temp.next = post.next; //移动到下一个位置 temp = post; post = pre; } temp.next = pre; return head;} 像temp这种要延迟一轮的，可以把初始值设为null，然后while循环中if (temp != null)，可以达到延迟一轮的效果 或者是while的周期安排得更好一点，比如下面大佬写的 1234567891011121314public ListNode swapPairs2(ListNode head) { ListNode pre = new ListNode(0); pre.next = head; ListNode temp = pre; while(temp.next != null &amp;&amp; temp.next.next != null) { ListNode start = temp.next; ListNode end = temp.next.next; temp.next = end; start.next = end.next; //这步先，就很妙，不需要方法1那样保留上一个 end.next = start; temp = start; } return pre.next;} 周期就安排的很好 temp-&gt;start-&gt;end，start和end是要交换的，temp永远在他们后面一个，方便对start这个节点操作 而上面我写的周期为 断裂的两个节点 post-&gt;b-&gt;pre，要交换的是post和b，这时候就要用temp将断裂的连上post，比较憨 其他链表类型的题目点击这里","link":"/algorithms/swap-nodes-in-pairs/"},{"title":"3-无重复的最长字串","text":"力扣3/牛客NC41 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 这道题，这个思路很妙 用一个长度为26的数组记录出现的字符次数，如alph[0] = 1就代表a出现了1次 最大不重复子串可能出现在哪里？用|代表两端，o代表任意字符，x代表重复字符，过程如下： |ooxoo|x 下一个不为0（alph[r + 1] ！= 0），也就是|内|有重复o|oxoo|x 左边不断收缩，因为左边统计过，右边不可能更长oo|xoo|xoox|oo|x 右边才可以继续前进oox|oox|… 123456789101112131415public int lengthOfLongestSubstring(String s) { int[] alph = new int[256]; int l = 0, r = 0, result = 0; while (r &lt; s.length()){ if (alph[s.charAt(r)] == 0){ result = Math.max(result, r - l + 1); alph[s.charAt(r)]++; r++; }else { alph[s.charAt(l)]--; l++; } } return result;} 其他字符串类型的题目可以点击这里","link":"/algorithms/longest-substring-without-repeating-characters/"},{"title":"31-下一个排列","text":"力扣31 https://leetcode-cn.com/problems/next-permutation/ 也就是比当前排列大的最小排列，这题说实话有点考思维，有点像智力题 我直接给出结果再分析 从后往前找第一个nums[i] &lt; nums[i + 1]，交换，将[i+1 : n]排序 分析 其实我说完结论你细想确实是这么回事 一般来说我们几个数字做排列的时候， 想排出最大的数字，肯定是大数放前面。换句话说，只要不是满足nums[i] &gt; nums[i + 1]，就一定不是最大的排列 想排出最小的数字，肯定是小数放前面。 那么如果我们想找到比某个排列大的排列，我们也应该遵从这个思路 先从后往前找nums[i] &lt; nums[i + 1]，交换那么nums[i] &gt; nums[i + 1]，那么这个数一定比当前的大 将剩下的[i+1 : n]升序排序 两步可互换 举个例子： 如果要找比[1, 5, 6, 4]大的排列，先找到5 &lt; 6，交换，[1,6,5,4]，这个排列一定比原来的大，将[5,4]升序排序，[1,6,4,5]，就找到了比这个排列大的最小排列 思路清晰，这题写起来并不难 12345678910111213141516public void nextPermutation(int[] nums) { for (int i = nums.length - 2; i &gt;= 0; i--) { if (nums[i] &lt; nums[i + 1]){ Arrays.sort(nums, i + 1, nums.length); for (int j = i + 1; j &lt; nums.length; j++) { if (nums[j] &gt; nums[i]){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; return ; } } } } Arrays.sort(nums); //题目要求已经是最大排列的话，变回最小} 其他题目点击这里","link":"/algorithms/next-permutation/"},{"title":"297-二叉树的序列化和反序列化","text":"力扣297 / 剑指offer37 https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/ https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/ Java 优化后稳定12ms 12345678你可以将以下二叉树： 1 / \\ 2 3 / / 4 5序列化为 &quot;[1,2,3,4,null,5]&quot; 这是一道困难题，题目没有要求采用什么顺序进行序列化，只要能序列化能还原就行 示例用的是层次遍历，其实力扣以前的树题目也都是采用这个，本文也采用这个 我的BFS解法serialize()：将二叉树层次遍历序列化为字符串 要注意和普通的bfs模板不同的地方： 去掉if(cur.left != null)，要把null也加进来，并append(“null,”) 第一步改造后会在queue的末尾产生多余null值（1,2,3,4,null,5,null），要去除多余的null则需改变while结束条件：记录有效节点数而不是!queue.isEmpty() 1234567891011121314151617181920212223public String serialize(TreeNode root) { if (root == null) return \"[]\"; StringBuilder sb = new StringBuilder(\"[\"); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int validNum = 1; //记录有效节点数 while (validNum != 0){ TreeNode cur = queue.poll(); if (cur != null){ validNum--; sb.append(cur.val); queue.offer(cur.left); //null也加进来 if (cur.left != null) validNum++; //null不计入有效节点 queue.offer(cur.right); //null也加进来 if (cur.right != null) validNum++; //null不计入有效节点 }else { sb.append(\"null\"); } if (validNum != 0) sb.append(\",\"); } sb.append(\"]\"); return sb.toString(); } 优化了一下，if (validNum != 0) sb.append(&quot;,&quot;);原来使用sb.setLength内部还是调用了Arrays.fill，里面是循环，原来在12-16ms波动 deserialize()：反序列化，用层次遍历字符串序列重构二叉树 遍历一遍，因为字符串是记录了null的，因此肯定是一左一右，树这边，需要用队列记录根节点才知道挂到哪一棵树上 12345678910111213141516171819202122public TreeNode deserialize(String data) { if (data.equals(\"[]\")) return null; String[] nodes = data.substring(1, data.length() - 1).split(\",\"); TreeNode root = new TreeNode(Integer.parseInt(nodes[0])); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int i = 0; while (i &lt; nodes.length){ TreeNode cur = queue.poll(); i++; if (i &lt; nodes.length &amp;&amp; !\"null\".equals(nodes[i])){ cur.left = new TreeNode(Integer.parseInt(nodes[i])); queue.offer(cur.left); } i++; if (i &lt; nodes.length &amp;&amp; !\"null\".equals(nodes[i])){ cur.right = new TreeNode(Integer.parseInt(nodes[i])); queue.offer(cur.right); } } return root;} DFS解法我看到时间短的解法都是DFS，我也没有做，找了个提交记录2ms的，有时间再看，记录一下 1234567891011121314151617181920212223242526272829303132333435363738public class Codec { // Encodes a tree to a single string. StringBuilder res; int i ; public String serialize(TreeNode root) { res = new StringBuilder(); serializeDFS(root); return res.toString(); } public void serializeDFS(TreeNode root) { if (root==null) { res.append(\"#\"); return ; } res.append((char) (root.val+'0')); serializeDFS(root.left); serializeDFS(root.right); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { return deserializeDFS(data.toCharArray()); } public TreeNode deserializeDFS(char[] chars) { if (chars[i]=='#') { i++; return null; } TreeNode root = new TreeNode(chars[i++]-'0'); root.left = deserializeDFS(chars); root.right = deserializeDFS(chars); return root; }} 娱乐解法提交完后我去提交记录里看了看0ms和1ms的示例… 以下代码仅供娱乐 0ms 笑死我了，真是人才，由于不限定序列化的方式，因此判题系统只判断deserialize函数 123456789101112public class Codec { TreeNode node; public String serialize(TreeNode root) { node = root; return \" \"; } public TreeNode deserialize(String data) { return node; }} 32ms c语言强转，看起来可行，但实际上是在内存中取地址，跨机发送和网络传输地址不同不可行 1234567char* serialize(struct TreeNode* root) { return (char *)root;}struct TreeNode* deserialize(char* data) { return (struct TreeNode *)data;} 其他树的题目点击这里","link":"/algorithms/serialize-and-deserialize-binary-tree/"},{"title":"235/236-二叉树最近公共祖先","text":"力扣235 https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ 二叉搜索树的性质：左子树&lt;根&lt;右子树。因此当前节点要做的事情很简单： 我们只需要判断当前节点和要找的两个节点p, q比较大小 root.val比p.val和q.val都小，公共节点肯定不是他，在右子树 root.val比p.val和q.val都大，公共节点肯定不是他，在左子树 root.val在p.val和q.val之间，公共节点肯定是他 对于特殊情况：公共祖先就是p或者q的情况，因为我们递归从上往下遍历，先到达的那个是p就返回p，是q就返回q，所以这个特殊情况的判断放在前序遍历的位置 123456789101112public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return root; if (p == root || q == root) return root; //越靠近根的那个是在前序遍历位置 if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) { return lowestCommonAncestor(root.left, p, q); }else if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) { return lowestCommonAncestor(root.right, p, q); } return root;} 妙就妙在判断的顺序，先判断全左和全右，这样就不需要判断p和q哪个大，夹在中间时p &lt; root &lt; q还是q &lt; root &lt; p 力扣236 https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ 思考过程：没有了二叉排序树的性质，那只能左右遍历了，当前节点要做的事：如果左右子树包含p,q就说明当前节点是最近公共祖先。那p,q肯定不会说一直都在同一层，所以是由下层返回的才能判断，后序遍历位置理所当然 思路：后序遍历位置，左右递归后返回的结果记录下来，返回的结果应该是：如果是要找的p或q，那么一直沿父节点返回，否则直接返回null。那么递归回来的时候，公共祖先左右两边节点就是p和q，否则的话左右两边为null 看图比较直观： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960后序遍历，所以从叶子节点开始，假设树如下，要找的节点是8和4 3 / \\ / \\ / \\ / \\ 5 1 / \\ / \\ / \\ / \\ 6 2 0 8 / \\ 7 4 3 / \\ / \\ / \\ / \\ 5 1 / \\ / \\ / \\ / \\ 6 2 0 8 / \\ null 4 3 / \\ / \\ / \\ / \\ 5 1 / \\ / \\ / \\ / \\ null 4 null 8 / \\ null 4 3 / \\ / \\ / \\ / \\ 4 8 / \\ / \\ / \\ / \\ null 4 null 8 / \\ null 4 3 返回到当前节点为3时，左右都不为null(不需要判断具体左和右)，成了 / \\ / \\ / \\ / \\ 4 8 / \\ / \\ / \\ / \\ null 4 null 8 / \\ null 4 代码如下 12345678910111213public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return root; if (p == root || q == root) return root; //找到了 TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left!=null &amp;&amp; right != null) return root; //只需要判断是否为null else if (left != null) return left; else if (right != null) return right; return null;} 妙就妙在只需要判断是否为null即可而不需要判断是否是p还是q，不为null那么一定是p或者q，左右都不为null一定是公共祖先 特殊情况：p,q恰好是公共祖先的特判刚好也能判到","link":"/algorithms/lowest-common-ancestor-of-a-binary-tree/"},{"title":"40-组合总和II","text":"力扣40 https://leetcode-cn.com/problems/combination-sum-ii/ 无脑套回溯模板就vans了 这题能评中等，大概率是因为去重的方式吧 题目比较简单，套模板五分钟就秒杀了吧，我就只贴leetcode模式代码了 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { backtrace(candidates, target, new ArrayList&lt;&gt;(), 0, 0); return new ArrayList&lt;&gt;(res);}private Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;();public void backtrace(int[] candidates, int target, List&lt;Integer&gt; path, int index, int sum){ //结束条件：路径中的和等于target if (sum == target){ ArrayList&lt;Integer&gt; re = new ArrayList&lt;&gt;(path); Collections.sort(re); res.add(re); return ; } for (int i = index; i &lt; candidates.length; i++) { //剪枝 if (sum &gt; target) return ; //做选择 sum += candidates[i]; path.add(candidates[i]); //递归 backtrace(candidates, target, path, i + 1, sum); //撤销 sum -= candidates[i]; path.remove(path.size() - 1); }} 以上方法，慢，但不是慢在set去重，博客曾经也提到过，Set去重效果比List.contains快了不止一个数量级，实际上，HashSet去重是O(1)的，因此是慢在结束条件的Collections.sort(re); 嗯，一开始就先对candidates排序，那么如果第二次加入的元素和前一次一样，那么就直接continue 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); //一次性排序 backtrace2(candidates, target, new ArrayList&lt;&gt;(), 0, 0); return new ArrayList&lt;&gt;(res);}private Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;();public void backtrace2(int[] candidates, int target, List&lt;Integer&gt; path, int index, int sum){ //结束条件：路径中的和等于target if (sum == target){ res.add(new ArrayList&lt;&gt;(path)); return ; } for (int i = index; i &lt; candidates.length; i++) { //剪枝 if (sum &gt; target) return ; //做选择 if(i &gt; index &amp;&amp; candidates[i] == candidates[i-1]) continue; //去重，第二次加入和前一次一样，则continue sum += candidates[i]; path.add(candidates[i]); //递归 backtrace2(candidates, target, path, i + 1, sum); //撤销 sum -= candidates[i]; path.remove(path.size() - 1); }} 其他回溯的题目可以点击这里","link":"/algorithms/combination-sum-ii/"},{"title":"357-计算各个位数不同的数字个数","text":"力扣357 https://leetcode-cn.com/problems/count-numbers-with-unique-digits/ 虽然标签时回溯，但是不要回溯，这一看就是数学题 思路：对于n位的数，首位（第一位）不能为0，所以有9种选择（1~9），第二位则有9种选择，第三位8种选择，第四位7种选择… 不考虑首位，从第二位开始，选择数是递减的。最后再乘上首位一定是9种。 当首位为0时，实际上退化为n-1位数，也就是说，变成了动态规划问题，记录dp[n-1]的结果 举个例子： 已知n=1时有0~9，10种情况 n=2：十位不为0(假设取了9)，个位有9种情况(0~8)，个位为0实际上就是n=1的10种情况，res = 9 * 9 + 10 = 91 n=3：百位不为0时有9种，十位有9种，个位有8种，个位为0时实际上就是n=2，res = 9 * (9 * 8) + 91 = 739 n=1：res = 9 * (9 * 8 * 7) + 739 也就是dp了，这种题就属于一开始看不出dp那种 代码如下： 1234567891011121314public int countNumbersWithUniqueDigits(int n) { if(n == 0) return 1; int[] dp = new int[n + 1]; dp[1] = 10; for (int i = 2; i &lt;= n; i++) { int time = i, num = 9, product = 1; while (--time != 0){ product *= num; num--; } dp[i] = 9 * product + dp[i - 1]; //最后再乘上首位的9种 } return dp[n];} 直接双百 其他动态规划的题目可以点击这里","link":"/algorithms/count-numbers-with-unique-digits/"},{"title":"404-左叶子之和","text":"力扣404 https://leetcode-cn.com/problems/sum-of-left-leaves/ 当前节点：如果是左叶子，加入res？？？当然错，因为我们无法判断当前节点是左叶子还是右叶子（root.left == null &amp;&amp; root.right == null只能判断是否是叶子节点） 因此“当前节点”应该是从上一层的父节点开始if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null)，是不是就显得理所当然了？ 123456789101112private int res = 0;public int sumOfLeftLeaves(TreeNode root) { if (root == null) return 0; //这个0是随意的,反正结果跟这个也没关系 if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null){ res += root.left.val; } sumOfLeftLeaves(root.left); sumOfLeftLeaves(root.right); return res;} 其他树的题目点击这里","link":"/algorithms/sum-of-left-leaves/"},{"title":"424-替换后的最长重复字符","text":"力扣424 https://leetcode-cn.com/problems/longest-repeating-character-replacement/ 滑动窗口题目，需要用数组或者map统计每个字母出现的次数 1234567891011121314151617181920public int characterReplacement2(String s, int k) { int l = 0, r = 0, res = 0, count = 0; //count是窗口里最多的字母的个数 int[] alph = new int[26]; char[] ch = s.toCharArray(); while(r &lt; ch.length){ alph[ch[r] - 'A']++; count = Math.max(count, alph[ch[r] - 'A']); //统计窗口里最多的字母的个数 r++; // 判断k是否够用，如果r - l &gt; count + k，那就说明窗口里的str[r]+可以替换的k都不够占满窗口，窗口里必然有其他的字母 if(r - l &gt; count + k){ alph[ch[l] - 'A']--; l++; } res = Math.max(res, r - l); } return res;} python实现 12345678910111213141516171819def characterReplacement(self, s: str, k: int) -&gt; int: l, r, res, count = 0, 0, 0, 0 # count是窗口里最多的字母的个数 alph = {} while r &lt; len(s): if s[r] in alph: alph[s[r]] += 1 else: alph[s[r]] = 1 count = max(count, alph[s[r]]) r += 1 # 判断k是否够用，如果r - l &gt; count + k，那就说明窗口里的str[r]+可以替换的k都不够占满窗口，窗口里必然有其他的字母 if r - l &gt; count + k: alph[s[l]] -= 1 l += 1 res = max(count, r - l) return res 其他滑动窗口类型的题目可以点击这里 其他字符串类型的题目可以点击这里","link":"/algorithms/longest-repeating-character-replacement/"},{"title":"43-字符串相乘","text":"力扣43 字符串相乘 https://leetcode-cn.com/problems/multiply-strings/ 思路：此题和大数相加有些类似，这种通过字符串模拟手算加法乘法的，仍然采用这种从高位到低位，进位和基数分开的方式，更加简洁方便 过程如下 代码如下 要注意基数数组和进位数组的长度，如上图最左边的8，也就是有可能首位进位，因此长度是len(num1 + num2)而不是len(num1 + num2 - 1) 1234567891011121314151617181920212223242526272829public String multiply(String num1, String num2) { int[] jiShu = new int[num1.length() + num2.length()]; //基数数组 int[] jinWei = new int[num1.length() + num2.length()]; //进位数组 for (int i = 0; i &lt; num1.length(); i++) { for (int j = 0; j &lt; num2.length(); j++) { int bit1 = num1.charAt(i) - '0'; int bit2 = num2.charAt(j) - '0'; int add = bit1 * bit2 + jiShu[i + j + 1]; jiShu[i + j + 1] = add % 10; //关键步骤 jinWei[i + j] = add / 10 + jinWei[i + j]; //关键步骤 } } //将基数和进位从低位向高位相加得出最终结果 int[] res = new int[jinWei.length]; for (int i = jinWei.length - 1; i &gt;= 0; i--) { int num = jiShu[i] + jinWei[i] + res[i]; res[i] = num % 10; if (i - 1 &lt; 0) break; res[i - 1] += num / 10; } //转换成字符串，注意开头为0和全0情况 StringBuilder sb = new StringBuilder(); boolean flag = false; //遇到开头不为0时才能插入 for (int i = 0; i &lt; res.length; i++) { if (res[i] != 0) flag = true; if (flag) sb.append(res[i]); } return \"\".equals(sb.toString()) ? \"0\" : sb.toString();} 其他字符串类型的题目点这里","link":"/algorithms/multiply-strings/"},{"title":"406-根据身高重建队列","text":"力扣406 https://leetcode-cn.com/problems/queue-reconstruction-by-height/ 思路很重要 先排序：身高从低到高排序，前面人数从大到小排序 排完后[[4,4],[5,2],[5,0],[6,1],[7,1],[7,0]] 从后往前遍历 [7,1]表示往后挪一个：[[4,4],[5,2],[5,0],[6,1],[7,0],[7,1]] [6,1]表示往后挪一个：[[4,4],[5,2],[5,0],[7,0],[6,1],[7,1]] 后同… 代码不难，思维题 1234567891011121314151617public int[][] reconstructQueue(int[][] people) { //身高从低到高排序，前面人数从大到小排序 Arrays.sort(people, (o1, o2) -&gt; { if (o1[0] != o2[0]) return o1[0] - o2[0]; else return o2[1] - o1[1]; }); //从后往前调整顺序，people[i, j]表示people[i]往后调整j个 for (int i = people.length - 2; i &gt;= 0; i--) { int time = people[i][1]; int[] temp = people[i]; for (int j = i; j &lt; i + time; j++) { people[j] = people[j + 1]; } people[i + time] = temp; } return people;} 其他题目点击这里","link":"/algorithms/queue-reconstruction-by-height/"},{"title":"3D数学基础图形与游戏研发笔记","text":"本文所有公式都是在右手系下的，也就是v’ = M * v。如果换成左手系，那么根据矩阵转置公式v’(T) = v(T) * M(T)可得，需要将矩阵M进行一次转置并将左乘改为右乘，正角度也需要从逆时针改为顺时针 1. 向量1.1 向量点乘也叫点积，数量积，结果是一个数量 几何形式：a · b = ||a|| * ||b|| * cosθ 代数形式： 图形学意义： 可以计算一个向量在另一个向量上的投影 通过计算夹角θ可以判断两个向量是否同向，如果点乘结果＜0，或者θ＞90°，或者cosθ＜0，那么我们说两个向量反向 在聚光灯的效果计算中，可以根据点积来得到光照效果，如果点积越大，说明夹角越小，则物体离光照的轴线越近，光照越强 1.2 向量叉乘结果是一个向量 几何形式：||a * b|| = ||a|| * ||b|| * sinθ，其模长为如下平行四边形的面积 代数形式： 图形学意义： 对于两个向量，叉乘的结果实际上是两个向量组成的平面的法线方向，方向满足右手定则 可以判断左右，对于a, b, c三个点，判断c点是否在线段ab的左边，只需要作向量ab, ac, 做叉积，右手定则结果为正（指向屏幕外面）则在左边 进一步可以用来判断内外/前后，对于三角形abc三个顶点外加三角形内部一个d点，如果d点在三个顺时针向量ab, bc, ca的左边，则d在三角形abc内部 2. 矩阵矩阵相乘不满足交换律 很多时候，我们更加习惯于将向量看成是n * 1的矩阵，而且经常会将向量和矩阵混合运算（比如将矩阵和向量做一些乘法等运算） 2.1 向量点乘和叉乘的矩阵形式如上所说，不管是为了方便混合运算也好或者是为了代码实现更加统一也好，向量点乘和叉乘也可以统一写成“矩阵乘法”形式 叉乘的a变成的这个矩阵称为a的对偶矩阵 3. 线性变换使用一些矩阵左乘列向量在图形学上通常有一些特殊的意义，比如旋转，平移等变换，需要知道一些特殊的变换（以2D坐标为例） 3.1 缩放变换 3.2 镜像变换 3.3 切变变换 3.4 旋转变换 3.5 平移变换平移变换稍微有点不同 3.6 使用齐次坐标巧妙统一线性变换不难发现，前面几个变换都可以写成x’ = Mx的形式，但是平移变换只能写成x’ = x + b的形式，那么我们完成上述变换可以统一写成x’ = Mx + b的形式，如下： 后面这个项不够优雅，但是如果我们对其扩展一个维度，就可以统一写成x’ = Mx的形式了。 什么意思呢？就是说对于一个二维坐标(x, y)，写成列向量的时候添加一个w维度，(x, y, 1)T，（T是转置成列向量的意思，否则编辑器不好写列向量），那么可以发现平移变换也可以写成如下x’ = Mx的形式了 是不是很巧妙？这种写法称为齐次坐标，在齐次坐标表示法下，w维度为1则表示向量，w为0则表示一个点 有了齐次坐标，我们就可以把以上所有3.1-3.5的变换统一写成x’ = Mx的形式了 非常优雅（主要是方便代码实现） 这里abcd是一般化写法，前面几个特殊的变换还是跟前面是一样的，自己推一下就能写出如下几个常用的了 3.7 *推广到3维坐标以上，都是以2D坐标为例，3维下大致相同，其次坐标为(x, y, z, w)，线性变化一般化公式为： 特殊的如下： Shear： 1234567891011Hxy(s, t) = [1 0 s 0 1 t 0 0 1] Hxz(s, t) = [1 s 0 0 1 0 0 t 1] Hyz(s, t) = [1 0 0 s 1 0 t 0 1] Hxy(s, t)表示用z切变x、y，最终x += sz，y += tz，z不变 3.8 绕任意轴的旋转绕单位向量n(nx, ny, nz)逆时针旋转θ 推导过程可以看这篇文章 https://zhuanlan.zhihu.com/p/56587491 再次提醒：本文所有公式都是在右手系下的，如果换成左手系，那么需要将矩阵进行一次转置并将左乘改为右乘，并注意正角度需要改为顺时针 这个公式比较复杂，对于计算机运算也比较慢，可以通过欧拉角和四元数进行绕任意轴的旋转比较简便，附录中有介绍 3.9 绕任意轴的镜像平面的单位法向量n(nx, ny, nz) 4. 视图变换(View)第三章说的线性变换是对物体进行变换，也就是model，加上第四第五张介绍的view和projection，合称mvp变换 用照相的例子来比喻就是： 找一个好的地点并调整好被拍摄者的占位(model) 调整相机角度(view) 茄子(projection) 所以视图变换就是：调整相机位置、确定拍摄方向、摆正相机水平角度这个过程（当然要灵活点，所谓相机就是观测者的眼睛，不一定非得是相机） 怎么摆正相机呢？在数学上怎么表示呢？通常我们将相机位置设为原点构建坐标系，相机摆正为垂直向上的y方向，看向-Z方向，那么自然x的方向虽然没有意义，但是就可以使用(g * t)叉乘得出 5. 投影变换(Projection) 5.1 正交投影(Orthographic)正交投影比较简单，投影到某个面，就把法线方向的“深度”去掉，比如投影到xy平面，就把z值置为0即可 当然，这个矩阵是默认了物体经过原点的，如果看了games101，发现正交投影并没有这么做，而只是将空间中的物体移动到以原点为中心，并缩放到 [-1, 1]³中，并且保留了z。那这完全不一样呀… 通常情况下我们说投影，投影平面是屏幕（或者说是C++运行的那个窗口），如果物体在视野外没有被看到，那么想投影就必须先被相机看到，我们不移动相机，而是移动物体，于是才有了games101中的移动并缩放到 [-1, 1]³，而保留z是因为games101不仅仅是做投影，还要后面的深度遮挡绘制和光栅化，所以这里先保留了深度值。因此games101中的投影并没有真正的投影，而是将物体规整到 [-1, 1]³这个空间中，让相机能够“看到” 上面这种情况才是一般情况，因为通常我们的场景被称为世界坐标（观测者在原点，可能出现正负坐标），但是我们投影完成后应该输出在屏幕（左上角为原点，只有正的二维坐标），所以games101中实际上做的是世界坐标-&gt;屏幕坐标的转换 5.2 透视投影(Perspective)上面说过了什么是透视投影，一般在透视投影时，我们需要width, height, zNear, zFar这几个参数，zNear和zFar代表了远近平面的z值，只有在这个范围内的物体才会被看到。可以认为人的眼睛就是摄像机，电脑屏幕就是近平面，视力距离就是远平面。 而对于width, height，我们通常只取一个值比如height，另一个通过屏幕的宽高比获取，但是更常用的方法是连height也不直接指出，而是通过fov，称为视角的东西给出。这是因为比如我们要做一个睁眼特效，那么就可以通过不断的改变视角大小最后才达到屏幕高度（完全睁开眼） 6. 几何图元介绍一些图元的常用表示方式 直线 1234class Line3D{ Vector3 origin; //起点 Vector3 end; //终点} 射线 1234class Ray3D{ Vector3 origin; //起点 Vector3 delta; //单位方向向量} 球 1234class Sphere{ Vector3 center; //求球心 float radius; //半径} AABB（轴对齐矩形边界框） 也就是将某个不规则物体框起来的长方体box，记录两个对角顶点的向量 1234class AABB{ Vector3 min; //xyz最小顶点 Vector3 max; //xyz最大顶点} 顶点顺序如下图 这个顺序的好处是当我们求某个顶点坐标时 123456Vector3 AABB::corner(int i){ assert(i &gt;= 0); assert(i &lt;= 7); return Vector3((i &amp; 1) ? max.x : mix.x, (i &amp; 2) ? max.y : mix.y, (i &amp; 4) ? max.z : mix.z);} 因为从0~7，x是小大一周期，y是小小大大一周期，z是小小小小大大大大一周期，算是一个小trick AABB对于物体旋转，物体旋转，AABB也跟着旋转，要计算的是旋转后的物体的AABB还是原来AABB的AABB 如果是前者，那么可以对旋转后的物体重新做AABB即可。如果想得到后者，需要对原AABB做旋转，然后再得出max和min的坐标，这里的计算也有个小trick，就是并不需要真正的和旋转矩阵相乘，因为我们知道旋转矩阵乘法后为 x’ = m11x + m21y + m31z y’ = m12x + m22y + m32z z’ = m13z + m23y + m33z 观察即可知道，想得到x’max，那么如果m11为正则取xmax，如果为-则取xmin，其他同理，因此实现时只需要对9个m不断if判断即可 123456789if(m11 &gt; 0.0f){ min.x += m11 * old.min.x; max.x += m11 * old.max.x;}else{ min.x += m11 * old.max.x; max.x += m11 * old.min.x;}... //继续+=其他m得出x,y,z 平面 按照高中数学，平面方程有一般式（三点），点法式（平面上一点+法向量），截距式 https://zhuanlan.zhihu.com/p/102514602 对于一般式ax+by+cz+d=0，则法向量是(a,b,c) 如果点p(x0, y0, z0)是平面上一点，则pn作为向量做点乘，得到d，d是原点到这个平面的距离 3D中，有时候很多个点在一个近似平面上，求一个离所有点距离之和最小的“最佳”平面，做一个类似回归的计算 多边形 简单多边形（没有洞）描述顶点只需要依次顺时针给出坐标，但是如果是有洞的多边形，我们可以通过切缝的方式变为简单多边形 7. 几何检测7.1 距离检测一个点到xxx的最近点 2D直线上的最近点 q’ = q + (d - q·n)n 其实就是从点p做该直线的垂线，和直线相交的点 射线上的最近点 q’ = p + (d·(q - p))d 其中p为射线起点，d为射线方向单位向量， 平面上的最近点 q’ = q + (d - q·n)n 和直线是一样的，因为都是垂线 球上的最近点 q’ = q + (||c - q|| - r) * (c - q) / ||d|| 是圆心c和q减去半径那段，方向是q方向 AABB上的最近点 这个在游戏开发中比较常用，比如飞机游戏，当我们瞄准一个物体的时候，我们瞄准目标物体AABB中最近的一个点即可 方法也很简单，直接判断点(x, y, z)和目标物体所在的AABB大小，比如小于AABB的minx则取minx，大于maxx则取maxx，在中间则取目标物体的x 7.2 相交检测2D中两条直线相交性检测 3D中两条射线相交性检测 射线和平面相交性检测 三个平面间相交性检测 射线和球相交性检测 两个球/圆相交性检测 球和平面相交性检测 //TODO 这里涉及到大量的公式，后序补上，都出自《图形图像编程精粹I》和《3D数学基础：图形与游戏开发》13章 8. 三角形和网格三维的模型一般都会分解成无数个三角形网格以方便渲染弧面和纹理映射 关于网格，目前的图形库（比如DirectX和opengl）大都设计成以下结构 1234567class Vertex{ //顶点类 Vector3 p; //一个3维向量，表示一个顶点，包含xyz坐标 float u, v; //u v坐标用于纹理映射 //其他信息 Vector3 normal; //用于Gouraud shading的顶点法向量} 123456class Triangle{ //三角形类 Vertex vtx[3]; //一个三角形包含3个顶点 //其他信息 Vector3 normal; //用于Flat shading的三角形法向量} 1234567891011121314class TriMesh{ //三角形网格类 //所谓网格其实就是三角形列表 int vAlloc; //分配的顶点数量，通常会比count多一些，方便扩展，类似于capcity和count int vCount; //需要的顶点数量 Vertex *vList; //保存顶点列表 int tAlloc; //分配的三角形数量，通常会比count多一些，方便扩展 int tCount; //真正需要的三角形数量 Tringle *triList; //保存三角形列表 int addTri(Tringle tri); //增加三角形方法，返回索引 //其他信息} 当然，因为最终操作的其实是网格，网格中其实有顶点了，所以也有些库的三角形类并没有Vertex vtx[3];而是只存了一个index，需要的时候再统一从网格类中根据下标获取顶点，这是标准做法 8.1 三角形和顶点的法向量关于三角形类和网格类都会有一个属性normal，这个法向量会用于shading 三角形法向量的求法：三角形两个边向量做叉乘 e1 = v3 - v2 e2 = v1 - v3 n = e1 * e2 顶点法向量的求法：一个顶点可能是n个三角形的公共顶点，将这n个三角形的法向量求和就是该顶点法向量的方向，再做归一化（很多地方说是相邻三角形的法向量的平均数，仔细看发现其实不是平均数，因为求和后不是/n而是/模长，也就是变成单位向量） 代码实现的时候，我们并不能直接知道某个顶点会连接哪几个三角形，不可能需要算某个顶点法向量的时候去临时遍历一遍所有的三角形。所以一般都计算完三角形的法向量后，做一次求所有顶点的法向量操作：遍历所有的三角形，并将其三个顶点法向量累积，最后遍历一遍所有的顶点做归一化 12345678910111213141516171819202122void Mesh::computerVertexNormals(){ int i; computeTriNormals(); //得到所有三角形的法向量 //旧值清零 for(i = 0; i &lt; vCount; i++){ vertex(i).mormal.zero(); } //将每个三角形的法向量累加到各顶点 for(i = 0; i &lt; tCount; i++){ Tri *t = &amp;tri(i); //其实就是Tri t = triList[i]，我不是很习惯用指针 for(int j = 0; j &lt; 3; j++){ //累计到各顶点 vertex(t-&gt;v[j].index).normal += t-&gt;normal; //其实就是vList[t.v[j].index].normal += t.normal;看不懂可以看下面的解释 } } //所有顶点的法向量归一化 for(i = 0; i &lt; vCount; i++){ vertex(i).normal.normalize(); }} 再说一下，t-&gt;v[j]是三角形类里面有个顶点类的成员v，.index是因为前面说的优化，也就是说这个顶点类并不是真正的Vertex，而是一个内部类Ver（长得都差不多只是成员函数只有索引），vertex(index)就是get函数*vList[index] 8.2 网格操作//TODO 顶点焊接、面拆分，边坍缩，网格削减等等一系列操作，实现见书本14章 9. 图形流水线(图形管道) 建立场景 可见性检测 设置渲染状态 几何体生成与提交 变换和光照 背面剔除与裁剪 投影到屏幕空间 光栅化 像素着色 其实基本上就是从第一行代码到显示在屏幕上所有过程 这几个的步骤不是固定的，有些步骤可以互换，所以如果用不同的图形库，也要遵守他们的流水线 opengl这里是简化图 10. 光照和着色这里说的光照只关注光的效果，不关注光造成的阴影，称为shading，而不关注shadow 10.1 光照blinn-phong反射模型简单的认为光照由三部分组成：环境光，漫反射，高光 La,Ld,Ls的具体内容是什么呢？ 10.1.1 漫反射diffuse漫反射是说是光照在物体上然后反射到眼睛里面去 这个公式如何理解呢？，这只是一个大胆的简化模型，但是是有一定道理的，可以看下面一步步的假设推导 我们可以从I开始，假设一开始光照强度是I，那么经过反射后先视为平行光（视为，不是真的，因为这个是简易模型），那么我们会发现如下图，跟物体平面是否正对着光有关，Lambert余弦指出平面法线和光的夹角余弦值会和光的强度成正比，这确实是有道理的，如下 那么我们就得到了I’ = I*cosθ，cosθ可以替换成两个向量的点乘，同时根据常识可得光最小为0而不会为负数，为0就全黑了，因此 I’ = I * max(I·n) 这是我们认为是平面光源的情况（光无限远或者其他手段），但是光其实是点光源 我们认为光往每个角度平均的向外球面传播，于是我们可以认为强度以圆的半径速率减少 因此光到某个点时的强度为 I’ = (I/r²) * max(I·n) 是不是也有那么点道理？？ 最后我们认为可以控制强度因子，这个我认为你可以想象成雾天什么的，对吧，光还是那么强，只是经过云层等到达的强度就减少了，我们直接认为这个为一个常数因子。当然雾只是个比喻，有了这个因子之后可以方便我们操控光的亮面大小 再次提醒，这一切都是大胆的简化假设，如果以上三步你都认为确实存在一定的道理，那么你就得出上面漫反射部分的公式了 10.1.2 高光Specular高光是一种镜面反射 在Blinn-phong中仍然是在简单的大胆简化假设的基础上进行推导 假设有一面镜子反射太阳光，我们在什么时候会感到刺眼？那就是眼睛刚好在反射角的时候，如下图：如果眼睛在黄色线上，就会感到很刺眼，偏一点点，仍然会刺眼但程度小，越远离黄色线，就越没有刺眼的感觉 为了描述这个偏离的角度，这样子就比较难，这里很巧妙的引入了半程向量这种说法 半程向量非常好求，I+v再归一化为单位向量即可，这个夹角α和偏离角度虽然差了2倍，但是也可以用来描述偏差嘛对吧 和Ld不同的是，我们可以看到一个次数p，这个是什么意思呢？ 在之前漫反射的时候我们说了kd代表漫反射光面的大小，同样的这里的ks也代表高光光面的大小，但是对于高光来说，除了光面还有一个很重要的因素就是亮度，p则代表了光面的亮度，这仍然是有道理的 公式中的其他部分和Ld差不多，就不解释了 10.1.3 环境光Ambient最后是La环境光，当我们用手机夜拍的时候，没有太阳也不开闪光灯，唯一的一点光源只是转角看不到的路灯，你是否希望拍出来的东西是一片黑？？ 不希望吧，我们在一个很暗的环境下，我们希望物体接受到一些墙面或者任何（不光滑的平面）反射过来的那么一丢丢亮度 这很难处理，我们没有办法知道四面八方有多少物体能够给我们提供光源，那么我们干脆简单的认为四面八方都能提供一样强度的一点点光 就是这么简单大胆，于是将上述三个公式Ld, La, Ls一组合，便得到了Blinn-phong模型的完整公式 一切都是这么的妙~啊 10.2 着色三维物体都会表示成一堆三角形的模型，在着色时我们就可以选择对表面，还是顶点还是像素 10.2.1 flat shading对表面求法向量 10.2.2 Gouraud shading对顶点求法向量，求法面第8章也说过了，是该顶点邻接三角形的平均值 10.2.3 Phong shading对每个像素进行着色 诚然，对像素着色效果最好，效率也比较低，但games101中指出，并不是说我们每个时刻都需要phong shading，因为这还取决于三角形的数量，如果三角形足够细化，那么flat shading也是可以有很好的效果的，并给出了对比图 我们可以看到，当模型三角形数量足够多的时候，phong shading带来的提升效果就不明显了，白白增加了计算量 10.3 雾化雾化就是将3D图形和雾的颜色相混合的效果，会造成物体颜色模糊效果 雾化浓度和雾化距离相关，公式如下 计算出雾的浓度后再混入颜色 11. 纹理映射 不管纹理图片大小多大，我们都首先缩放到u, v范围为[0, 1] 然后我们对于uv中间的小数比如0.25、0.5就用插值的方法将图贴上去 //TODO纹理映射中的双线性插值，解决插值中的模糊问题 11.3 纹理复用很多时候纹理贴图都是可以复用的，比如墙壁的砖块，如果墙壁很大，为每一个墙壁制作纹理贴图肯定是不合理的，所以厉害的视觉设计师会将纹理设置成这样： 什么意思呢？就是说我用两张这样的图片从上下左右跟另一张拼在一起，瓷砖纹理都能无缝接合另外一张，这样的纹理就可以复用而不违和 12. 双缓存计算机输出图形时会出现闪烁（物体运动的时候突然消失，然后出现在下一个位置），使用双缓存可以解决闪烁 我们说双缓存，实际上是一个缓存…单缓存实际上是没有缓存…因为默认屏幕显示东西认为是一个缓存…闪烁的原因：原来是擦除上一帧的屏幕并重新绘制，擦除需要时间，绘制也需要时间，擦除完了我们看到原物体消失，重绘完了我们看到新位置物体出现，这就是闪烁。如果加入了缓存，可以直接将下一帧的图片存在缓冲区中，一次性输出到屏幕。 注意，擦除和重绘的时间还是一样慢，但是擦除的不是屏幕，而是缓存，也就是说上一帧还在屏幕上，重新绘制到缓存后，从缓存到屏幕的拷贝是一瞬间的事情 关于双缓存，知道出现的原因和解决的原理即可，哪怕是自己实现也就是swapBuffer，用d3d或者opengl更简单了，一两行代码 13 可见性检测这里不需要自己做，DirectX能自动调用硬件进行快速的可见性检测，原理部分以后再介绍 //TODO 14 抗锯齿所谓锯齿，就是由于屏幕像素太小造成如下不平滑的边缘 原因是对于像素的每个格子，用格子中心的坐标(0.5, 0.5)所在的颜色代表了整个像素格子的颜色 解决方法 物理：使用分辨率更好的显示器 超采样supersampling：MsAA 多重采样multisampling：directx 超采样就是将每个像素细分为四个小格子，对于每个小个子都计算颜色平均值作为当前的颜色。如果分为四个小格子就叫做MsAA4*4，可以更细的距离进行采样，缺点是分的越多计算量越大 以下是games101作业2中的代码（具体逻辑不用深究，就看是不是多了4倍计算） 多了一层for，就是细分的格子数量，所以计算量也随之增大 多重采样是directx和一些图形库的抗锯齿方法，很快，仍然会使用屏幕分辨率4倍大小的后台缓冲和深度缓冲，但是，不像超级采样那样计算每个子像素的颜色，而是只计算像素中心颜色一次，然后基于子像素的可见性（基于子像素的深度/模板测试）和范围（子像素中心在多边形之外还是之内）共享颜色信息。 多重采样直接填充Directx的结构体即可 12345typedef struct DXGI_SAMPLE_DESC{ UINT Count; //用于指定每个像素的采样数量 UINT Quality; //用于指定希望得到的质量级别} DXGI_SAMPLE_DESC, *LPDXGI_SAMPLE_DESC; 不同硬件的质量级别表示的含义不一定相同，质量级别越高，占用的系统资源就越多，所以我们必须在质量和速度之间权衡利弊。具体的说明在后面的d3d文章中介绍，这里只做理论了解 附录多坐标系当我们进行三维场景设计时，我们想旋转单个物体而不能影响其他物体，就不可能去旋转世界坐标系。因此引入了物体坐标系，在世界坐标系和物体坐标系中间为了方便转换还引入了惯性坐标系，如下，世界坐标系和惯性坐标系的转换只需要平移，惯性坐标系和物体坐标系转换只需要旋转 旋转和坐标系变换是一模一样的，只是理解角度不同，一个 active 变换也可以理解为一个坐标系转换变换，反之亦然。在某些情况下，使用多个坐标系统更符合思维习惯，我们可以让物体自身保持不变，只是从一个参考系转换到另一个参考系，由于参考系发生了改变，因此物体的坐标也会随之改变。在另一些情况中，我们不想改变参考系，而只想在同一个参考系中对物体进行变换 所以旋转的作用不仅仅在某个坐标系上旋转物体，还可以用于惯性坐标系和物体坐标系之间的坐标转换，比如对于同一个“i2o转换矩阵”可以通过如下旋转公式相互转换 其实和普通的旋转没有区别，只是说一下旋转有这种作用而已 为了欧拉角的唯一性（多转360°还是同一个角度），我们通常把heading限制在-180° ~ +180°，bank限制在-180° ~ +180°，pitch限制在-90° ~ +90° 欧拉角之前说过绕任意轴旋转公式复杂，计算机也需要保存9个计算复杂的变量，欧拉角对其进行了简化 欧拉角是用三个角度表示方位和旋转，称为角位移： heading角（也称作yaw角）：常用于描述绕y轴（垂直轴）飞机水平偏航 pitch角：常用于描述绕x轴飞机低头抬头 bank角（也称作roll角）：常用于描述绕x轴飞机自身翻滚 三个旋转角绕着三个相互垂直的坐标轴（三个轴可以是任意的），通常是笛卡尔坐标系 注意：欧拉角是基于物体坐标系来旋转的，而不是基于世界坐标系来旋转的，所以通常我们使用欧拉角旋转一个空间坐标下的物体时，记得做惯性系-&gt;物体系的旋转 缺点 表达不唯一，绕某个轴旋转360°还是一样的方位 插值计算复杂 万向锁问题 万向锁问题很多博客用油管那个英文视频举例，相信大家也看过了，简单的说，本来三个角度有自己的作用，可以控制飞机的偏航、俯仰、滚转。但是转到如下图所示的时候 本来红绿蓝三个圈应该是两两垂直的，蓝和绿至少有一个在图中的灰色圈里（准确的说应该是绿圈）用于控制俯仰操作，但是现在没有了，那么这个箭头不能做到俯仰操作了。转动绿圈的效果和转动蓝圈的效果变成一样了，绿圈就仿佛失去了他的作用。 矩阵和欧拉角的转换这里以物体坐标系转换到惯性坐标系为例，其他也一样 欧拉角-&gt;矩阵： 其实就是分别绕轴旋转再做矩阵乘法（下面这两张图是左手坐标系所以看起来跟之前的不太一样，自行转置） 矩阵乘法结果如下： 这里以物体坐标系转换到惯性坐标系为例，如果是惯性系转换成物体坐标系，则做矩阵的逆，这里是正交矩阵，所以做转置即可 矩阵-&gt;欧拉角： 其实就是通过矩阵得到h,b,p角度大小，可以从上面矩阵 由m32得：p = asin(-m32) 由m31和m33相除得：h = atan(m31 / m33) = atan2(m31, m33) 由m12和m22相除得：b = atan(m12 / m22) = atan2(m12, m22) 同理，如果是惯性-&gt;物体则转置 欧拉角和四元数的转换看四元数同章节 四元数四元数类比复数，是三维下的复数 可以表示为[w (x y z)]，xyz通常表示成向量，所以也可以简写成[w v] [w (x y z)] = w + xi + yj + zk，其中i² + j² + k² = -1 四元数的一些运算 负号：-q = -[w v] = [-w -v] 单位四元数：[1 (0 0 0)]图形学表示没有角位移也就是没有旋转 求模：||q|| = √(w² + x² + y² + z²)，单位四元数模场为1 共轭：q* = [w (-x -y -z)]图形学表示为沿负方向旋转 逆：q^-1 = q* / ||q|| 对数：q = [cos θ/2 (sin θ/2)n]则log q = [0 nθ/2] 差：d = a^-1*b，也就是d = b/a，需要注意的是所谓的差其实是除法，代表的是角位移了多少 点乘：q1q2 = w1w2 + x1x2 + y1y2 + z1z2 图形学中，将物体绕任意轴的向量n旋转，可以表示成四元数 q = [cos θ/2 (sin θ/2)nx (sin θ/2)ny (sin θ/2)nz] 把点p旋转q到点p‘ 幂：q^t = e^(t * log q)，几何意义：q = [cos θ/2 sin θ/2n]时表示绕n旋转θ°，则q^2表示旋转2θ° 矩阵和四元数的转换下面这个矩阵是左手系下的 需要注意的是，不能直接取第一列的公式计算wxyz，因为开根号会丢失正负信息，而是算出wxyz最大的后，再通过对应右边的公式计算剩余三个 给出其中的一个w的推导，其余类似： 欧拉角和四元数的转换 四元数 -&gt; 欧拉角 先判断p角是否为90°（或者判断sinp == 1），是的话会出现万向锁，直接p = sinp*pi/2（注意不要直接写成pi/2，要累计误差）不是的话才是下面的公式 下面h角和b角都是分了万向锁情况和普通情况 四元数插值用过flash就知道，如果对于一个物体在t0、t10时刻的位置不同，中间的“关键帧”是通过插值计算出来的，并不需要我们为每个时刻都绘制一幅图像，这就是插值 球面线性插值“slerp” 对于四元数表示的原角度q0，新角度q1，插值函数为 t的范围是[-1, 1]，其实很好理解，Δq就是做差嘛，前面说过四元数的差其实是做除法，t就是描述了一个类似于时间的东西，或者理解为中间的几分之一 旋转插值 另一种更便于计算机实现的方式是使用角度ω进行旋转插值 如下图两个单位向量的位置v0v1，我们不再认为v1 = v0 + tω，而是认为v0和v1都乘一个系数后平移再做向量加法 如此，我们便只需要求出k0和k1到底是多少即可： 将k0k1代入前面的公式v1 = k0v0 + k1v1即可，这是对于两个单位向量，类比一下换成两个四元数可得 btw：这个ω可以通过四元数的点乘求出来，因为四元数的点乘实际上跟向量的点乘差不了多少，只是多了个w，那么cosω = q0点乘q1 在实现的时候，需要注意的是前面向量的点乘我们说过cos可以用来判断两个向量的同向反向，这里表现为v0转到v1是顺时针大半圈呢还是逆时针小半圈呢？虽然这里四元数正负都是同一个方位，所以我们在钝角的情况下旋转到他的反向，也就是总是挑最小的那个方向进行，所以我们在实现时最好有如下判断 12345678910111213141516//如果为钝角，那么不旋转到他那里，而是旋转到他的反向if(cosOmega &lt; 0.0f){ q1w = -q1w; q1x = -q1x; q1y = -q1y; q1z = -q1z; cosOmega = -cosOmega;}//如果夹角很小，为了减小计算量，直接认为走直线if(cosOmega &gt; 0.9999f){ k0 = 1.0f - t; k1 = t;}else{ //旋转插值公式} 几种方法对比 任务/性质 矩阵 欧拉角 四元数 坐标系间旋转点 能 不能（转换成矩阵） 不能（转换成矩阵） 连接或增量旋转 能，但比四元数慢，小心矩阵蠕变情况 不能 能，比矩阵快 插值 基本上不能 能但可能遭遇万向锁 Slerp提供了平滑插值 易用程度 难 易 难 占用大小 9个数 3个数 4个数 是否能唯一表示给定方位 是 不是，同一方位有无数种表达 不是，有两种方法，他们相互为负 可能导致非法 矩阵蠕变 任意三个数都能构成合法的欧拉角 可能会出现误差积累从而非法 没有最好的方法，根据需求，并且几种方法之间可以相互转换","link":"/games/3DMath-Primerfor-Graphics-and-Game-Development-note/"},{"title":"456-132模式","text":"力扣456 https://leetcode-cn.com/problems/132-pattern/ 单调栈题目，用的很巧妙，不是普通的无脑单调栈，还涉及到单调栈的一个规律：循环出栈时，出栈的序列也满足反向单调栈的特点。比如下图递减栈在4入栈时： 根据这一现象，可以找到：比入栈值的大/小的最大最小值 本题思路：数组中想找132，机会最大的当然是1越小越好，2越接近3越好，2越大越好(也可以说成3越大越好，因为“2越接近3越好”) 我们从后往前遍历，先找比2大的3，因此构造单调递减栈，栈存的是每一个“3”，随着栈的慢慢迭代，栈顶3会越来越高，满足了“3越大越好”的题意。根据前面提到的性质，出栈的序列是递增栈，当遇到一个峰顶“3”时，最后一个出栈的就是比“3”小的最大的2，存起来，继续遍历的过程中，对比当前值（1）和存起来的（2），就知道是否满足132模式了 1234567891011121314//从右往左构造单调递减栈public boolean find132pattern(int[] nums) { Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();//单调递减栈，存值比存下标简单，代表了132中的3 int theTwo = Integer.MIN_VALUE; for(int i = nums.length - 1; i &gt;= 0; i--){ if(nums[i] &lt; theTwo) return true; while(!stack.isEmpty() &amp;&amp; nums[i] &gt; stack.peekLast()){ theTwo = stack.pollLast(); //最后一个出的肯定是比当前入栈小的最大值 } stack.offerLast(nums[i]); } return false;} 总之，很巧妙我觉得 其他单调栈系列题可以点这里","link":"/algorithms/132-pattern/"},{"title":"48-旋转图像","text":"力扣48 https://leetcode-cn.com/problems/rotate-image/ 所谓原地旋转，就是不能新建一个数组 思路1：计算某个点距离上下左右的坐标，一次循环翻转4个值 123456789101112131415161718192021222324252627|- - - - - - - - - - - - - - - - -|| ↑ || toTop || ↓ || ← toLeft → o ← - - toRight - - →|| ↑ | | | | | toBottom || | | | ↓ | |- - - - - - - - - - - - - - - - -|旋转过后|- - - - - - - - - - - - - - - - -|| ↑ || toLeft || ↓ || ← - - toBottom - - → o ← toTop →|| ↑ | | | | | toRight || | | | ↓ | |- - - - - - - - - - - - - - - - -|四个一周期点a旋转后占了b的位置，b占了c的位置，c占了d的位置，d一定会回到a的位置 用个变量记录下来，或者python的话可以直接a, b, c, d = b, c, d, a 1234567891011121314public void rotate(int[][] matrix) { int row = (matrix.length % 2 == 0) ? (matrix.length / 2) : (matrix.length / 2 + 1); for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; matrix[0].length / 2; j++) { int toTop = i, toRight = matrix[0].length - j - 1, toBottom= matrix.length - i - 1, toLeft = j; //四个旋转坐标交换 int temp = matrix[toTop][toLeft]; matrix[toTop][toLeft] = matrix[toRight][toTop]; matrix[toRight][toTop] = matrix[toBottom][toRight]; matrix[toBottom][toRight] = matrix[toLeft][toBottom]; matrix[toLeft][toBottom] = temp; } }} 思路2：转置+对称 顺时针：转置+左右对称 180°：上下对称+左右对称 逆时针：转置+上下对称 12345678910111213141516171819public void rotate2(int[][] matrix) { //矩阵转置 for(int i=0;i&lt;matrix.length;i++){ for(int j=0;j&lt;i;j++){ int tem=matrix[j][i]; matrix[j][i]=matrix[i][j]; matrix[i][j]=tem; } } //左右翻转 for(int i=0;i&lt;matrix.length;i++){ for(int j = 0; j &lt; matrix.length / 2; j++){ int tem = matrix[i][matrix.length - 1 - j]; matrix[i][matrix.length - 1 - j] = matrix[i][j]; matrix[i][j] = tem; } }} 其他题目点击这里","link":"/algorithms/rotate-image/"},{"title":"54-螺旋矩阵","text":"力扣54 https://leetcode-cn.com/problems/spiral-matrix/ 我记得是在acwing里面学的，dx,dy作为导向，每次只要x += dx[t]即可，不用上下左右考虑是加还是减，还是很方便的 1234567891011121314151617181920212223public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return res; int[] dx = {0, 1, 0, -1}; //方向指引 int[] dy = {1, 0, -1, 0}; int x = 0, y = -1, t = 0; //t代表第几次方向，x,y初值是因为一开始往右走 boolean[][] isPass = new boolean[matrix.length][matrix[0].length]; for(int i = 0; i &lt; matrix.length * matrix[0].length; i++){ if(!check(matrix, x + dx[t], y + dy[t], isPass)){ //转向 t = (t + 1) % 4; } x += dx[t]; y += dy[t]; res.add(matrix[x][y]); isPass[x][y] = true; } return res;}public boolean check(int[][] matrix, int x, int y, boolean[][] isPass){ return x &gt;= 0 &amp;&amp; x &lt; matrix.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; matrix[0].length &amp;&amp; !isPass[x][y];} 其他题目点击这里","link":"/algorithms/spiral-matrix/"},{"title":"496-下一个更大元素I","text":"力扣496 https://leetcode-cn.com/problems/next-greater-element-i/ 单调栈简单题，找下一个最大值，因此用递减栈遍历nums2，因为nums1要定位查，所以将结果放入map中 这题没什么好讲的了，所谓简单题，模板一套就vans了 12345678910111213141516public int[] nextGreaterElement(int[] nums1, int[] nums2) { Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //数字：下一个更大元素 for (int i = 0; i &lt; nums2.length; i++) { while (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peekLast()){ //找到了比他大的元素 map.put(stack.pollLast(), nums2[i]); } stack.offerLast(nums2[i]); } //仍在栈中而不在map中的元素就是-1 int[] res = new int[nums1.length]; for (int i = 0; i &lt; nums1.length; i++) { res[i] = map.getOrDefault(nums1[i], -1); } return res;} 其他单调栈系列题可以点这里","link":"/algorithms/next-greater-element-i/"},{"title":"5-最长回文子串","text":"力扣5 https://leetcode-cn.com/problems/longest-palindromic-substring/ 思路很有意思很高频的一道题，我的思路历程是这样的： 确定左右然后对区间判断？ 不对—&gt;应该是以i为中间往两边扩散 “aba”和”abba”好像不一样啊？ 只是l和r初始值不能是等于i，而是相同字母的左右边界，这样两种情况就一样了 想明白了这两点 1234567891011121314151617181920212223public String longestPalindrome(String s) { if (s == null || s.length() == 0) return \"\"; char[] chars = s.toCharArray(); int[] idx = new int[2]; //用来存最长的结果的左右下标，不要每次都substring，这样太慢 for (int i = 0; i &lt; chars.length; i++) { int l = i, r = i; //从中间向两边找 //l和r初始值应该是相同字母的左右边界 while (l - 1 &gt;= 0 &amp;&amp; chars[l - 1] == chars[i]) l--; while (r + 1 &lt; chars.length &amp;&amp; chars[r + 1] == chars[i]) r++; while (l - 1 &gt;= 0 &amp;&amp; r + 1 &lt; chars.length){ if (chars[l - 1] != chars[r + 1]){ break; } l--; //左右扩散 r++; } if ((r - l) &gt; (idx[1] - idx[0])){ idx[0] = l; idx[1] = r; } } return s.substring(idx[0], idx[1] + 1);} 优化[a]代表当前遍历到了哪里 对于b[b]bbb和 bb[b]bb我们可以发现其实定位l和r的初始值后是一样的，所以我们可以跳过这几种，具体有以下两点要做 定位完r后，直接让i = r，跳过中间的所有b（[b]bbbb—&gt;bbbb[b]） 这样操作后实际上没有i在中间的情况（b[b]bbb），因为我们实际上只找了最左边那次，所以可以不用再定位l，只需要定位r 1234567891011121314151617181920212223public String longestPalindrome(String s) { if (s == null || s.length() == 0) return \"\"; char[] chars = s.toCharArray(); int[] idx = new int[2]; for (int i = 0; i &lt; chars.length; i++) { int l = i, r = i; //while (l - 1 &gt;= 0 &amp;&amp; chars[l - 1] == chars[i]) l--; //优化2，实际上不需要找左边了 while (r + 1 &lt; chars.length &amp;&amp; chars[r + 1] == chars[i]) r++; i = r; //优化1，跳过中间部分，直接定位到同字母的最后一个 while (l - 1 &gt;= 0 &amp;&amp; r + 1 &lt; chars.length){ if (chars[l - 1] != chars[r + 1]){ break; } l--; r++; } if ((r - l) &gt; (idx[1] - idx[0])){ idx[0] = l; idx[1] = r; } } return s.substring(idx[0], idx[1] + 1);} 后记，准备将原来的一些题目重做一下，有一些题目真的是感觉得出一定是高频题，比如链表反转，最长回文，最长不重复，最大子数组…接下来会重做这些题目 参考 评论区糖丶7的方法 其他字符串类型的题目可以点击这里","link":"/algorithms/longest-palindromic-substring/"},{"title":"480-滑动窗口中位数","text":"力扣480 https://leetcode-cn.com/problems/sliding-window-median/ 首先考虑暴力法，每次截取其中的窗口并进行排序，然后取中位数，O(n^2 * logn) 123456789101112131415161718192021public double[] medianSlidingWindow(int[] nums, int k) { if (nums == null || nums.length == 0){ return new double[]{0.0}; } double[] res = new double[nums.length - k + 1]; for (int i = 0; i &lt; nums.length - k + 1; i++) { int[] arr = new int[k]; System.arraycopy(nums, i, arr, 0, k); //排序 Arrays.sort(arr); int mid = k / 2; if (k % 2 == 0){ res[i] = arr[mid - 1] / 2.0 + arr[mid] / 2.0; }else{ res[i] = arr[mid]; } } return res;} 滑动窗口方法，第一次窗口填值并排好序，后面的只需要删除旧的窗口元素和加入新的窗口元素，且加入新窗口元素时可以通过二分查找应该插入的位置，O(n^2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public double[] medianSlidingWindow2(int[] nums, int k) { if (nums == null || nums.length == 0){ return new double[0]; } double[] res = new double[nums.length - k + 1]; int mid = k / 2; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) { list.add(nums[i]); } Collections.sort(list); for (int i = 0; i &lt; nums.length - k + 1; i++) { //加入结果集 if (k % 2 == 0){ res[i] = list.get(mid - 1) / 2.0 + list.get(mid) / 2.0; }else{ res[i] = list.get(mid); } if (i + k == nums.length) break; //去掉一个 list.remove(Integer.valueOf(nums[i])); //插入新的 int idx = findIndex(list, nums[i + k]); list.add(idx, nums[i + k]); } return res;}/** * 二分查找 */public int findIndex(List&lt;Integer&gt; nums, int target){ int l = 0, r = nums.size() - 1, mid; while(l &lt;= r){ mid = l + (r - l) / 2; if(target &lt; nums.get(mid)) r = mid - 1; else if(target == nums.get(mid)) return mid; else if(target &gt; nums.get(mid)) l = mid + 1; } return l;} 最终优化：和2思想一样，只是该题其实窗口从头到尾都是有序的，细节优化为全局都使用二分，O(n * logn) 优化1：第一次窗口填值就可以通过二分查找插入对应位置，无需排序 优化2：不止是加入新元素的时候用二分，删除旧元素的时候也可通过二分查找位置，这样调用remove就不用遍历查找了 1234567891011121314151617181920212223242526272829303132333435363738public double[] medianSlidingWindow3(int[] nums, int k) { if (nums == null || nums.length == 0){ return new double[0]; } double[] res = new double[nums.length - k + 1]; int mid = k / 2; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) { //优化：插入的时候就可以再利用二分查找顺便排好序 int idx = findIndex(list, nums[i]); list.add(idx, nums[i]); } for (int i = 0; i &lt; nums.length - k + 1; i++) { //加入结果集 if (k % 2 == 0){ res[i] = list.get(mid - 1) / 2.0 + list.get(mid) / 2.0; }else{ res[i] = list.get(mid); } if (i + k == nums.length) break; //去掉一个 //优化：去掉的时候也可以利用二分查找删除，就可以remove下标而不是remove元素 int idx = findIndex(list, nums[i]); list.remove(idx); //插入新的 idx = findIndex(list, nums[i + k]); list.add(idx, nums[i + k]); } return res;}//findIndex方法和解法2完全一致 python实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445def medianSlidingWindow3(self, nums: List[int], k: int) -&gt; List[float]: if nums is None or len(nums) == 0: return [] mid = k // 2 res = [] li = nums[: k] li.sort() for i, num in enumerate(nums): # 加入结果集 if k % 2 == 0: res.append(li[mid - 1] / 2 + li[mid] / 2) else: res.append(li[mid]) if i + k == len(nums): break # 去掉一个 idx = self.find_index(li, nums[i]) del(li[idx]) # 插入新的 idx = self.find_index(li, nums[i + k]) li.insert(idx, nums[i + k]) return resdef find_index(self, nums, target) -&gt; int: \"\"\" 二分查找 \"\"\" l, r, mid = 0, len(nums) - 1, 0 while l &lt;= r: mid = l + (r - l) // 2 if target &lt; nums[mid]: r = mid - 1 elif target == nums[mid]: return mid else: l = mid + 1 return l 其他滑动窗口类型的题目可以点击这里","link":"/algorithms/sliding-window-median/"},{"title":"515-在每个树行中找最大值","text":"力扣515 https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/ 也就是找每行的最大值 思路一：bfs层次遍历每行嘛，找最大值并加入res 思路二：dfs深度优先，res中记录每行的最大值，通过level回溯参数定位现在是第几行，更新res.set(level - 1, max(res.get(level - 1), 当前节点值)); bfs写法 123456789101112131415161718public List&lt;Integer&gt; largestValues(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()){ int levelMax = Integer.MIN_VALUE; int size = queue.size(); for(int i = 0; i &lt; size; i++){ //分层层次遍历模板 TreeNode cur = queue.poll(); levelMax = Math.max(levelMax, cur.val); if(cur.left != null) queue.offer(cur.left); if(cur.right != null) queue.offer(cur.right); } res.add(levelMax); } return res;} dfs写法 12345678910111213141516private List&lt;Integer&gt; res = new ArrayList&lt;&gt;();public List&lt;Integer&gt; largestValues2(TreeNode root) { dfs(root, 1); return res;}public void dfs(TreeNode node, int level){ if (node == null) return ; if (level == res.size() + 1){ res.add(node.val); }else{ res.set(level - 1, Math.max(res.get(level - 1), node.val)); } dfs(node.left, level + 1); dfs(node.right, level + 1);} dfs确实比bfs快，由4ms提高到1ms，文德提出的这个dfs解法还是不错的 其他树的题目点击这里","link":"/algorithms/find-largest-value-in-each-tree-row/"},{"title":"53-最大子序和","text":"力扣53 https://leetcode-cn.com/problems/maximum-subarray/ 子序dp系列真的很顶 看[4,-1,2]部分，可以观察出这部分最大子序和是5，要得到5，所以dp[i] = dp[i - 1] + nums[i] 看[-2,1]，最大子序和应该直接取1，也就是加了不如不加，因为不如当前的，所以是dp[i] = max(dp[i-1] + nums[i], nums[i]) 想一想就知道需要不一样的两段之间比大小，所以不是一直累加dp，而是要max变量记录 12345678910public int maxSubArray(int[] nums) { int res = nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); res = Math.max(dp[i], res); } return res;} 其他动态规划的题目可以点击这里","link":"/algorithms/maximum-subarray/"},{"title":"56-合并区间","text":"力扣56 https://leetcode-cn.com/problems/merge-intervals/ 给出一个区间的集合，请合并所有重叠的区间。 示例1 123输入: intervals = [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: intervals = [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路1：按左端点升序排序，推荐这样做，因为这样比较省事。排序后遍历，后一个的开始&lt;=前一个的结束，说明有交集，合并（合并细节：因为一直往后遍历，因此只需要将后一个区间的左端点改为前一个区间的左端点，右端点改为较大的那个） 如：[1, 3], [2, 4] =&gt; [1, 3], [1, 4]，可以看到前一个其实是不需要管的，后一个的左端点变成了前一个的左端点，右端点是4&gt;3所以是4，这样实现了“合并” 123456789101112131415public int[][] merge(int[][] intervals) { List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(intervals, (o1, o2) -&gt; o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]); for (int i = 1; i &lt; intervals.length; i++) { if (intervals[i - 1][1] &gt;= intervals[i][0]){ intervals[i][0] = intervals[i - 1][0]; intervals[i][1] = Math.max(intervals[i - 1][1], intervals[i][1]); }else { res.add(intervals[i - 1]); } } res.add(intervals[intervals.length - 1]); return res.toArray(new int[0][]);} 思路2：数轴法，其实这个也好想，甚至比思路1先想到（因为说到区间合并会先想到数轴），因此我们可以模拟数轴，进行区间染色：区间头部为2，后面为1，如[1,3]为[0,2,1,1,…] 这里要注意两点： 数轴是无限大的，我们模拟数轴只模拟稍微大一点的数就行：int[] flag = new int[10005]; 要注意区分头部（2）和尾部（1），不能为同样的标识，否则两个不同的区间容易混淆 123456789101112131415161718192021222324252627282930313233343536373839public int[][] merge(int[][] intervals) { if (intervals.length == 0 || intervals[0].length == 0){ return intervals; } int[] flag = new int[10005]; //flag代表一条数轴 int max = intervals[0][1]; //结束条件为遍历到最大值 //数轴染色,区间头部为2，后面为1，如[1,3]为[0,2,1,1,...] for (int[] interval : intervals) { int j = interval[0]; if (flag[j] == 0) { flag[j] = 2; } while (++j &lt;= interval[1]) { flag[j] = 1; } max = Math.max(interval[1], max); } //遍历数轴 boolean border = true; int index = 0; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); int[] a = new int[2]; while (index &lt;= max + 1){ //右边界 if ((flag[index] == 0 || flag[index] == 2) &amp;&amp; !border){ a[1] = index - 1; res.add(Arrays.copyOf(a, a.length)); border = true; } //左边界 if (flag[index] == 2 &amp;&amp; border){ a[0] = index; border = false; } index++; } return res.toArray(new int[0][]);} 其他排序的题目点击这里","link":"/algorithms/merge-intervals/"},{"title":"61-旋转链表","text":"力扣61 https://leetcode-cn.com/problems/rotate-list/ 比较简单，别那么傻每次都交换，先往后找到该去的位置，截成两段，直接对调 123456789101112131415public ListNode rotateRight(ListNode head, int k) { if (head == null || head.next == null) return head; ListNode pre = head, post = head; while (k-- != 0){ pre = pre.next != null ? pre.next : head; } while (pre.next != null){ //前后一起移动找到分割点post pre = pre.next; post = post.next; } pre.next = head; head = post.next; post.next = null; return head;} 1707 ms 37.8 MB Java 优化一下，别那么傻，k可能很大，头尾循环1000多次…，直接循环一次，得出链表的大小，然后k % count即可得到该去的位置了 1234567891011121314151617181920public ListNode rotateRight(ListNode head, int k) { if (head == null || head.next == null) return head; ListNode pre = head, post = head; int count = 1; while (pre.next != null){ //遍历1次获得链表长度 pre = pre.next; count++; } k = k % count; //计算位置 pre = head; while (k-- != 0) pre = pre.next; //就不用头尾循环了 while (pre.next != null){ pre = pre.next; post = post.next; } pre.next = head; head = post.next; post.next = null; return head;} 其他链表类型的题目点击这里","link":"/algorithms/rotate-list/"},{"title":"63-不同路径II","text":"力扣63 https://leetcode-cn.com/problems/unique-paths-ii/submissions/ dp题，不同路径加入了障碍物，但影响不了多少，只多了判断条件： 如果当前为障碍，dp[i][j]为0 如果左边为障碍，dp[i][j] = 上面 如果上面为障碍，dp[i][j] = 左边 否则才是dp[i][j] = 左边 + 上面 因为障碍的判断刚好是0，因此仍然可以直接加，其实只有两个条件 12345678910111213141516171819202122232425262728public int uniquePathsWithObstacles(int[][] obstacleGrid) { int row = obstacleGrid.length; int col = obstacleGrid[0].length; if (col == 0) return 0; int[][] dp = new int[row][col]; //dp[i][j]代表到该点有多少种走法 //初始化 boolean check = true; //能走 for (int i = 0; i &lt; row; i++) { if(obstacleGrid[i][0] == 1) check = false; dp[i][0] = check ? 1 : 0; } check = true; for (int i = 0; i &lt; col; i++) { if(obstacleGrid[0][i] == 1) check = false; dp[0][i] = check ? 1 : 0; } //开始dp for (int i = 1; i &lt; row; i++) { for (int j = 1; j &lt; col; j++) { if (obstacleGrid[i][j] == 1){ dp[i][j] = 0; }else { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[row - 1][col - 1];} 解法倒是很简单，但是会有智障把障碍放在入口和出口？？？？？？？？？？？？？ 值得注意的是在dp问题中，很多人会采取dp[m + 1][n + 1]的写法来帮助更好的符合生活形式（1开头而不是0开头），另外就是可以简化初始化过程，dp[0]和dp[n][0]作为初始化，则dp[1]也可符合递推关系式，无需额外初始化。 另外就是部分人会采用降一维来减少空间复杂度，只记录dp[n] 这些技巧性很强的东西我在这里不多说了，评论区一抓一大把，偶尔可以学学优化一下，但是这里我只希望记录最通用、最本质、最模板的方法，以便能在一个“复杂度允许的范围内最快速度做出题目”。 其他动态规划的题目可以点击这里","link":"/algorithms/submissions/"},{"title":"60-第k个排列","text":"力扣60 https://leetcode-cn.com/problems/permutation-sequence/ 这题虽然是一道回溯题，但如果只是仅仅简单的回溯一下，会超时，经过剪枝和优化可以到13%。此题可以数学优化，还是有点挑战性的。再说了，我相信很多人和我一样看到题目第一个想到的肯定是先计算出开头数字，但是写起来还是回溯… 1. 暴力回溯+剪枝先来看看最low的回溯，这份提交是会超时的，而且还做了剪枝（到k个后面的就不继续了） 123456789101112131415161718192021222324252627282930313233class Solution { public String getPermutation(int n, int k) { int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) { nums[i] = i + 1; } backtrace(nums, new StringBuilder(), k); return res.get(res.size() - 1); } private List&lt;String&gt; res = new ArrayList&lt;&gt;(); private boolean max = false; public void backtrace(int[] nums, StringBuilder track, int k) { //结束条件 if (track.length() == nums.length) { res.add(track.toString()); if (res.size() == k) max = true; return; } for (int i = 0; i &lt; nums.length; i++) { //剪枝 if (max) return ; if (track.indexOf(String.valueOf(nums[i])) != -1) continue; //做选择 track.append(nums[i]); //递归 backtrace(nums, track, k); //撤销 track.deleteCharAt(track.length() - 1); } }} 2. 提前结束条件优化可以看到，剪枝也超时，分析一下，可以看出track.indexOf这句可能会影响性能，我们修改为标记数组，查找的时候O(1)，并且做了空间上的优化 12345678910111213141516171819202122232425262728293031323334class Solution { public String getPermutation(int n, int k) { int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) { nums[i] = i + 1; } backtrace2(nums, new boolean[n], new StringBuilder(), k); return res; } private String res = \"\"; //优化一下空间，结果只存一个 private int num = 0; public void backtrace2(int[] nums, boolean[] flag, StringBuilder track, int k){ //结束条件 if (track.length() == nums.length){ res = track.toString(); num++; return ; } for (int i = 0; i &lt; nums.length; i++) { //剪枝 if (k == num) return ; if (flag[i]) continue; //做选择 track.append(nums[i]); flag[i] = true; //递归 backtrace2(nums, flag, track, k); //撤销 track.deleteCharAt(track.length() - 1); flag[i] = false; } }} 3. 数学优化事实上写起来并不难，而且我相信大多数人第一眼看到题目想到的应该是这个，不过写的还是回溯（因为笔试需要时间，一般不敢冒险，选择了自己熟悉的方法…） 3.1 总体思路和过程以正常人的思维，手写可能的排列的时候一定是这样的顺序： 先固定第一位是1，后三位按顺序排列 234 243 324 342 423 432 也就是说1开头，那么剩下3位进行排列，共需A(3, 3) = 3! = 6 那么第一位想要为2必须先经历完1开头的，且2开头的也有6条数据 同样的，第一位想要是3，那么需经历开头1和2，那么也就是说，如果n位，那么第一位需要变成a1，那么前面有(n - 1)! * (a1 - 1) 反过来，已知k = 9，那么k / 6 = 1余3，说明第一位肯定已经超过了1的那6条，因此第一位是2 接下来确定第二位，那么变成了子问题：此时可供选择的选择列表把2去除了变为134，k为余数3，说人话就是：第一位的2已经确定了，在剩下的134中找到第3条数据。 当然，程序的话就不用再写了，这是子问题，之前已经写好了，重新遍历上面的即可 3.2 java实现步骤下面是java代码，我先贴完整代码（可以不看先，先看讲解），再一步步讲解： 12345678910111213141516171819202122232425262728293031public class six_zero_第k个排列_other { @Test public void test(){ String res = getPermutation(4, 9); System.out.println(res); } public String getPermutation(int n, int k) { //生成排列数列表 paiLie[0] = 0! paiLie[1] = 1! 由排列公式可得n! = n * (n - 1)! int[] paiLie = new int[n + 1]; List&lt;Integer&gt; nums = new LinkedList&lt;&gt;(); //选择列表，也就是1234，每次被选择一位后这里就会减少一位 paiLie[0] = 1; for (int i = 1; i &lt;= n; i++) { paiLie[i] = paiLie[i - 1] * i; //n! = n * (n - 1)! nums.add(i); } //准备完毕，开始从左到右找到每一位 String res = \"\"; k--; //这个可以回过头来看，因为下面k的计算是跟跳过的个数onceSkip相关的，onceSkip是下标，因此要先-1成下标 while (nums.size() != 0){ int onceSkip = paiLie[(nums.size() - 1)]; //也就是1开头的有6条，这就是这个6，当然第二位的时候就是(n - 1)!了 int index = k / onceSkip; res += nums.get(index); //后面重复，nums变为少了当前加的这个值，k也会减去跳过的个数 nums.remove(index); k -= index * onceSkip; //总共跳过的条数 } return res; }} 别急，一步步来做： paiLie[]：先要生成上面说的排列数列表，因为每次都是n! = (n - 1)! * n，需要前一个阶乘作为基础，所以一开始生成比较好，而不是临时算。 nums：同时还要生成上面说的选择列表，也就是一开始为1234，第一轮被选出2之后剩下134的这个东西 1234567891011public String getPermutation(int n, int k) { //生成排列数列表 paiLie[0] = 0! paiLie[1] = 1! 由排列公式可得n! = n * (n - 1)! int[] paiLie = new int[n + 1]; List&lt;Integer&gt; nums = new LinkedList&lt;&gt;(); //选择列表，第一轮为1234 paiLie[0] = 1; for (int i = 1; i &lt;= n; i++) { paiLie[i] = paiLie[i - 1] * i; nums.add(i); } return \"\";} 打个断点看看效果 完美（笑） 准备工作完成，下面看我们要完成的计算公式 总跳过数：之前说了第一位需要变成a1，那么前面有(n - 1)! * (a1 - 1)，(n - 1)!也就是开头为1的这一组会有多少条，起名onceSkip，对应的代码就是onceSkip = paiLie[(nums.size() - 1)]没错吧，至于a1 - 1，也就是跳过了多少组，起名index，也就是index = k / onceSkip 打个断点看看：res已经将第一位2加进来了 需要注意的是题目给的k是现实的k，但是我们k计算相关的是nums.get(index)，用的是下标，因此一开始做了一次k - 1，自己试下就知道了。 本轮结束第一位已加入res，开始确定第二位，子问题，进入前修改一下选择列表nums：去除已加入的2，修改k：k代表的是剩余几条数据，因此要减去已经跳过的index * onceSkip 看代码 就完成了，代码其实非常简单，就是计算别搞错了。 力扣2ms，官方的代码1ms，但是思路一样的 其他回溯系列题目可以点击这里","link":"/algorithms/permutation-sequence/"},{"title":"654-最大二叉树","text":"力扣654 https://leetcode-cn.com/problems/maximum-binary-tree/ 当前节点任务：数组中找到最大的并构造节点，递归左右两边子数组构造出左右节点 由于默认函数没有必要的参数，所以得自己写一个，必要的参数如上面所说：左右子数组，所以需要start和end参数 12345678910111213141516171819202122public TreeNode constructMaximumBinaryTree(int[] nums) { return buildTree(nums, 0, nums.length - 1);}public TreeNode buildTree(int[] nums, int start, int end) { if (start &gt; end) return null; int rootIdx = findMax(nums, start, end); TreeNode root = new TreeNode(nums[rootIdx]); root.left = buildTree(nums, start, rootIdx - 1); root.right = buildTree(nums, rootIdx + 1, end); return root;}public int findMax(int[] nums, int start, int end){ int maxIdx = start; for (int i = start; i &lt;= end; i++) { if (nums[i] &gt; nums[maxIdx]){ maxIdx = i; } } return maxIdx;} 其他树的题目点击这里","link":"/algorithms/654-maximum-binary-tree/"},{"title":"70-爬楼梯以及进化版","text":"力扣70 https://leetcode-cn.com/problems/climbing-stairs/ 动态规划经典题，没有之一 还是那三句话 定义动态规划数组的含义 找出关系式 找初始值 因为此题实在简单，直接给出java代码 12345678910111213public int climbStairs(int n) { if (n &lt;= 1) return 1; int[] dp = new int[n + 1]; //1.dp[i]表示到第i阶的方法数 //3.初始值，不可能出现dp[-1]，dp[0],dp[1]要注意，dp[1],dp[2] dp[0] = 0; dp[1] = 1; dp[2] = 2; //2.”先到达再说“，现在在第5阶楼梯，可以从3阶跳上来，可以从第4阶跳上来。 for (int i = 3; i &lt;= n; i++) { dp[i] = dp[i - 2] + dp[i - 1]; } return dp[n];} 本来此题如此简单，不值得记录，但是！！重点来了，字节跳动2020秋招9月笔试题 多了一个条件：不能连续跳两步 好家伙，早就听说字节喜欢考原题，妙啊真是妙蛙种子吃着妙脆角进了米奇妙妙屋—妙到家了 发现自己真的是知其然不知其所以然，看知乎的数学推导： https://www.zhihu.com/question/275079633 代码就不贴了，没什么了，把上面的dp递推关系式改一下dp[i] = dp[i - 3] + dp[i - 1];，初始条件手算一下，就可以了，关键是思维和数学推导 其他动态规划的题目可以点击这里","link":"/algorithms/climbing-stairs/"},{"title":"739-每日温度","text":"力扣735 https://leetcode-cn.com/problems/daily-temperatures/submissions/ 自从上次做了最大矩形单调栈题目之后，最近笔试见了两题单调栈的题目了，心理作用？？赶紧补吧… 题目描述的不是很清楚（可以看英文版比较明白），总之，是说往后找到比当前大的（温度高的），然后记录下标距离。 很显然是单调栈的题目：”往后找到第一个”这样的字样 思路也比较简单： 往后找第一个比当前大的，因此采用递减栈。 栈中记录下标（因为要求的是下标差而且通过下标可以直接在T[i]中得出值作比较反之则困难，好多单调栈的题目都是这样记录的） 遇到比栈顶大则记录当前与栈顶元素的距离，出栈，循环直至满足递减栈 当前元素入栈。 java代码 1234567891011121314151617181920212223242526272829public class seven_three_nine_每日温度 { @Test public void test(){ int[] T = {73, 74, 75, 71, 69, 72, 76, 73}; int[] res = dailyTemperatures(T); System.out.println(Arrays.toString(res)); } public int[] dailyTemperatures(int[] T) { int[] res = new int[T.length]; if (T == null || T.length == 0) return res; Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); //栈中存下标而不是值，值通过T[下标]得出 deque.offerLast(0); for (int i = 1; i &lt; T.length; i++) { if (T[i] &lt;= T[deque.peekLast()]){ //满足递减栈，当前下标直接入栈 deque.offerLast(i); }else { //不满足，出栈，记录距离，循环直至满足单调栈 while (deque.size() != 0 &amp;&amp; T[i] &gt; T[deque.peekLast()]){ Integer beginIndex = deque.pollLast(); //小的出来 res[beginIndex] = i - beginIndex; } deque.offerLast(i); //当前的入栈 } } return res; }} ps：栈用Stack也是可以的，具体我在博客中有记录，双端队列的速度理论上会比Vector的子类Stack快 其他单调栈系列题可以点这里","link":"/algorithms/daily-temperatures/"},{"title":"84-柱状图中的最大矩形","text":"前言：实习的公司真是个学习的好地方，展南安排任务慢慢开始对接测试人员，学宇教我上班划划水！有问题就去烦萌萌！嘿嘿，今天看到萌萌在刷力扣，给我发来了这道题 力扣原题https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ 题目我就不贴了，关键是第一次接触到单调栈。 1. 暴力法思路很简单，遍历，向左向右找到比当前heights[i]低的柱，下标为left和right，然后底(right - left - 1) * 高(heights[i]) 123456789101112public int largestRectangleArea(int[] heights) { if (heights == null || heights.length == 0) return 0; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; heights.length; i++) { //往左找，往右找 int left = i, right = i; while (left &gt;= 0 &amp;&amp; heights[left] &gt;= heights[i]) left--; while (right &lt; heights.length &amp;&amp; heights[right] &gt;= heights[i]) right++; max = Math.max(max, heights[i] * (right - left - 1)); } return max;} 用时1034ms！只有java能过，python使用这种方法超时。 2. 单调栈第一次接触这个概念，但是其实并不是第一次接触单调栈的题目。这个不是一个数据结构，只是一种思维，让栈的元素单调递增或者递减，使用的场景有：遍历到i时，需要往后/前看，看到满足某个条件时需要跟i作比较。 通过一些具体题目来看什么时候使用： 本题：在柱状图中，能够勾勒出来的矩形的最大面积。遍历到i时，往后找heights[right]比heights[i]小的元素，说明i处最大的矩形高为heights[i]，宽为right - i - 1 能看的到的楼：趋势科技秋招笔试题，大概是有一排高低不同的楼，人依次站在每栋楼的楼顶往后看，能看到多少栋楼的楼顶（趋势科技改了题目，可以往前看也可以往后看，当时不知道单调栈的概念） 大佬讲解https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/ 我直接贴完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 单调栈，思路： * 栈中存的是下标，代表了矩形宽度的起点start,i代表end位置，heights[i]代表了当前柱状图的高度，heights[stack.peek]就代表栈顶高度 * 低高（12）类型，入栈：因此栈顶的值就是：以栈顶柱状图高度（heights[stack.peek]）为矩形的起点start * 高低（21）类型，出栈：遇到比栈顶对应的高度小的（heights[i] &lt; heights[stack.peek]），说明以heights[stack.peek]为高的矩形被确定，宽度为i - stack.peek() - 1 * 循环上述出栈过程直到满足12类型，每次出栈对比累计最大值和当前矩形最大值 * 哨兵的添加：最后栈中剩下的满足12类型，为了方便继续比较，则增加末尾哨兵为0变成120，于是遍历到0的时候20满足了21类型，2出栈，10也满足21类型，结束。 */public class eight_four_柱状图中的最大矩形_other { @Test public void test(){ int[] heights = {2, 1, 5, 6, 2, 3}; int res = largestRectangleArea(heights); System.out.println(res); } public int largestRectangleArea(int[] heights) { int len = heights.length; if (len == 0) return 0; if (len == 1) return heights[0]; int res = 0; int[] newHeights = new int[len + 2]; newHeights[0] = 0; System.arraycopy(heights, 0, newHeights, 1, len); newHeights[len + 1] = 0; len += 2; heights = newHeights; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(len); // 先放入哨兵，在循环里就不用做非空判断 stack.addLast(0); for (int i = 1; i &lt; len; i++) { while (heights[i] &lt; heights[stack.peekLast()]) { int curHeight = heights[stack.pollLast()]; int curWidth = i - stack.peekLast() - 1; res = Math.max(res, curHeight * curWidth); } stack.addLast(i); } return res; }} 10ms，估计时间的消耗在System.arraycopy，还有别的写法，占坑。 3. 其他单调栈系列题目其他单调栈系列题可以点这里","link":"/algorithms/largest-rectangle-in-histogram/"},{"title":"784-字母大小写全排列","text":"力扣784 https://leetcode-cn.com/problems/letter-case-permutation/ 本题和1219 黄金矿工类似，属于枚举型回溯 枚举：当数字时进行一次选择、递归、撤销，当字母时进行两次（一次大写一次小写）选择、递归、撤销 这题有说仅由数字和字母组成，所以直接判断数字比较简单，else为字母 总体比较简单，直接贴核心代码 12345678910111213141516171819202122232425262728public List&lt;String&gt; letterCasePermutation(String S) { backtrace(S, 0, new StringBuilder()); return res;}private List&lt;String&gt; res = new ArrayList&lt;&gt;();public void backtrace(String s, int index, StringBuilder path){ //结束条件：path.length == s.length if (path.length() == s.length()){ res.add(path.toString()); return ; } //开始枚举回溯 if (Character.isDigit(s.charAt(index))){ //数字 path.append(s.charAt(index)); //选择 backtrace(s, index + 1, path); //递归 path.deleteCharAt(path.length() - 1); //撤销 }else { //字母 //大写 path.append(String.valueOf(s.charAt(index)).toUpperCase()); //选择 backtrace(s, index + 1, path); //递归 path.deleteCharAt(path.length() - 1); //撤销 //小写 path.append(String.valueOf(s.charAt(index)).toLowerCase()); //选择 backtrace(s, index + 1, path); //递归 path.deleteCharAt(path.length() - 1); //撤销 }} 其他回溯系列题目可以点击这里","link":"/algorithms/letter-case-permutation/"},{"title":"901-股票价格跨度","text":"力扣901 https://leetcode-cn.com/problems/online-stock-span/ 单调栈题目，我也不清楚力扣的输入样例是什么，但是直接return 1的话可以测试一下看到已经返回了null, 1, 1…因此可以判断只需要完成这个类的next方法即可 123456789101112131415161718class StockSpanner { private Deque&lt;int[]&gt; stack = new LinkedList&lt;&gt;(); //递减栈 public StockSpanner() { } public int next(int price) { int num = 1; int[] node = new int[2]; while (!stack.isEmpty() &amp;&amp; price &gt;= stack.peekLast()[0]){ int lastNum = stack.pollLast()[1]; num += lastNum; } node[0] = price; node[1] = num; stack.offerLast(node); return num; }} 其他单调栈系列题可以点这里","link":"/algorithms/online-stock-span/"},{"title":"JS从url中获取请求参数工具类","text":"这是一个从URL中获取参数值的工具例如URL为http://localhost/index.html?id=5&amp;name=张三 那么在html中引入该头文件 &lt;script src=&quot;js/getParameter.js&quot;&gt;&lt;/script&gt; 后就可以通过js代码传入参数获得参数值了 1var id = getParameter(\"id\"); 下面给出工具类getParameter.js的代码 123456//根据传递过来的参数name获取对应的值function getParameter(name) { var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\",\"i\"); var r = location.search.substr(1).match(reg); if (r!=null) return (r[2]); return null;}","link":"/frontend/JS%E4%BB%8Eurl%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"Java二叉树的层次遍历","text":"1. 层次遍历和BFS之前写过二叉树的前中后序遍历，不懂的点这里，今天介绍的是层次遍历，层次遍历概念很简单，我直接盗用力扣上面的图了，采用BFS也是显而易见的 2. BFS模板还是我们最喜欢的套路模板环节，废话不多说，直接代码 123456789void bfs(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); // Java 的 pop 写作 poll() if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); }} BFS和关键是队列，通过先进先出的机制完成广度优先 https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xej9yc/ 通过这个幻灯片就可以很好的解释了队列在二叉树层次遍历中的使用：每当一个根节点出队，就把左右子节点入队，不断循环 3. 题目：力扣102 https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 由于题目不仅要求层次遍历，还要按输出规则返回List&lt;List&lt;Integer&gt;&gt; 12345[ [3], [9,20], [15,7]] 因此我们需要记录每层有多少个，然后遍历这么多个并加入每层list，遍历完后才将这个list加入最终结果res，直接给ide可以测试的代码 1234567891011121314151617181920212223242526272829303132public class one_zero_two_二叉树的层次遍历 { @Test public void test(){ TreeNode root = new TreeNode(3); root.left = new TreeNode(9); root.right = new TreeNode(20); root.right.left = new TreeNode(15); root.right.right = new TreeNode(7); List&lt;List&lt;Integer&gt;&gt; lists = levelOrder(root); System.out.println(lists.toString()); } private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()){ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int size = queue.size(); //这里和下面的for循环就是记录每层的list，其他都是上面的模板 for(int i = 0; i &lt; size; i++){ root = queue.poll(); list.add(root.val); if(root.left != null) queue.offer(root.left); if(root.right != null) queue.offer(root.right); } res.add(list); } return res; }} 其他树的题目点击这里","link":"/algorithms/hierarchical-traversal-binary-tree-with-java/"},{"title":"GC","text":"1. 如何定位垃圾垃圾就是没有引用的对象，那么如何确定是否还存在引用呢 引用计数(ReferenceCount)：存在循环引用问题 根可达算法(RootSearching)：从跟开始寻找(线程栈变量，静态变量，常量池，JNI指针)，找不到的就算垃圾 2. 垃圾回收算法 标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描） 拷贝算法 (copying) - 没有碎片，浪费空间 标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整） 3. JVM中的垃圾回收器10种如下，JVM回收内存通常是组合使用，不同的垃圾回收器采用不同的策略 左边6个分代模型中，下面的是老年代，上面的是年轻代，一般是如图所示搭配（但也可以混杂搭配，看其他虚线） 1.8默认是PS+PO（新生代Parallel Scavenge，老年代Parallel Old），但是可以用分区模型G1（推荐，有些公司运维有JVM调优经验的话说不定会用这个） 下面介绍一下各个组合 3.1 分代模型-Serial系列如图解释的很清楚，当垃圾回收线程来了，工作线程STW，垃圾回收线程完了，工作线程才能继续 STW：Stop The World，如字面意思，马上！！停止！！！ 为什么有时候机器会突然卡顿一下，就是因为STW了 3.2 分代模型-Parallel系列随着内存越来越大，Serial有点慢，于是出现了Parallel 和Serial差不多也是STW，不过Parallel嘛，垃圾回收线程是多个且并行的 3.3 分代模型-CMS系列还是随着内存的越来越大，Parallel很慢，原因：线程数和效率不是线性提升的，因为线程需要上下文切换ContextSwitch，到达一定数量后，线程多反而耗费了大量时间在此 CMS：concurrent mark sweep Parnew和Parallel Scavenge基本一样，只是为了配合CMS而产生的 CMS过程如下： 初始标记也是STW，但是只GCRoot扫描根（前面说的根可达算法可还记得？），很少所以时间可以接受 重新标记也是STW，这里有个bug，后面讲 CMS三色标记法和错标问题并发标记存在问题，就是错标 情况1：在标记的时候突然有个对象引用没了（成为了垃圾，称为浮动垃圾），这种就是漏标了，这种问题不大，大不了下次gc再清理就是了 情况2：一个对象本来是垃圾，突然又有引用了（存在这种情况嘛？有的，缓存），这种错标就比较严重了 所以存在重新标记的过程 三色标记法 黑色：对象标记，成员field也被标记 灰色：对象标记，成员还未标记 白色：没有遍历到的字段 标记是怎么标记的呢？CMS标记采用三色标记法，重新标记阶段扫描就是扫描灰色的对象。说回情况2，如果第一次标记后黑色的对象有个指针域指向了某个白色对象，再次标记的时候不会再扫描黑色对象，此时就产生了错标 解决办法 CMS解决办法：incremental update：简单的说就是A引用变了的时候重新将A置为灰色，这样就可以重新扫描到了 这种办法存在一个bug，就是说对象A有两个field，多线程的时候垃圾回收线程标记了field1不是垃圾，然后扫描field2，工作线程使得field1重新指向了一个垃圾对象D，这样本来A应该被标记为灰色，但是垃圾回收线程不知道filed1改变了，标记完field2后将A置为黑色 因此才需要remark过程，但是这个过程导致CMS这个原本号称“解决STW”的算法产生了历史上最长的STW，也就是因为这样，CMS并没有作为任何一个JDK版本的默认垃圾回收器 G1解决办法：SATB 3.4 JVM的堆内存模型JVM堆的具体内存分区如下，图中的数字是大小比例 可以看到新生代用的拷贝算法，但不是一般的拷贝，是eden:survivor1:survivor2=8:1:1，第一次gc从eden到s1，然后在s1和s2之间来回跳，到达一定的次数后进入老年代（这个次数默认15，CMS默认6，可以通过-XX:MaxTenuringThreshold配置） 4. JVM调优实战经验 服务器升级加大了内存，反而更加卡顿。原因是内存越大，FGC时间越长。解决办法：PS -&gt; PN + CMS 或者 G1 线上CPU突然100%。那么一定有线程在占用系统资源， 找出哪个进程cpu高（top） 该进程中的哪个线程cpu高（top -Hp） 导出该线程的堆栈 (jstack) 查找哪个方法（栈帧）消耗时间 (jstack) 工作线程占比高 | 垃圾回收线程占比高 系统内存飙高，如何查找问题？（面试高频） 导出堆内存 (jmap) 分析 (jhat jvisualvm mat jprofiler … ) 如何监控JVM jstat jvisualvm jprofiler arthas top… 附录1. 对象分配过程 一些基本类型的变量是有机会分配在栈上的比如局部变量，怎么判定是否能分配在栈上？如果逃逸分析没有逃逸，标量替换可以替换，则分配在栈上 逃逸分析：看附录2 标量替换：即一个对象可以用两个基本类型的变量来替换它，就称为可以标量替换，比如一个对象只有两个int的类型，那么我们完全可以用两个int变量代替这个类（结构体） 如果对象太大，直接老年代，否则会先TLAB（ThreadLocalAllocationBuffer线程本地分配缓冲区），这个细节一般不会有人问起，但是确实存在的，Eden区有一部分TLAB，线程争用后才进入Eden区的公共空间 2. 逃逸分析逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化： 栈上分配 Java虚拟机中，如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。 同步消除 线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除。 标量替换 标量是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机的原始数据类型都不能再进一步分解，它们就可以称为标量。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配到物理机器高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。 3. JVM常用命令3.1 监控相关基础命令 jps：查询运行中的java进程编号和名称，相当于ps命令，但只有java相关的 jinfo pid：作用不大，可以查看某个进程的jdk信息，比如jdk版本啊classpath啊encoding啊当前的vm参数啊等等 jstack pid：java堆栈信息，类似于idea里面的debug控制台左边，显示了某个进程的所有线程运行了哪个方法，可以用来查死锁 jmap -histo pid：查看某个java进程内存分配状况 jstat：可以观察到classloader，compiler，gc相关信息，实时监控资源和性能 工具（arthas）上面介绍的基本命令基本上不用，因为通常都用工具，就很像git，一般都用sourcetree或者idea而不是纯命令行，因为工具更加强大，所以我们来看看 gui工具：jconsole, jvisualvm这些可视化工具都很不错，而且是jdk自带的，但是只能在本地开发压测和debug用，线上服务器通常没有gui，所以用的更多的是arthas（阿里开源的工具，下载并启动jar包，java -jar arthas-boot.jar，在黑框上模拟图形化界面） 下面介绍arthas一些命令 help：帮助文档 dashboard：仪表盘模拟图形界面，很强，可以监控CPU和内存，相当于top，看图 jvm：相当于jinfo，显示了jvm相关信息，垃圾回收器等 thread [线程id]：相当于jstack，只列出了线程列表，要看某个线程的详情可以thread 线程id，要找死锁，直接thread -b可以看到某个死锁阻塞状况 heapdump：将内存占用信息导出到具体的文件夹，用于查oom，如果疯狂fgc，或者已经出现了oom，那么可以heapdump导出到具体的文件夹，然后用前面说的gui工具打开进行本地分析，相当于jmap命令 注意：arthas的headdump和jmap在生产环境中都不太能用，因为内存有可能很大，完整dump备份一次要很久，生产环境通常使用XX:+HeapDumpOnOutOfMemoryError，代表在oom之前自动导出 3.2 GC常用参数 -Xmn -Xms -Xmx -Xss年轻代 最小堆 最大堆 栈空间 -XX:+UseTLAB使用TLAB，默认打开 -XX:+PrintTLAB打印TLAB的使用情况 -XX:TLABSize设置TLAB大小 -XX:+DisableExplictGCSystem.gc()不管用 ，FGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationConcurrentTime (低)打印应用程序时间 -XX:+PrintGCApplicationStoppedTime （低）打印暂停时长 -XX:+PrintReferenceGC （重要性低）记录回收了多少种不同引用类型的引用 -verbose:class类加载详细过程 -XX:+PrintVMOptions -XX:+PrintFlagsFinal -XX:+PrintFlagsInitial必须会用 -Xloggc:opt/log/gc.log -XX:MaxTenuringThreshold升代年龄，最大值15 锁自旋次数 -XX:PreBlockSpin 热点代码检测参数-XX:CompileThreshold 逃逸分析 标量替换 …这些不建议设置 Parallel常用参数 -XX:SurvivorRatio -XX:PreTenureSizeThreshold大对象到底多大 -XX:MaxTenuringThreshold -XX:+ParallelGCThreads并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同 -XX:+UseAdaptiveSizePolicy自动选择各区大小比例 CMS常用参数 -XX:+UseConcMarkSweepGC -XX:ParallelCMSThreadsCMS线程数量 -XX:CMSInitiatingOccupancyFraction使用多少比例的老年代后开始CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收） -XX:+UseCMSCompactAtFullCollection在FGC时进行压缩 -XX:CMSFullGCsBeforeCompaction多少次FGC之后进行压缩 -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingPermOccupancyFraction达到什么比例时进行Perm回收 GCTimeRatio设置GC时间占用程序运行时间的百分比 -XX:MaxGCPauseMillis停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代 G1常用参数 -XX:+UseG1GC -XX:MaxGCPauseMillis建议值，G1会尝试调整Young区的块数来达到这个值 -XX:GCPauseIntervalMillis？GC的间隔时间 -XX:+G1HeapRegionSize分区大小，建议逐渐增大该值，1 2 4 8 16 32。随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长ZGC做了改进（动态区块大小） G1NewSizePercent新生代最小比例，默认为5% G1MaxNewSizePercent新生代最大比例，默认为60% GCTimeRatioGC时间建议比例，G1会根据这个值调整堆空间 ConcGCThreads线程数量 InitiatingHeapOccupancyPercent启动G1的堆空间占用比例","link":"/Java%E5%9F%BA%E7%A1%80/GC/"},{"title":"Java实现树的遍历及二叉树可视化","text":"1. 树的遍历说明 前序遍历（根左右） 中序遍历（左根右） 后序遍历（左右根） 层次遍历（一层层） 层次遍历使用的是BFS，而前中后是DFS，所以单独开一篇 不难发现，其实名字中的“前中后”指的是“根”的位置 2. java实现（递归和栈）递归方式我就不多说了，栈方式的话按照如下顺序： 根节点入栈 进入左节点，节点不为空则入栈，重复直到节点为空则出栈（此时出的这个是最后一个不为空的节点） 进入右节点，节点不为空则入栈，重复直到栈为空结束 通用模板 123456789101112131415private List&lt;Integer&gt; res = new ArrayList&lt;&gt;();public List&lt;Integer&gt; traversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (!stack.empty() || root != null){ if(root!=null){ stack.push(root); root = root.left; }else { root = stack.pop(); root = root.right; } } return res;} 不要乱写代码，直接背下这套模板，前中后序遍历只差一句res.add(root.val);只是位置不同而已 2.1 前序遍历力扣原题https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 递归方式 123456789101112class Solution { private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { if(root != null){ res.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); } return res; }} 栈方式 123456789101112131415161718class Solution { private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.empty() || root != null){ if (root != null){ res.add(root.val); //前序加在这里 stack.push(root); root = root.left; }else { root = stack.pop(); root = root.right; } } return res; }} 2.2 中序遍历力扣原题https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ 递归方式 1234567891011class Solution { private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { if(root != null){ inorderTraversal(root.left); res.add(root.val); inorderTraversal(root.right); } return res; }} 栈方式 123456789101112131415161718class Solution { private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.empty() || root != null){ if(root != null){ stack.push(root); root = root.left; }else { root = stack.pop(); res.add(root.val); //中序加在这里 root = root.right; } } return res; }} 2.3 后序遍历递归方式 1234567891011class Solution { private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { if(root != null){ postorderTraversal(root.left); postorderTraversal(root.right); res.add(root.val); } return res; }} 栈方式 后序遍历使用栈方式有点不同，栈方式都是：根节点入栈，左节点入栈出栈，右节点入栈出栈。res.add(root.val);前序只需要加在根节点入栈前，中序只需要加在右节点出栈前。而对于后序遍历，按理来说应该加载右节点出栈后，但是左节点出栈和右节点出栈都是同一段代码段，我们无法判断root = stack.pop();是左节点出栈还是右节点出栈，因此我们要在右节点入栈时记录下来，如果出栈时==记录，那么说明是右节点出栈。 12345678910111213141516171819202122232425class Solution { private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode stored = null; //用来记录右节点 while(!stack.empty() || root != null){ if (root != null){ stack.push(root); root = root.left; }else{ root = stack.peek(); //这里不同，不要直接pop if (root.right == null || root.right == stored){ //这就说明是右节点已经遍历过了，准备出栈了 res.add(root.val); //后序加在这里 stack.pop(); stored = root; //记录下来 root = null; }else { root = root.right; } } } return res; }} 当然，如果你只记得模板，没关系，我们可以将前序遍历改造成根右左（root = root.left和root.right换一下位置），然后reverse这个列表 123456789101112131415161718192021class Solution { private List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.empty() || root != null){ if (root != null){ res.add(root.val); //前序加在这里 stack.push(root); root = root.right; //先右 }else { root = stack.pop(); root = root.left; //再左 } } // 精髓！ -- 换一种思路来解题 -- 通过一个方向相反的近似解，最后在答案基础上做反转 // 反转结果，得到 ： 左 -&gt; 右 -&gt; 根 Collections.reverse(res); return res; }} 这篇文章对栈的说明写的非常不错https://www.cnblogs.com/bigsai/p/11393609.html 2.4 层次遍历层次遍历和前中后序思想和写法都完全不同 前中后序：DFS/栈 层次遍历：BFS和队列 专门开了一篇来写层次遍历 –&gt; 传送门 附录 其他写法1. 颜色标记法（大佬说可以前中后序遍历都相同的代码）12345678910class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: stack,rst = [root],[] while stack: i = stack.pop() if isinstance(i,TreeNode): stack.extend([i.right,i.val,i.left]) elif isinstance(i,int): rst.append(i) return rst java实现详见 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/ 2. 另一套模板网上有些很简洁的版本，这个风格我是比较喜欢的，前序如下，自己摸索 1234567891011121314151617class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; //力扣专属测试用例 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if(node == null) continue; // 这样的输出顺序是：根 -&gt; 左 -&gt; 右 list.add(node.val); stack.push(node.right); stack.push(node.left); } return list; }} 3. 二叉树的可视化根据网上的代码修改而成，完美切合力扣格式，有时候在力扣做算法题时，在测试的时候通常要先构造一棵树，但是又没办法查看就很无奈，创建两个类 代码已经上传到github，附带一个力扣题目作为demo，https://github.com/wjwABCDEFG/TreeUtil 以下是代码关键部分解释说明 为了匹配任何类型，这里用了泛型 1234567891011/** * 树节点 */public class Node&lt;T extends Comparable&lt;?&gt;&gt; { public Node&lt;T&gt; left, right; public T data; public Node(T data) { this.data = data; }} TreeVisualUtil代码，直接复制即可食用，要改的地方我用注释标好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import org.junit.Test;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class TreeVisualUtil { public static &lt;T extends Comparable&lt;?&gt;&gt; void printNode(Node&lt;T&gt; root) { int maxLevel = TreeVisualUtil.maxLevel(root); printNodeInternal(Collections.singletonList(root), 1, maxLevel); } private static &lt;T extends Comparable&lt;?&gt;&gt; void printNodeInternal(List&lt;Node&lt;T&gt;&gt; nodes, int level, int maxLevel) { if (nodes.isEmpty() || TreeVisualUtil.isAllElementsNull(nodes)) { return; } int floor = maxLevel - level; int endgeLines = (int) Math.pow(2, (Math.max(floor - 1, 0))); int firstSpaces = (int) Math.pow(2, (floor)) - 1; int betweenSpaces = (int) Math.pow(2, (floor + 1)) - 1; TreeVisualUtil.printWhitespaces(firstSpaces); List&lt;Node&lt;T&gt;&gt; newNodes = new ArrayList&lt;Node&lt;T&gt;&gt;(); for (Node&lt;T&gt; node : nodes) { if (node != null) { System.out.print(node.data); newNodes.add(node.left); newNodes.add(node.right); } else { newNodes.add(null); newNodes.add(null); System.out.print(\" \"); } TreeVisualUtil.printWhitespaces(betweenSpaces); } System.out.println(\"\"); for (int i = 1; i &lt;= endgeLines; i++) { for (Node&lt;T&gt; node : nodes) { TreeVisualUtil.printWhitespaces(firstSpaces - i); if (node == null) { TreeVisualUtil.printWhitespaces(endgeLines + endgeLines + i + 1); continue; } if (node.left != null) { System.out.print(\"/\"); } else { TreeVisualUtil.printWhitespaces(1); } TreeVisualUtil.printWhitespaces(i + i - 1); if (node.right != null) { System.out.print(\"\\\\\"); } else { TreeVisualUtil.printWhitespaces(1); } TreeVisualUtil.printWhitespaces(endgeLines + endgeLines - i); } System.out.println(\"\"); } printNodeInternal(newNodes, level + 1, maxLevel); } private static void printWhitespaces(int count) { for (int i = 0; i &lt; count; i++) { System.out.print(\" \"); } } private static &lt;T extends Comparable&lt;?&gt;&gt; int maxLevel(Node&lt;T&gt; node) { if (node == null) { return 0; } return Math.max(TreeVisualUtil.maxLevel(node.left), TreeVisualUtil.maxLevel(node.right)) + 1; } private static &lt;T&gt; boolean isAllElementsNull(List&lt;T&gt; list) { for (Object object : list) { if (object != null) { return false; } } return true; } /** * 只需要修改这里按部就班构造自己的树，运行main方法即可 */ private static Node&lt;String&gt; myTree() { Node&lt;String&gt; root = new Node&lt;&gt;(\"A\"); root.left = new Node&lt;&gt;(\"B\"); root.right = new Node&lt;&gt;(\"C\"); root.left.left = new Node&lt;&gt;(\"D\"); root.left.right = new Node&lt;&gt;(\"E\"); root.left.right.left = new Node&lt;&gt;(\"F\"); return root; } @Test public void test() { //要在别的类中使用只需要调用下面这句话即可，参数传入自己的root节点 TreeVisualUtil.printNode(myTree()); }} 效果如下，还不错！ 其他树的题目点击这里","link":"/algorithms/traverse-and-visualize-binary-tree-with-java/"},{"title":"Quill笔记","text":"1.什么是富文本编辑器百度百科： 通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。 富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue 但是我们今天要说的，是一款支持Vue的富文本编辑器：vue-quill-editor 2.Vue-Quill-EditorGitHub的主页：https://github.com/surmon-china/vue-quill-editor Vue-Quill-Editor是一个基于Quill的富文本编辑器：Quill的官网 3.使用指南使用非常简单：已经在项目中集成。以下步骤不需操作，仅供参考 第一步：安装，使用npm命令： 1npm install vue-quill-editor --save 第二步：加载，在js中引入： 全局引入： 123456import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'const options = {}; /* { default global options } */Vue.use(VueQuillEditor, options); // options可选 局部引入： 1234567891011import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'import {quillEditor} from 'vue-quill-editor'var vm = new Vue({ components:{ quillEditor }}) 我们这里采用局部引用： 第三步：页面使用： 1&lt;quill-editor v-model=\"goods.spuDetail.description\" :options=\"editorOption\"/&gt; 4.自定义的富文本编辑器不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。 使用也非常简单： 123&lt;v-stepper-content step=\"2\"&gt; &lt;v-editor v-model=\"goods.spuDetail.description\" upload-url=\"/upload/image\"/&gt;&lt;/v-stepper-content&gt; upload-url：是图片上传的路径 v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description 5.效果","link":"/frontend/Quill%E7%AC%94%E8%AE%B0/"},{"title":"MySQL基础","text":"1. MySQL基本架构 连接器客户端每发起一个连接请求，首先经过连接器，建立tcp连接，校验账号密码。连接器会维护连接列表processlist 可以通过show processlist查看，其中刚开启的线程处于sleep状态 Time代表已Sleep的时间，如果超过了wait_timeout需要重连，默认8小时，可以通过show variables like '%timeout%'命令查看 为了防止断线重连，可以采用如下方法： 长连接：由于连接在内存中，容易造成OOM异常，mysql重启，jvm会Full GC 重置连接资源：通过命令mysql_reset_connection，可以在不断线的情况下重置连接资源 ps: 要注意让spring配置连接池bean的时候设置的maxIdleTime属性（不同连接池属性名可能不一样）要小于mysql的wait_timeout 缓存k-v形式，如果命中，直接返回数据，如果未命中，走分析器，并在获取结果后缓存，以便第二次查。因为用的少（缓存都走redis了）8.0后取消了，8.0之前，explain索引分析的时候记得加上SQL_NO_CACHE关掉 分析器词法分析（查询还是别的操作，哪张表，哪列等），语法分析（运行时会报SQL syntax语法错误） 优化器是否使用索引，使用什么索引。有时候会用错索引，使用analyze table table_name或者强制走索引force index 执行器操作引擎执行SQL 引擎 参考 https://baijiahao.baidu.com/s?id=1655327558614401593&amp;wfr=spider&amp;for=pc https://zhuanlan.zhihu.com/p/53619907 通过show engines;就可以查看支持的引擎，有9种，常见的有3，4种（InnoDB，MyISAM，CSV，MEMORY） 查看某张表的引擎等信息可以用show table status like ‘user’ \\G 一张表横向对比 InnoDB MySQL默认的事务型引擎 用来处理大量短期事务，短期事务大部分是正常提交的，很少回滚 通过间隙锁（next-key locking）防止幻读的出现 基于聚簇索引建立，与其他存储引擎有很大的区别，聚簇索引对主键查询有很高的性能，不过它的二级索引（secondary index，非主键索引）必须包含主键列。所以如果主键列很大的话，索引会很大 性能高 自动崩溃恢复 InnoDB页结构，16kb 索引B+树中⼀个节点为⼀⻚或⻚的倍数最为合适，如果读取1.2页也要读取2页 MyISAM 5.1之前，MyISAM是默认的引擎 适用于些只读数据，或者表空间较小 特性：全文索引、支持压缩、空间函数。全文索引：基于分词创建的索引，也可以支持复杂的查询。压缩：如果数据在写入后不会修改，那么这个表适合MyISAM压缩表。可以使用myisampack对MyISAM表进行打包，压缩表是不可以修改数据的，可以减少磁盘IO，提升性能，压缩表也支持索引，但是索引也是只读的 不支持事务和行级锁（后续版本中支持了事务），对整个表加锁，而不是行锁，读取的时候对表加共享锁，写入的时候加排他锁，但是可以同时读写。但是由于没有行锁机制，所以在海量写入的时候，会导致所有查询处于Locked状态。 将表存储在两个文件中：数据文件、索引文件，分别是.MYD、.MYI后缀 行记录数取决于磁盘空间和操作系统中的单个文件最大尺寸 即使是Blob，Text等等长字段，也可以基于前500字符创建索引 可以选择延迟更新索引键，在创建表的时候指定delay_key_write选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是写到缓存区，只有在清理缓存区或者关闭表的时候才会将索引写入磁盘。这可以极大的提升写入性能，但是在主机崩溃时会造成索引损坏，需要执行修复操作。 CSV CSV引擎可以将普通的CSV文件作为MySQL表来处理 不支持索引 CSV可以在数据库运行时拷贝或者拷出文件，可以将Excel等电子表格中的数据存储为CSV文件，然后复制到MySQL中，就能在MySQL中打开使用。 同样，如果将数据写入到一个CSV引擎表，其他外部程序也可以从表的数据文件中读取CSV的数据。因此CSV可以作为数据交换机制。非常好用。 Memory 所有的数据都保存在内存中，不需要进行磁盘I/O Memory表的结构在重启以后还会保留，但数据会丢失 需要快速地访问数据，并且这些数据不会被修改（例如将邮编和州名映射的表） 比MyISAM表要快一个数量级（因为在内存中） 2. MySQL索引和SQL调优关于索引，内容比较多，另外开了一篇文章==&gt;mysql索引 3. 日志系统3.1 redo log内容：记录数据修改操作（事务尚未提交） 作用：异常宕机或者介质故障后的数据恢复（crash safe） 层级：innoDB层面 解释： 更新语句–&gt;写redo log–&gt;更新内存数据–&gt;空闲/按策略将redo log写入磁盘，这种先写日志再写磁盘的技术称为WAL(Write Ahead logging) redo log大小是固定的，循环写。write pos走在前面，表示当前写入redo log的位置。checkpoint表示同步到磁盘的位置。如下图 有一条update语句执行，redo log从write pos开始往右写，到头后循环到最左边继续，当碰到check point说明redo log满了，会立即同步到磁盘。 同样的，如果空闲了也会同步到磁盘，checkpoint也会往右移，当碰到write pos说明redo log空了。 3.2 undo log内容：记录事务开始前的值 作用：用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读 层级：innoDB层面 3.3 bin log内容：记录二进制 作用：主从复制同步，时间点还原 层级：MySQL Server层面 3. 事务、隔离级别和MVCC事务 原子性（Atomicity）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，发生错误会被回滚（Rollback）到事务开始前的状态。 一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则。比如转账一边-100另一边+100，总体不变就是其中一种预设规则。 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 隔离级别几种隔离级别 读未提交（READ UNCOMMITTED） ：⼀个事务还没提交时，它做的变更就能被别的事务看到。 读提交（READ COMMITTED） ：⼀个事务提交之后，它做的变更才会被其他事务看到。 可重复读（REPEATABLE READ）：⼀个事务执⾏过程中看到的数据，总是跟这个事务在启动时看到的数据是⼀致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化（SERIALIZABLE）：对于同⼀行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写锁冲突的时候，后访问的事务必须等前⼀个事务执⾏完成，才能继续执行。 通过以下mysql语句更改 1SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 上面几种level; 并发问题 脏读（dirty read） ：如果⼀个事务读到了另⼀个未提交事务修改过的数据。 不可重复读（non-repeatable read）：如果⼀个事务只能读到另⼀个已经提交的事务修改过的数据，并且其他事务每对该数据进⾏⼀次修改并提交后，该事务都能查询得到最新值。 幻读（phantom read）：如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来。 ps：不可重复读和幻读有点像，主要区别在于不可重复读是两次查询某一条数据的修改，幻读是查询整张表出现的新增。也就是新增那行原来不存在所以锁不住，控制的手段也会不一样。 对应解决 读未提交：啥都不能解决 读提交：解决脏读，事务A读取的是事务B开始前和提交后的数据 可重复读：解决脏读、不可重复读，事务A整个过程读取的都是事务B开始前的数据 串行化：解决脏读、不可重复读、幻读，事务A过程中事务B只能等待 MVCC读提交和可重复读为什么可以读取另一个事务开始前的数据呢？这里就要提到MVCC（Multi-Version Concurrency Control ，多版本并发控制），在事务在启动的时候就“拍了个快照”，这个快照被称为一致性视图。 那快照是怎么实现的呢？当然不需要完全复制一张表，而是使用了undo log中一个叫版本链的东西，事实上每一行数据都有隐藏的trx_id记录了每一个版本，还有一个roll_pointer指针域指向旧版本，形成一个undo log链表 MVCC就是根据某一个版本生成对应的一致性视图 如果是读提交，则在每个SQL执行前生成 如果是可重复读，则只在第一次查询的时候生成一次 参考本文参考 三太子敖丙公众号MySQL系列文章 CSDN博客:二十六画生的博客（https://blog.csdn.net/u010002184/article/details/88526708） CSDN博客:cwjokaka（https://blog.csdn.net/u013295276/article/details/79105163）","link":"/Mysql/MySQL%E5%9F%BA%E7%A1%80/"},{"title":"JWT+RSA非对称加密实现无状态登录","text":"1. 问题以前我们的登录都是将当前登录的用户信息放在session中，但是session是保存在服务器的，在分布式环境下服务器不只有一台，那就容易找不到登录的用户信息，所以应该是保存在客户端也就是cookie中的，但是存在cookie中有个问题，就是要进行一些操作时需要获取当前登录的用户信息，那么要将cookie中的user发送过去，这一来二去老是携带着明文的用户名和密码，就很不安全，会被人用一些技术手段拦截，那么就获取了你的账号密码信息。 随后就产生了一些加密技术，也就是说cookie中存的user信息是密文（此时称为token），就算被拦截了没有破解方法（称为密钥）也没有用。 1. RSA非对称加密技术看大佬的讲解 https://www.zhihu.com/question/304030251 当然，后面还涉及到一些更深入的东西（中间人攻击，CA认证中心等），有时间再补笔记(●’◡’●)计网的笔记先埋个坑慢慢填 追更：计网的笔记点击这里 2. JWT是token的一种，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范。格式是这样的（头部：我是JWT格式的token，载荷：用户信息，签名：头部和载荷合在一起再加密） 我们来看一下登录的流程 我们首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个信任的微服务 用户请求登录 授权中心校验，通过后用私钥对用户信息进行签名加密生成jwt 返回jwt给用户并保存在cookie中 用户携带JWT访问 Zuul直接通过公钥解密JWT，进行验证，验证通过则放行 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心 3. 具体实现及登录功能细节3.1 加密生成jwt部分实现 创建载荷对象，也就是jwt中的载荷部分，无需包含密码和盐（使用了rsa以后，只要公钥能解析不出错就说明认证成功了） 会用到的依赖 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; 四个工具类 RsaUtils：生成rsa密钥（一个公钥一个私钥）方法，读取公钥密钥方法 JwtUtils：将用户信息使用私钥加密成jwt格式的token方法，使用公钥解析token获得用户信息方法 代码太多了，反正是工具类，这里给个下载链接，直接下载粘贴即可食用 http://39.106.175.70/owncloud/index.php/s/xcW47RaFFiSjfQ0 运行测试类，直接复制即可食用 要替换的地方已用注释标明 1234567891011121314151617181920212223242526272829303132333435363738394041public class JwtTest { //rsa公钥私钥位置 private static final String pubKeyPath = \"C:\\\\Users\\\\wjw\\\\.leyoursa\\\\rsa.pub\"; private static final String priKeyPath = \"C:\\\\Users\\\\wjw\\\\.leyoursa\\\\rsa.pri\"; private PublicKey publicKey; private PrivateKey privateKey; @Test public void testRsa() throws Exception { RsaUtils.generateKey(pubKeyPath, priKeyPath, \"234\"); //生成rsa密钥，最后一个是盐，随便给，越复杂越好 } //第一次执行时没有文件所以注释掉，执行完上面那个函数后放开before注释 //@Before public void testGetRsa() throws Exception { this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); } @Test public void testGenerateToken() throws Exception { // 用私钥加密user信息生成token String token = JwtUtils.generateToken(new UserInfo(20L, \"jack\"), privateKey, 5); System.out.println(\"token = \" + token); } @Test public void testParseToken() throws Exception { //使用公钥解密token //改成上面那个函数生成的token试试解密 String token = \"eyJhbGciOiJSUzI1NiJ9.eyJpZCI6MjAsInVzZXJuYW1lIjoiamFjayIsImV4cCI6MTU5NTIzMzI4OX0.IhrxQJ9vmdME2EaOiGl-IEI6JybKDo6y7UlCp0pBWwfusUHbY3xjMFnGnnRvQ2keOU7AFetBhMPw03T4pUbUil8tmzc38mk5etYs0kxkoa2_qmeu80qqQUBVvfexYmZkvo3nOjz66IFfX716CWgZ-9Ew8zAib1o0TFkJ4RnjV5w\"; // 解析token UserInfo user = JwtUtils.getInfoFromToken(token, publicKey); System.out.println(\"id: \" + user.getId()); System.out.println(\"userName: \" + user.getUsername()); }} 加密解密测试效果： 3.2 cookie部分实现加密这部分测试成功之后我们注意到登录功能还需要保存到cookie中 也提供一个工具类，直接复制即可食用 http://39.106.175.70/owncloud/index.php/s/Y2tQJoCMUILK0ZY 3.3 登录流程业务逻辑实现rsa,jwt,cookie都弄好后，就可以实现登录功能了 其实登录就比较简单，controller service那些，跟着之前流程来就行 不过测试用例写死了不优雅，可以使用yml+配置类读取（当然你可以暴力） yml 配置类 给出代码，省略篇幅，包自己引入一下，getter/setter自己创建一下 123456789101112131415161718192021222324252627282930313233343536373839404142@ConfigurationProperties(prefix = \"leyou.jwt\")public class JwtProperties { private String secret; // 密钥 private String pubKeyPath;// 公钥 private String priKeyPath;// 私钥 private int expire;// token过期时间 private String cookieName; private PublicKey publicKey; // 公钥 private PrivateKey privateKey; // 私钥 private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); /** * @PostContruct：在构造方法执行之后执行该方法 */ @PostConstruct public void init(){ try { File pubKey = new File(pubKeyPath); File priKey = new File(priKeyPath); if (!pubKey.exists() || !priKey.exists()) { // 生成公钥和私钥 RsaUtils.generateKey(pubKeyPath, priKeyPath, secret); } // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); } catch (Exception e) { logger.error(\"初始化公钥和私钥失败！\", e); throw new RuntimeException(); } } //get,set自己生成一下} 后面的没什么好说了，代码太简单，有手就行，我贴图分析吧 controller service 3.4 cookie细节的处理cookie是保存在本地的，那么通过localhost访问就没什么问题，但是通过域名访问就有问题 以下是对比图 先解决方法再分析原因： nginx配置文件的网关部分添加proxy_set_header Host $host; zuul的yml 原因：我们通过调试可以看到cookie的domainName是计算机名称而不是leyou.com 这个计算机名是哪来的呢，因为zuul到登录微服务是通过eureka注册中心的 访问流程是nginx=&gt;zuul=&gt;登录微服务，因此我们要让计算机名带着访问路径一起走才对，所以才有了上面的设置，解决后的效果 3.5 token过期处理的思路token和cookie都有过期时间，如果用户在一段时间内没有操作那么过期了就需要重新登录，没有问题。但是如果一直在操作（比如选购商品选了很久，最后下单的时候发现cookie过期了，拿不到用户登录信息，就很尴尬）。 解决思路比较简单，就是不管进行什么操作，vue可以放在created钩子函数中，只要加载了页面，就调用verify这个方法：验证是否有token，如果还有，则说明用户正在操作，重新更新一遍token和cookie，防止过期 1234567891011121314151617181920212223242526/** * 验证是否还在登录状态，不管进行什么操作，比如搜索啊下单啊，浏览啊，都应该调用一下这个方法，以表明用户还在操作 * 只要调用这个方法，就验证是否有token，然后重新更新一遍token，防止过期 */@GetMapping(\"verify\")public ResponseEntity&lt;UserInfo&gt; verify( @CookieValue(\"LY_TOKEN\") String token, HttpServletRequest request, HttpServletResponse response){ try { //使用公钥解析jwt UserInfo user = JwtUtils.getInfoFromToken(token, this.jwtProperties.getPublicKey()); if (user == null){ return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); } //刷新jwt和cookie中的有效时间，不退出就一直登录 token = JwtUtils.generateToken(user, this.jwtProperties.getPrivateKey(), this.jwtProperties.getExpire()); CookieUtils.setCookie(request, response, jwtProperties.getCookieName(), token, jwtProperties.getExpire() * 60); return ResponseEntity.ok(user); } catch (Exception e) { e.printStackTrace(); return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); }} 3.6 zuul网关拦截注册，登录，搜索等功能不需要拦截 下单等功能需要拦截判断是否已登录 网关微服务只需要公钥和cookie名字，以及白名单 123456789101112leyou: jwt: pubKeyPath: C:\\Users\\wjw\\.leyoursa\\rsa.pub # 公钥地址 cookieName: LY_TOKEN filter: allowPaths: # 白名单 - /api/auth - /api/search - /api/user/register - /api/user/check - /api/user/code - /api/item 复制一份读取yml的配置类到网关微服务，需要相应修改，只读取不创建 123456789101112131415161718192021222324252627@ConfigurationProperties(prefix = \"leyou.jwt\")public class JwtProperties { private String pubKeyPath;// 公钥 private String cookieName; private PublicKey publicKey; // 公钥 private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); /** * @PostContruct：在构造方法执行之后执行该方法 */ @PostConstruct public void init(){ try { // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); } catch (Exception e) { logger.error(\"初始化公钥和私钥失败！\", e); throw new RuntimeException(); } } //省略getter,setter} 读取白名单的配置类单独出来 12345678910111213141516/** * 白名单配置类 */@ConfigurationProperties(prefix = \"leyou.filter\")public class FilterProperties { private List&lt;String&gt; allowPaths; public List&lt;String&gt; getAllowPaths() { return allowPaths; } public void setAllowPaths(List&lt;String&gt; allowPaths) { this.allowPaths = allowPaths; }} 有了这两个配置类就可以读取yml参数了，主要完成下面这个拦截器即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 除了注册，登录，发短信，搜索等功能以外，所有的微服务进入前都要判断是否已登录 */@Component@EnableConfigurationProperties({JwtProperties.class, FilterProperties.class})public class LoginFilter extends ZuulFilter { @Autowired private JwtProperties jwtProperties; @Autowired private FilterProperties filterProperties; @Override public String filterType() { return \"pre\"; } @Override public int filterOrder() { return 10; } @Override public boolean shouldFilter() { //白名单不拦截 List&lt;String&gt; allowPaths = this.filterProperties.getAllowPaths(); //初始化运行上下文获取request和response RequestContext context = RequestContext.getCurrentContext(); HttpServletRequest request = context.getRequest(); String url = request.getRequestURL().toString(); for (String allowPath : allowPaths) { if (StringUtils.contains(url, allowPath)) { return false; //不拦截 } } return true; } @Override public Object run() throws ZuulException { //获取token //初始化运行上下文获取request和response RequestContext context = RequestContext.getCurrentContext(); String token = CookieUtils.getCookieValue(context.getRequest(), this.jwtProperties.getCookieName()); if (StringUtils.isBlank(token)){ context.setSendZuulResponse(false); context.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); } //解析 try { JwtUtils.getInfoFromToken(token, this.jwtProperties.getPublicKey()); } catch (Exception e) { e.printStackTrace(); context.setSendZuulResponse(false); context.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); } return null; }} 3.7 最终效果看看页面上，cookie有了，value是jwt，域名也对了，注册和登录也不拦截了，腰不酸腿不痛了 嗯！是主流登录的实现效果~","link":"/SpringCloud/JWT+RSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95/"},{"title":"SpringMVC接收前端参数为null的探索","text":"在使用SpringMVC时接收前端参数有时后会无法封装，获得null值，报415错误的问题，原因就是有时候我们搞不懂json对象、json字符串、参数字符串之间的区别。 提交方式：form/url，ajax 请求方式：get，post 接收方式：一个个参数接收，封装实体类(Bean类型) 文章将会排列组合= =，举例说明各种搭配如何成功接收数据。 form/url + get + 一个个接收/Bean类型get请求基本没有什么坑，controller层一个个接和用实体类接都没有问题 html 123456&lt;form action=\"testGet\"&gt; 单个&lt;input type=\"text\" name=\"a\"&gt;&lt;br&gt; 姓名：&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"age\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; controller 1234567@RequestMapping(\"/testGet\")public String testGet(int a, User user){ System.out.println(\"testGet方法执行了\"); System.out.println(a); System.out.println(user); return \"success\";} form + post + 字符串类型用一整个String body接收 html 12345&lt;form action=\"testPostString\" method=\"post\"&gt; 姓名&lt;input type=\"text\" name=\"username\" /&gt;&lt;br&gt; 年龄&lt;input type=\"text\" name=\"age\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/form&gt; controller 123456@RequestMapping(\"/testPostString\")public String testPostString(@RequestBody String body){ System.out.println(\"testPostString方法执行了\"); System.out.println(body); return \"success\";} 可以看到form表单发送的数据格式 这种类似于get请求时发送url格式的参数我称为“参数字符串”，用一个String body接收是没问题的。就是麻烦了一点，需要接收后再处理成json对象 form + post + Bean类型这个组合获取不到值会报415，就是类型不匹配(String和User)，解决方法是在controller方法的参数上加@ModelAttribute注解 html 12345&lt;form action=\"testPostBean\" method=\"post\"&gt; 姓名&lt;input type=\"text\" name=\"username\" /&gt;&lt;br&gt; 年龄&lt;input type=\"text\" name=\"age\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/form&gt; controller 123456@RequestMapping(\"/testPostBean\")public String testPostBean(@ModelAttribute User user){ System.out.println(\"testPostBean方法执行了\"); System.out.println(user); return \"success\";} 加了注解就可以自动封装 ajax + get/post + bean类型异步的请求，发送给后台的就是两种：json或者json字符串，这个我觉得真的有点坑 这篇csdn博客写的很详细：https://blog.csdn.net/qq_37960007/article/details/79542727 根据这位博主的描述我直接给出这两种的写法，再做说明 两种可行办法 json字符串 + contentType指定为json + Bean接收 json对象 + contentType不指定 + Bean接收 法1ajax 1234567891011$.ajax({ url: \"testAjax\", contentType: \"application/json;charset=utf-8\", data:'{\"username\": \"haha\", \"age\": 20}', dataType: \"json\", type: \"post\", success:function (data) { alert(data); alert(data.age); }}); controller 1234567@RequestMapping(\"/testAjax\")public @ResponseBody User testAjax(@RequestBody User user){ System.out.println(\"testAjax方法执行了\"); System.out.println(user); user.setAge(100); return user;} 同时需要jackson的maven坐标 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt; 效果如下，确实能接收（@ResponseBody注解是将User类变成json格式返回给前端，这个不是接收，不是我们要讨论的） 法2ajax 12345678910$.ajax({ url: \"testAjax2\", data:{\"username\": \"haha\", \"age\": 20}, dataType: \"json\", type: \"post\", success:function (data) { alert(data); alert(data.age); }}); controller 1234567@RequestMapping(\"/testAjax2\")public @ResponseBody User testAjax2(@ModelAttribute User user){ System.out.println(\"testAjax方法执行了\"); System.out.println(user); user.setAge(100); return user;} 也是可以的 区别在哪里？ json字符串和json对象 你不要问那些键加不加双引号行不行，值加不加双引号行不行，其实都可以，但是如果你写的标准的话他们就相差一对单引号！ 是否有contentType: &quot;application/json;charset=utf-8&quot; 这个是指定发送给后台的类型，如果指定了json，那么说明：应该写json字符串，因为它会自动帮你转换这个字符串 如果没指定，则应该直接写json对象，因为它不会帮你转换，别弄反了 controller层的区别 如果是用json字符串，那么controller就应该导入jackson的jar包，通过它来帮助我们完成映射 如果是用json对象，那么controller就使用@ModelAttribute，情况就行普通post的Bean封装 真的是天坑！！！！ ps：json对象 -&gt; json字符串可以通过字符串的拼接或者JSON.stringify() ​ json字符串 -&gt; json对象可以手动去除字符串或者JSON.parse() axios + post + 字符串/bean类型使用axios工具，如果发送post请求，且不用url拼接字符串的方式，而是试图发送整个json对象，如下 那么需要借助上面图中这样的qs工具，只需要在main.js（也可以随便找个全局的js文件）引入这个工具 这样就可以像上面图示那样发送整个对象了，后台能接到","link":"/Spring/SpringMVC%E6%8E%A5%E6%94%B6%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E4%B8%BAnull%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"title":"SpringMVC入门笔记1","text":"先讲一些自己的理解和概念性的东西，可以跳过直接看第3部分 1. SpringMVC的作用SpringMVC实际上就是代替了原来Servlet中的作用，为什么使用SpringMVC，其实我们内心也很清楚，原来写Servlet的时候要么是继承了Servlet接口复写5个生命周期方法（init service … destory），要么继承HttpServlet接口复写doGet和doPost方法，非常繁琐。或者高级一点的进行servlet抽取，通过方法名代表访问路径，其实这就相当于springmvc的简易模型。 而SpringMVC就是完成了*“一个普通类也可以处理http请求” *这么一个功能。 作用和servlet一样，接收前端请求参数，调用service层方法，返回json数据 1.1 MVC模型 MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 Model：数据模型，JavaBean的类，用来进行数据封装。 View：指JSP、HTML用来展示数据给用户 Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 1.2 SpringMVC中的一些组件 前端控制器（DispatcherServlet） 处理器映射器（HandlerMapping） 处理器（Handler） 处理器适配器（HandlAdapter） 视图解析器（View Resolver） 视图（View） 流程如下 2. web项目的环境搭建既然是web应用，当然要使用Maven骨架创建一个webapp项目，这样结构比较标准！注意不要选错了 这里添加archetypeCatalog参数的值为internal可以快一点 后面就一路next了 注意，由于使用骨架创建的项目没有java和resources目录，而我们熟悉的项目结构是 └─src &nbsp;&nbsp;&nbsp;&nbsp;└─main &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─java &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─resources &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─webapp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─WEB-INF 所以我们需要手动创建java和resources目录并把他们标记成source root和resources root，否则的话没有办法创建java类和配置文件，具体做法如下 配置好tomcat就可以了，这里就不介绍了 ​ 3. SpringMVC使用3.1 pom坐标123456789101112131415161718192021222324252627282930313233343536&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!--版本锁定--&gt; &lt;spring.version&gt;5.2.3.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 3.2 web.xml中的配置1234567891011121314151617181920212223242526272829303132&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置字符过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; ​ 3.3 resources文件夹下新建springmvc.xml文件并写入1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"com.wjw\"&gt;&lt;/context:component-scan&gt; &lt;!--配置视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启SpringMVC框架注解的支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 其中internalResourceViewResolver中配置的路径就是Controller类中return自动跳转的对应页面 ​ 3.4 普通的类代替servletjava文件夹中创建一个名为controller的包和一个HelloController类（也就是我们俗称的controller层），如果类上方也有@RequestMapping(“/user”)标签，则表示多级目录，那么前端页面需要访问user/hello 能自动对应上前端页面的名称是因为springmvc.xml中视图解析器中写明了路径 ​ 3.5 随便写一个html/jsp页面提交请求 这时候我们就可以启动tomcat访问index.jsp了，如无意外你就可以看到控制台打印了aaa,达到跟servlet一样的效果了 ​ 4. 静态资源的访问方法html/css/js/img等属于静态资源，要访问他们，必须设置静态资源不拦截。以下给出两种方法。 4.1 设置servlet-mapping在web.xml对应位置（servlet-mapping的位置你懂的吧）中添加 123456789101112131415161718192021222324&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 同理，其他格式的自定义 4.2 mvc提供的方式springmvc提供了一种标签可以设置静态资源不拦截 1234&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;!-- 样式 --&gt;&lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;!-- 图片 --&gt;&lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- javascript --&gt; 根目录是指webapp目录，html同理，加上就好 5. 请求参数绑定变量和实体类前端的请求数据总会带上参数，我们常常需要将参数封装，springmvc是通过变量名字来自动对应的，省去了原来用request.getParameter()的麻烦。 那么前端提交的name就必须像下面那样写 Controller层 6. 获取原生Servlet的API（request和response）一般很少用，直接给controller的方法添加两个形参：HttpServletRequest request和HttpServletRequest response response就可以使用了 7. 常见的注解@RequestMapping上面已经用过了，它还有这么一些属性 path/value：指明请求url，如果只有这个参数则可以不写 mthod：可以指定POST和GET两种方式 params：指定前端必须要传递进来的参数 headers：指定请求中必须包含的请求头 @RequestParams(value=“name”)解决url参数可以和接收的参数名字不匹配的问题 比如前端参数是name 后台是username，对应不上，因此我们可以用这个注解指定url接收名 @RequestBody同上，不过是对post请求（前端通过表单提交且method=”post”，或者ajax异步时使用post） 后台方法形参还是一个String body，这个body包括：username=哈哈&amp;age=13 @PathVariable(value=”id”)这个注解为了restful风格而生（一种倡导/root/user/10而不是/root/user?id=10的风格） Controller层，属性value或者name都一样 前端传值的时候的路径 @RequestHeader用法和上面的类似，都是加在字符串形参前面，用处是获得某个请求头的值，如@RequestHeader(value=”Accept”) @CookieValue使用方法同上，用于获取Cookie值 @ModelAttribute写在方法上，也可以写在参数上。写在方法上时，作用是优先于原来前端请求的对应方法，前端请求的参数会进入该方法的形参，该方法返回值会进入原先请求的方法的形参 有种拦截的味道 如果没有返回值，那么可以在该方法形参添加一个map，方法内用map集合存住返回值，这时可以将@ModelArrtibute写在原先请求的方法的形参参数上，属性就是map的key @SessionAttributes同样的，存入session域中 8. 返回给前端的信息前面说完了接收请求，现在来说一下返回数据，Controller层的方法可以有多种返回值应对不用的响应需求 8.1 页面跳转型8.1.1 返回值为String类型return的值为”success”，会经过视图解析器，找到success.jsp 还有一种不太常用的方法，使用request和response转发和重定向 return &quot;forward:/WEB-INF/pages/success.jsp&quot;; 或者是 return &quot;redirect:/index.jsp&quot;; 8.1.2 返回值为void类型则会默认跳转方法上面的RequestMapping的路径.jsp，如果不存在，则会报404错误。或者可以使用request和response转发和重定向获取servlet的api，如此则自己写要跳转的页面，注意：因为这样不再经过视图解析器，注意路径不能再写success，而是/WEB-INF/pages/success.jsp，如果是response还要注意加上response.getContextPath()返回值为 8.1.3 返回值为ModelAndView类型这是一个专门用来处理页面跳转返回的类，其实就是String返回类型+Model类的合体，通过addObject方法存入request域和session域中，通过setViewName方法可以通过视图解析器指定跳转页面 8.2 json型正常点，这种一般都是对应异步请求 要先放开静态资源（js，图片，css），否则会被拦截，做法是在springmvc.xml中添加 1234&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;!-- 样式 --&gt;&lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;!-- 图片 --&gt;&lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- javascript --&gt; @ResponseBody作用是将返回值以json的格式发送给前端，写在方法返回值类型上 前端ajax请求代码 12345678910111213$.ajax({ url: \"user/testAjax\", contentType: \"application/json;charset=utf-8\", data:'{\"username\": \"hehe\", ' + '\"password\": \"123\", ' + '\"age\": \"20\"}', dataType: \"json\", type: \"post\", success:function (data) { alert(data); alert(data.age); }}); json字符串和JavaBean对象互相转换的过程中，需要以下jackson坐标 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt; 关于json对象和json字符串和普通字符串传输时造成null值的一些坑，可以看这篇文章","link":"/Spring/SpringMVC%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"title":"SpringMVC入门笔记2","text":"1. SpringMVC的文件上传1.1 文件上传的必要前提 form表单的enctype取值必须是：muitipart/form-data（默认值是：application/x-www-form-urlencoded），enctype：是表单请求正文的类型 必须是POST请求 html中通过&lt;input type=&quot;file&quot; /&gt; 来提交 commons-fileupload两个库 1.2 SpringMVC实现文件上传 添加maven依赖坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; springmvc.xml中配置文件解析器 需要注意的是，这里的id必须叫做multipartResolver，不能自己乱改 123&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\" /&gt; &lt;!--单位是字节--&gt;&lt;/bean&gt; html 注意这里的 method=”post” enctype=”multipart/form-data” 不能变 name=”upload”可以改，但是要和下面的controller层接收方法的参数名一致 1234&lt;form action=\"user/fileUpload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"upload\" /&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt; controller 注意这里的参数名upload要和html表单的文件的name属性名一致 1234567891011121314151617181920@RequestMapping(\"/fileUpload2\")public String fileUpload2(HttpServletRequest request, MultipartFile upload) thro //springmvc方式上传文件 //上传的位置(文件夹目录) String path = request.getSession().getServletContext().getRealPath(\"/uploads File file = new File(path); //如果不存在，就创建 if (!file.exists()){ //创建文件夹 file.mkdirs(); } //获取上传文件名称 String fileName = upload.getOriginalFilename(); //为了两次上传导致文件名相同而冲突，所以我们用uuid设置filename String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); // 完成文件上传 fileName = uuid + \"_\" + fileName; upload.transferTo(new File(path, fileName)); return \"success\";} 1.3 jersey跨服务器上传在实际开发中，我们会有很多处理不同功能的服务器。例如： 应用服务器：负责部署我们的应用 数据库服务器：运行我们的数据库 缓存和消息服务器：负责处理并发访问的缓存和消息 文件服务器：负责存储用户上传文件的服务器。 1.3.1 步骤 新增pom坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.19.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.19.4&lt;/version&gt;&lt;/dependency&gt; 创建新的module或者project作为图片服务器，并配置好tomcat（详情略），要注意在target中手动创建文件夹,tomcat两个端口不能冲突 html同上 1234&lt;form action=\"user/fileUpload3\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"upload\" /&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt; controller 123456789101112131415161718@RequestMapping(\"/fileUpload3\")public String fileUpload3(MultipartFile upload) throws Exception { //跨服务器方式上传文件 //定义上传文件服务器路径 String path = \"http://localhost:9090/uploads/\"; //获取上传文件名称 String fileName = upload.getOriginalFilename(); //为了两次上传导致文件名相同而冲突，所以我们用uuid设置filename String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); fileName = uuid + \"_\" + fileName; //创建客户端对象 Client client = Client.create(); //和图片服务器进行连接 WebResource webResources = client.resource(path + fileName); //上传文件 webResources.put(upload.getBytes()); return \"success\";} 1.3.2 常见错误的解决：403错误权限问题 打开tomcat安装目录apache-tomcat-8.5.46\\conf\\web.xml，ctrl+F搜索&lt;servlet-name&gt;default&lt;/servlet-name&gt;找到如下图所示的位置，在如下图位置加入 1234&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt; 效果如下 404错误目录问题，fileupload的tomcat配置改为根目录即可 或者你不想改虚拟目录，那就要在应用服务器这边把上传的图片服务器的路径中加入刚刚的虚拟目录也是可以的 405错误同403错误 409错误文件夹为空问题，因为上传图片的目录是uploads，所以手动在图片服务器的target目录创建uploads文件夹 500错误原因复杂 2. SpringMVC异常处理为了避免浏览器直接弹出错误 让界面友好一点（比如页面提示系统正在维护中），我们可以通过异常处理器来跳转错误页面 springmvc.xml中 id只能是这个名字sysExceptionResolver，不能乱改 12&lt;!--配置异常处理器--&gt;&lt;bean id=\"sysExceptionResolver\" class=\"com.wjw.exception.SysExceptionResolver\"/&gt; 接下来我们创建并完成这两个类 自定义一个异常类SysException，继承Exception（像实体类那样的） 1234567891011121314151617public class SysException extends Exception { //存储提示信息 private String message; public SysException(String message) { this.message = message; } @Override public String getMessage() { return message; } public void setMessage(String message) { this.message = message; }} SysExceptionResolver类 实现HandlerExceptionResolver接口，异常处理器 12345678910111213141516171819202122232425public class SysExceptionResolver implements HandlerExceptionResolver { /** * 处理异常的业务逻辑 * @param httpServletRequest * @param httpServletResponse * @param o * @param e * @return */ @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) { // 获取到异常对象 SysException ex = null; if (e instanceof SysException){ ex = (SysException)e; }else { ex = new SysException(\"系统正在维护\"); } ModelAndView mv = new ModelAndView(); mv.addObject(\"errorMsg\", e.getMessage()); mv.setViewName(\"error\"); return mv; }} 使用方法如下 3. SpringMVC拦截器跟servlet中的过滤器filter一样，改名拦截器。有一丢丢不同，拦截器不会拦jsp，html，css，images等静态资源，但是过滤器如果配置了/*，全部都会拦下来。 3.1 xml方式 springmvc.xml中 1234567891011&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--配置每个拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--拦截具体方法--&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!--不拦截的方法--&gt; &lt;!--&lt;mvc:exclude-mapping path=\"\"/&gt;--&gt; &lt;bean class=\"com.wjw.interceptor.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 可以使用多个&lt;mvc:interceptor&gt;标签来指定多个拦截器，拦截器的顺序就是配置顺序 mvc:mapping和mvc:exclude-mapping是一组相对的标签，设置拦截路径和不拦截路径 自定义拦截器类 实现HandlerInterceptor接口 preHandle：预处理 controller方法前执行 postHandle：后处理 controller方法后，jsp/html执行之前 afterCompletion：最后处理 页面执行后执行的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyInterceptor implements HandlerInterceptor { /** * 预处理 controller方法前执行 * return true为放行，执行下一个拦截器或controller方法 * return false则不放行，可以通过request和response来跳转 * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"拦截器预处理运行了\"); //request.getRequestDispatcher(\"/WEB-INF/pages/error.jsp\").forward(request, response); return true; } /** * 后处理 controller方法后，jsp/html执行之前 * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"拦截器后处理\"); } /** * 页面执行后执行的方法 * @param request * @param response * @param handler * @param ex * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"afterCompletion方法\"); }} 实现HandlerInterceptor接口需要实现三个方法，为了偷懒，可以 extends HandlerInterceptorAdapter HandlerInterceptorAdapter是HandlerInterceptor接口的默认实现类，那么你需要哪个方法就overwrite哪个方法就行，其他写法上是一样的。 不使用xml的方式spring当然也支持java配置类的方式，何况如果使用了springboot使用java配置类就更多了 拦截器还是跟上面一样实现HandlerInterceptor接口或者继承HandlerInterceptorAdapte类，但是要在类上方加上@Component注解 xml不需要了，创建一个java配置类，实现WebMvcConfigurer接口，复写addInterceptors方法，具体代码如下： 1234567891011@Configurationpublic class WjwMvcConfiguration implements WebMvcConfigurer { @Autowired private LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginInterceptor).addPathPatterns(\"/**\"); //拦截所有路径 }}","link":"/Spring/SpringMVC%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/"},{"title":"Spring入门笔记1","text":"1. 程序耦合度/spring的作用/ioc的原理以前的程序存在两点不足： 诸如一些配置信息写在了类中，编译后改不了了，比如数据库的连接信息，如果是写在类中，以后想换数据库就只能动手改源码。解决办法就是通过读取xml或者properties的方式，编译后xml也还在，以后想修改数据库就可以只改变xml的内容。 创建对象的时候我们通过new的方式，比如在写service层的时候，我们需要new userDao()，这样子的话，如果没有先写好dao层，或者说两个人负责编写两个层等等，就必须等另一个人先写完，这样就不好。后来我们的解决办法是用工厂模式解耦，将new一个实例交给工厂类。这样确实解耦了，但是工厂类还是要改源码，最好的方式还是像xml一样需要的时候来读取。 这就是所谓的耦合度，在我看来， spring的ioc称为控制反转，就是解决了new的问题，将对象所在的类的路径写在xml中，需要用到对象的时候通过反射来创建对象，相当于编写了一个工厂类的作用。 spring的di称为依赖注入，就是通过xml的方式给函数中的元素赋值，解决了你不知道何时需要从工厂类中创建一个对象的问题，通过依赖注入来告知你想什么时候创建一个对象，需要用到的时候自动从ioc容器中获取而不是new。 借用网上的一张图 图片来源https://www.cnblogs.com/superjt/p/4311577.html，这篇博客对IOC的概念讲的很棒 2. 如何通过spring的ioc来创建对象从而代替new2.1 xml方式bean.xml service层 表现层（当然我们以后整合springmvc时不会在controller里面这么写，而是用spring-web包完成，那是后话了） 2.2 注解方式关于注解方式，只是方式不同，我们讲思想和概念的时候以xml的方式讲，第7部分统一讲注解方式。 3. ApplicationContext类3.1 ApplicationContext的三个常用实现类 ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了。(更常用) FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件(必须有访问权限） AnnotationConfigApplicationContext：它是用于读取注解创建容器的。 3.2 ApplicationContext（代表ioc）和BeanFactory（代表工厂）加载对象的区别（了解）了解一下即可 ApplicationContext：单例对象适用 采用此接口，它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。 BeanFactory：多例对象适用 它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。 这点我们可以通过一个accountService类的一个构造函数输出一句话来验证。 4. 创建Bean的三种方式4.1 使用默认构造函数创建也就是上面那样的 在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时 采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。 4.2 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）比如我们使用了工厂模式，又或者使用了别人的jar包，这时候发现某个类没有默认构造函数，只有带参构造函数或者构造函数交给了工厂类来创建。 这时候就要这样创建对象 4.3 使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)对于静态方法 那么需要这样使用 5. bean的作用范围和生命周期（了解）作用范围bean的作用范围调整 bean标签的scope属性： &nbsp;&nbsp;&nbsp;&nbsp;作用：用于指定bean的作用范围 &nbsp;&nbsp;&nbsp;&nbsp;取值： 常用的就是单例的和多例的 singleton：单例的（默认值） prototype：多例的 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session 似乎是制定了多例，就会像beanFactory一样在需要时才创建对象 生命周期 单例对象 ​ 出生：当容器创建时对象出生 ​ 活着：只要容器还在，对象一直活着 ​ 死亡：容器销毁，对象消亡 ​ 总结：单例对象的生命周期和容器相同 多例对象 ​ 出生：当我们使用对象时spring框架为我们创建 ​ 活着：对象只要是在使用过程中就一直活着。 ​ 死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收 6. 依赖注入Dependence Injection我们现在只是在视图层（servlet层）通过ioc创建了对象，可以打印出对象的地址，但是我们是要在service层调用dao的对象，也就是要告诉service层有了dao层的对象，总不能在service层去getBean吧，这样没有解耦还不如直接在service层new dao呢，那怎么办呢？这就是依赖注入的作用 简单的说，依赖注入就是通过xml的方式给函数中的元素赋值 比如我们要在servlet中创建service对象，那我们以前就会new service(name, age, birthday)，或者函数没有提供参数构造，只有默认构造，但是暴露了set方法（比如实体类），也是可以的new service() setName() setAge() setBirthday()。 依赖注入也是一样需要依靠这些方法，只是不需要主动调用而已，改为在xml中给参数注入值 6.1 能注入的数据类型：有三类 基本类型和String 其他bean类型（在配置文件中或者注解配置过的bean） 复杂类型/集合类型 三种类型的注入连同下面的注入方式一起讲，往下看 6.2 构造函数注入 6.3 set方法注入（更常用）6.3.1 基本类型和Bean类型的注入 6.3.2 复杂（集合类型）的注入 归为两大类 同一大类的可以互换，但不要这么做 7. 注解方式IOC和DI其实我们回顾xml方式，其实spring的ioc和di就帮我们完成了如下几件事。 &lt;bean&gt;标签实现了对象的创建（代替了new） &lt;property&gt;标签实现了数据的注入（代替了调用函数和实参） scope属性指定了bean的作用范围 init-method和destory-method指出了初始化函数和销毁函数（不重要） 因此我们用注解的方式也会实现这些操作 7.1 要使用注解，必须将bean.xml改成以下约束12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为 context名称空间和约束中--&gt; &lt;context:component-scan base-package=\"com.wjw\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 包名记得改 7.2 @Component作用：和&lt;bean&gt;标签一样，用于把当前类的对象存入spring容器中 写在类上，要new的类上 其中的value属性就是id，若不指定，默认值为首字母小写类名 由于只有一个属性，所以可以直接写@Component(“accountDao1”) getBean时的实参就是上面的id 7.2.1 @Controller：一般用在表现层7.2.2 @Service：一般用在业务层7.2.3 @Repository：一般用在持久层以上三个注解他们的作用和属性与Component一模一样。 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰。 7.3 @Autowired写在调用方的方法/变量上 Autowired为什么叫auto呢，因为他会自动注入，也就是说，如果只有一个dao实现类，那么这个注入会自动根据类型匹配到这个实现类，如下图： 自动按类型注入：是不管key，直接在value中找类型的 如果有两个dao实现类daoImpl1和daoImpl2，那么会先根据类型找出这两个dao，然后根据key（两个dao实现类的@Repository的id）找到对应的类 7.3.1 @Qualifier(value=”accountDaoImpl1”)：指定id也就是说，虽然我有两个dao实现类，但是我只用1个，如果我不想在变量名称里面写dao1 dao2，变量名我就想写accountDao，那就要通过这个@Autowired加上@Qualifier(value=”实现类ioc的id”) 另外，只有在Qualifier给变量注入时才需要和Autowired一起写，如果是作为方法参数时是可以单独使用的 7.3.2 @Resource(name=”accountDaoImpl1”)如果我不想写两个@，又想实现@Qualifier的功能怎么办，就用这个注解 注意：以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。 另外，集合类型的注入只能通过XML来实现。 7.3.3 @Value(value=${SpEL表达式})用于注入基本类型和String类型的数据 7.3 @Scope他们的作用就和在bean标签中使用scope属性实现的功能是一样的 写在类上（@Component下方），用于改变bean的作用范围 取值依然是singleton（默认） ​ prototype ​ … 7.4 @Predistroy和@PostConstruct他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的 写在方法上方，销毁和初始化 以下为完全不用XML的方式 7.5 @Configuration、@Bean、@ComponentScan(basePackages = “com.wjw”)我们发现，比如要在Service中注入dao则需要在serviceImpl中的定义dao语句上面加上@Autowired。但是有时候我们用的是jar包中的类，比如在queryRunner中传入连接池对象，这时候queryRunner和dataSource都不是我们自己写的类，那要如何注入和放进ioc容器呢？ 我们只能自己写一个类创建queryRunner对象并加入ioc容器中 同时，测试的时候applicationContext要改成注解AnnotationConfigApplicationContext类 这时候bean.xml可以不需要了 7.6 多个配置类和@Import其实只有一个配置类的时候@Configuration加不加都行（最好加），但是如果有多个配置类，则一定要加，多个配置类实现有三种方式： 指定多个类座位配置文件，但是这样两个配置类理解成“兄弟关系”，但其实是包含关系 配置类a中扫描配置类b的包名，同时配置类b也要有@Configuration @Import，在需要的一个配置类中导入另一个配置类，形成我们理解上的“从属关系” 7.7 @PropertySource、@Value 不要写死连接信息，也就是如何通过外部文件（.properties来获取信息，通过SpEL表达式） 如果properties文件在包下那么就classpath:packagename/xxx.properties classpath: 这是真实路径，文件编译后在target/classes目录下 做完这些一看，哦吼，还不如xml方式，所以最简单的方法是自己写的类用注解，jar包中的类用xml","link":"/Spring/Spring%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"title":"SpringCloud笔记","text":"1. 分布式概述回顾我们以前的项目，从大一到大三，架构慢慢的演变，从一开始堆在一起（乱成一团），到分成多个包，三层架构（水平拆分），到前后端分离成两个项目，后面后台部分分成多个模块小组开发（垂直拆分）等等 传统架构–&gt;水平拆分–&gt;垂直拆分（最早的分布式）–&gt;soa(dubbo)–&gt;微服务(springCloud) 接下来我们要接触到一些分布式，解决一些高并发情况 早期简单的分布式，就是启动多个相同的后台模块（比如启动多个用户管理模块，多个赛事管理模块）作为“服务”，然后前端发送请求时不是直接到服务，而是到一个分发中心模块，这个分发中心就平均分配请求到相同服务（这就是负载均衡），从而减轻其中一个服务的并发压力。 随着服务越来越多，目前主流的两个分布式服务架构：以dubbo为代表的采用RPC协议方式的SOA架构和以springcloud为代表的采用HTTP协议方式的微服务架构 RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。 现在热门的Rest风格，就可以通过http协议来实现。 1.1 流动计算架构（SOA）SOA ：面向服务的架构 代表就是dubbo（微服务和soa都是解决大量的服务的问题，界限其实并没有那么明显，soa也通常被视为微服务的一种方式，所以也有人说dubbo是微服务框架。另外由于采用了rpc协议，也有人说dubbo是rpc框架，我认为只是角度不同，都可以） 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 1.2 微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实却有一些差别： 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： 代表是springcloud，springcloud不是一个东西，是集成，把世界上最好的框架拿过来，多个组件集成到自己的项目中（官网的说法叫做分布式解决方案，多好听），有下面这几个组件，集成后实现了：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。 Eureka：服务治理组件，包含服务注册中心，服务注册与发现机制的实现。（服务治理，服务注册/发现） Zuul：网关组件，提供智能路由，访问过滤功能 Ribbon：客户端负载均衡的服务调用组件（客户端负载） Feign：服务调用，给予Ribbon和Hystrix的声明式服务调用组件 （声明式服务调用） Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。(熔断、断路器，容错) 1.3 选择如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。 相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选。这里介绍SpringCloud套件，因此我们会使用Http方式来实现服务间调用。 2. 准备工作用一个小例子来说明，咱们先做点准备工作 先用spring initializr创建一个springboot工程，作为服务提供者，也就是接触分布式之前的所谓“后台”，就不多做说明了。 再创建一个模块作为服务消费者（也用spring initializr，但是只需要web，也就是mvc部分，不需要mysql,jdbc,mybatis那些），也就是上面说的分发中心，前端发送的http请求先到这个分发中心，分发中心经过负载均衡（后面会讲到负载均衡）再主动发送http请求给各个服务提供者。 这个我也不多说了，直接建立就好 消费者的引导类注入RestTemplate 12345678910111213@SpringBootApplicationpublic class FangspcloudServiceConsumerApplication { @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(FangspcloudServiceConsumerApplication.class, args); }} 那么这个消费者的controller很简单，只需要主动发送http请求到提供者（也就是以前的controller）的服务接口就行 启动，访问的时候就是访问消费者的接口 好，那么准备工作就做好了，其实到这一步，我们的工作和以前并无二异，只是 以前：浏览器请求–&gt;后台 现在：浏览器请求–&gt;后台1–&gt;后台2 我们起这么个名字，方便讲解：浏览器请求–&gt;服务消费者–&gt;服务提供者 我们说过了，模块化会有很多个服务提供者（这个我们之前小组开发做过了，模块化开发比如用户模块和赛事模块对吧），分布式呢，还会出现很多个相同的提供者，比如多个用户模块（比如多台服务器，就可以减轻压力），这个也简单，只要改个端口号然后在idea的配置中复制一份多次启动就可以了 这就是分布式的前提。 3. Eureka3.1 eureka概述Eureka就是服务注册中心（可以是一个集群），对外暴露自己的地址，有三个角色 服务注册中心：Eureka的服务端应用，提供服务注册和发现功能 服务提供者：提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。启动后向Eureka注册自己信息（地址，提供什么服务） 服务消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，消费者从而得知每个服务方的信息，知道去哪里调用服务方。并且定期更新 还有个概念：心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 对于上面的工程，思考一个问题，我们服务提供者越来越多（相同的或者不同的），你有没有办法去管理？？？没有吧，eureka就是解决这个问题，不管是消费者还是提供者，统统都给我注册eureka，这样我就可以统一管理了 3.2 eureka使用步骤 为eureka搭建一个模块（服务注册中心），仍然用spring提供的初始化工具，不过这次勾选rureka Server 结构如下 确认依赖，一般都是没问题的 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR4&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; yml 1234567891011server: port: 10086spring: application: name: wjw-eureka # 作为微服务名称注入到eureka容器eureka: client: service-url: # EurekaServer地址,多个地址可以','隔开 defaultZone: http://localhost:${server.port}/eureka# register-with-eureka: false # 如果报错就先放开这两个注释跑一遍再注释掉# fetch-registry: false 引导类 123456789@SpringBootApplication@EnableEurekaServer //启用eureka服务端public class WjwEurekaApplication { public static void main(String[] args) { SpringApplication.run(WjwEurekaApplication.class, args); }} 给之前的服务提供者和消费者注册eureka客户端 要修改的地方如下： 提供者和消费者都要增加依赖 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR4&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 提供者增加后的yml 12345678910111213141516server: port: 8081spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///springboot username: root password: 0751@@@wjw application: name: service-provider # 应用名称，注册到eureka后的服务名称mybatis: type-aliases-package: com.wjw.service.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka 消费者增加后的yml 123456789server: port: 80spring: application: name: service-consumereureka: client: service-url: defaultZone: http://localhost:10086/eureka 提供者和消费者引导类都要加上注解 这样就配置好啦，依次启动eureka服务端和服务提供者消费者，然后可以访问http://localhost:10086看eureka的管理台了 这样就可以统一用eureka管理已注册的服务了 3.3 其他 之前消费者的controller是直接发动到提供者1的接口，但是我们都知道，后期要分发到多个提供者（负载均衡），这要有个前提：java端可以读取一些eureka的情况，理所当然！比如下面这段 123456789101112131415161718192021222324@Controller@RequestMapping(\"consumer/user\")public class UserController { @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; // eureka客户端，可以获取到eureka中服务的信息 @GetMapping @ResponseBody public User queryUserById(@RequestParam(\"id\") Long id){ // 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(\"service-provider\"); // 因为只有一个Service-provider。所以获取第一个实例 ServiceInstance instance = instances.get(0); // 获取ip和端口信息，拼接成服务地址 String baseUrl = \"http://\" + instance.getHost() + \":\" + instance.getPort() + \"/user/\" + id; User user = this.restTemplate.getForObject(baseUrl, User.class); return user; }} 这里可以看到 我们动态获取了当前注册的所有提供者，并手动分发到instance.get(0)也就是第一台服务器，这时候有人就有想法了！！咱可以做负载均衡了，将多个请求分发到不同的提供者！！是的，别急，这些不用自己写的，ribbon帮我们写好了，学起来。 这里还有一个要了解的就是概述中说的心跳（续约），了解一下即可 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 4. Ribbon4.1 ribbon概述前面说了ribbon可以帮助我们自动完成消息平均分发，是的就这么简单。要看复杂的概念也有，如下 4.2 ribbon使用步骤ribbon是在消费者中使用 不需要引入依赖，因为ribbon通常不会单独使用，所以在引入eureka的时候自动就引入了ribbon 前面说了我们可以对同一个服务提供者修改一下端口号然后再次启动，这样就有了多个提供者，且服务名一样，只是端口号不一样，可能说的不够细，咱们再细一点，配图 服务消费者的引导类中，对restTemplate方法使用@LoadBalanced注解开启负载均衡 4.消费者的restTemplate.getForObject方法里面通过 服务名 调用提供者的接口，因为此时有多个服务名相同的服务，所以就可以自动负载均衡啦！！！！ 测试 可以复制这段测试用例 123456789101112131415@SpringBootTest@RunWith(SpringRunner.class)public class RibbonLoadBalanceTest { @Autowired private RibbonLoadBalancerClient client; @Test public void test(){ for (int i = 0; i &lt; 50; i++) { ServiceInstance instance = this.client.choose(\"service-provider\"); System.out.println(instance.getHost() + \":\" + instance.getPort()); } }} RibbonLoadBalanceClient有一个choose方法，可以获取负载均衡得到的实例 可以看到ribbon默认使用了轮询的方式 4.3 源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 在如下代码打断点： 一路源码跟踪：RestTemplate.getForObject –&gt; RestTemplate.execute –&gt; RestTemplate.doExecute： 点击进入AbstractClientHttpRequest.execute –&gt; AbstractBufferingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.execute: 继续跟入：LoadBalancerInterceptor.intercept方法 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： 这就是负载均衡读取到不同端口的大致过程 上面提到了负载均衡器和负载均衡算法，也就是默认的是轮询方式。如果我们想自定义负载均衡策略，可以继续深入可以图中负载均衡算法那个类ILoadBalancer，可以看到是一个接口，继承了BaseLoadBalancer 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： 通过上面源码的分析，我们也可以试图猜测一下默认轮询的工作方式，记录一个count，消费方每次count++，然后%n个提供方，为几就分配到第几个提供方。当然源码内部非常复杂且实现时要考虑很多因素没有这么简单，不过错了也没关系，咱们就看过的这几段大胆的猜测就行。 4.4 修改负载均衡策略上面那张图已经看到了内置的负载均衡策略，使用时可以替换默认的，只需更改yml文件就可以 123service-provider: # 服务提供方的服务名 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule service-provider顶格写，这里不会有提示，甚至提示没有这项配置，没关系，大胆写，这时候再跑测试用例，可以看到是随机的了 ribbon做了处理，无论是哪种方式，分配给各个提供方的数量大体上是一样的 5. Hystrix5.1 hystrix概述熔断，是一种保护机制，Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路，如果其中一个环节出现错误，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。 Hystix解决雪崩问题的手段有两个： 线程隔离 服务熔断 5.1.1 线程隔离，服务降级Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果线程池已满，或者请求超时，则会进行降级处理（优先保证核心服务，而非核心服务不可用或弱可用） 故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。至少可以看到一个执行结果（例如返回友好的提示信息） 5.1.2 服务熔断熔断就是大量请求都超时情况下（比如某个模块出问题了），主动熔断，防止整个系统直接裂开。Hystrix的熔断可以自动恢复，但并不是马上恢复，而是用小批量的请求测试服务器是否恢复。 熔断状态机3个状态： Closed：关闭状态，所有请求都正常访问。 Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。 Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时 要注意不要搞混了，Closed才是可用，Open说明出问题了，这里理解成电路就行，闭合（Closed），断开(Open) 5.2 hystrix使用步骤hystrix用在消费者而不是提供者，因为消费者是调用方 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; yml 这个呢，由于生产环境中访问远程服务器要慢一点的，默认1s就熔断未免太过苛刻，开发环境下访问本地服务器倒是无所谓，要记得设置啊 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms 引导类加注解@EnableCircuitBreaker controller方法上方添加注解，自定义熔断方法，修改了返回值为String方便测试 测试，我们可以把提供者关掉来模拟服务器出现问题 访问，我们可以看到错误提示 这就是我们有时浏览网页的报错提示（不是那种返回500时指定的，这种通常是并发量巨大，比如广东海洋大学的抢课系统！！那种） 也可以在类上方添加全局熔断方法@DefaultProperties(defaultFallback = “全局熔断方法名”) 这个不多说了，看看就懂了，要注意的是方法上还是要加@HystrixCommand注解的，只是不指定的话默认使用全局的熔断函数，而且全局熔断方法的参数要为空，返回值要和被熔断方法一致（不是String的话自己写序列化就行，一般都是json字符串的，问题不大） 5.3熔断机制测试咱们主动抛出异常 在服务中心，提供者和消费者都正常的情况下，我们快速的访问http://localhost/consumer/user?id=1至少20次，触发了熔断机制，于是访问id=2时也会提示服务器正忙 5s后，再次访问id=2，恢复正常 6. Feign6.1 feign概述先看我们原来的http请求，他完成了消费者到提供者的消息传递 return restTemplate.getForObject(&quot;http://service-provider/user/&quot; + id, String.class); 你看原来这段字符串拼接，是不是很low！！？？ Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 6.2 feign使用步骤feign是在引导类中使用 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 引导类注解@EnableFeignClients，且不再需要RestTemplate发送http请求 定义一个接口，接口上方的@FeignClient(“service-provider”)是服务提供者的服务名，方法对应提供者的controller接口方法（复制过来去掉方法体） 要注意提供者类上方还有一个@RequestMapping(“user”)，这里不要也写成全局，而是在每一个方法的路径中定义 controller改动也是比较大的，首先就是Feign继承了Ribbon和Hystrix，所以我们不需要按照以前的方式写callback函数了，可以看到跟以前的controller差不多了（@Controller+String类型也是可以的，返回值多加了个.toString()而已），比较优雅 1234567891011121314@RestController@RequestMapping(\"consumer/user\")public class UserController { @Autowired private UserClient userClient; @RequestMapping @ResponseBody @HystrixCommand public User queryUsrById(@RequestParam(\"id\")Long id){ return this.userClient.queryUserById(id); }} 6.3 添加Hystrix支持原来的hystrix去掉了，Feign中集成了hystrix，但默认是关闭的，需要在yml中开启 yml 123feign: hystrix: enabled: true # 开启Feign的熔断功能 新建一个类，实现UserClient接口，并加入spring容器 12345678910@Componentpublic class UserClientFallback implements UserClient { @Override public User queryUserById(Long id) { User user = new User(); user.setUserName(\"服务器正忙，请稍后再试\"); return user; }} 接口加上fallback类 要注意由于不是只有一个参数了，所以前面的value=要加上了 关掉提供者后测试结果如下 可以看到实现了熔断机制 6.4 添加ribbon支持是的，集成后默认开启，无需配置！ 7. Zuul7.1 zuul概述不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 7.2 zuul使用步骤 使用初始化工具创建模块，zuul组件在spring cloud routing下 目录和前面的eureka那些同级就行 没有特殊要求 yml 12345678910server: port: 10010spring: application: name: wjw-zuulzuul: routes: service-consumer: # 路由名称，可以随便写，习惯上是服务名 path: /service-consumer/** url: http://localhost:80 引导类上方加上@EnableZuulProxy注解 这时候我们访问http://localhost:10010/service-consumer/consumer/user?id=1和访问http://localhost:80/consumer/user?id=1结果是一样的 也就是说localhost:10010/service-consumer会重定向到localhost:80 7.3 搭配eureka食用yml中写死路径就很low，我们从eureka动态的获取服务列表 为zuul模块添加eureka还是那三大步骤 为zuul模块添加eureka依赖（别弄错了呀，要是这个starter的） 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; zuul模块的yml增加 1234eureka: client: service-url: defaultZone: http://localhost:10086/eureka 引导类 yml改成服务名 启动 简洁写法当我们想让服务名和路径不一致时可以用上面的写法，也可以像下面这样简写，那么路径名默认就是服务名通常用这种 123zuul: routes: service-consumer: /service-consumer/** 最简洁写法不写！ 是的，依然可以通过服务名访问，并且所有服务都默认可以通过zuul端口+服务名访问 7.4 官方推荐api前缀官方推荐加上前缀api，看看我们最终的yml 12345zuul: routes: service-provider: /user/** service-consumer: /consumer/** prefix: /api 这样浏览器访问时需要在端口后加上api，以后有api的就说明是通过zuul的了 因为配了映射名，我们也可以通过映射名访问 可以看到有两次user，第一次是yml中的映射，第二次才是provider中的controller类上方的@RequestMapping(“user”)全局路径，这也就是为什么很多人controller不带全局路径的原因，他们更习惯用zuul来完成每个模块的全局路径 7.5 zuul过滤器和传统过滤器差不多，继承ZuulFilter然后复写run方法处理过滤操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Componentpublic class LoginFilter extends ZuulFilter { /** * 过滤器类型：pre route error post */ @Override public String filterType() { return \"pre\"; } /** * 执行顺序，返回值越小，优先级越高 */ @Override public int filterOrder() { return 10; //随便写，写10是怕有小于10的 } /** * 是否执行run方法 */ @Override public boolean shouldFilter() { return true; } /** * 编写过滤器的业务逻辑 */ @Override public Object run() throws ZuulException { //初始化zuul的context上下文对象 RequestContext context = RequestContext.getCurrentContext(); //1.获取request然后获取参数 HttpServletRequest request = context.getRequest(); String token = request.getParameter(\"token\"); if (StringUtils.isBlank(token)){ //拦截，不转发请求 context.setSendZuulResponse(false); //响应状态码，401身份未验证 context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED); //设置相应过滤器 context.setResponseBody(\"request error!\"); } //返回值为null代表什么都不做 return null; }} 比如我们这里run方法是判断请求中是否带有参数token 正常流程： 请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。 7.6 添加Hystrix和ribbon支持默认是支持的，修改一下超时时间就好了 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 # 设置hystrix的超时时间为6000ms 附录1. @SpringCloudApplication注解引导类上的注解越来越多 在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解@SpringCloudApplication 所以在引导类上写这个注解就可以了！","link":"/SpringCloud/SpringCloud%E7%AC%94%E8%AE%B0/"},{"title":"ThreadLocal","text":"作用 多个线程之间的数据隔离 单个线程内部的简化参数（传递上下文） 使用使用可太简单了，一个set 一个get 123ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();threadLocal.set(\"张三\");String name = threadLocal.get(); 原理说明set和get究竟是怎么回事set方法 12345678public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);} get方法 12345678910111213public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue();} 由前两行可以看到根据每个currentThread获取了map，因此不同的线程获取的map自然就不同，每个线程只能操控自己的map，而对于同一个线程，不管在哪里获取的map都是同一个。 而对于每个map，key为ThreadLocal这个类，value为我们set的值 当然这只是分析，我们可以进一步看getMap源码验证上图 先看getMap方法体： 123ThreadLocalMap getMap(Thread t) { return t.threadLocals;} 直接返回了Thread类的一个属性成员 12345678910111213public class Thread implements Runnable { /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; ... 到这里就可以完全说明不同的线程获取的map自然就不同，每个线程有自己的map了 map真的是map吗再看看这个map，他叫ThreadLocalMap，跟hashmap一样吗？ 部分源码如下： 123456789101112131415161718192021222324252627static class ThreadLocalMap { /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; ... 对比hashmap分析，我贴上Hashmap的部分源码 123456789101112131415public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; ... } transient Node&lt;K,V&gt;[] table; ... 我们都知道hashmap在树化之前是数组+链表，首先是Entry[] table，类似于hashmap“数组+链表”中的数组Node&lt;K,V&gt;[] table 那链表呢？答案是没有。从上面可以看出，hashmap的有指针域Node&lt;K,V&gt; next;，但是ThreadLocalMap的Entry是一个弱引用 综上所述，ThreadLocalMap其实并没有实现Map接口，只是一个Entry数组 ThreadLocalMap如何解决hash冲突既然我们知道了ThreadLocalMap只是一个Entry数组，如果定义了多个ThreadLocal 12ThreadLocal&lt;String&gt; threadLocal1 = new ThreadLocal&lt;&gt;();ThreadLocal&lt;Integer&gt; threadLocal2 = new ThreadLocal&lt;&gt;(); 存东西的时候遇到hash冲突怎么解决呢，先说结论：hashmap遇到hash冲突后会跟在此下标对应的链表后面，而ThreadLocalMap没有链表，遇到hash冲突后计算下一个下标，直到数组在某个下标处没有值 1234567891011121314151617181920212223242526272829303132private void set(ThreadLocal&lt;?&gt; key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); //1.这样计算hash值 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { //4.entry不为空且key不相等，说明hash冲突，一直找下一个位置 ThreadLocal&lt;?&gt; k = e.get(); if (k == key) { //2.key相等，覆盖旧值 e.value = value; return; } if (k == null) { //3.当前位置是空的，就初始化⼀个Entry对象放在位置i上； replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();}//nextIndex也贴出来，真的是下一个位置！！private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0);} get时候也是一样：计算hash下标–&gt;判断key是否相等–&gt;相等直接返回，不相等看下一个位置–&gt;继续判断是否相等… 内存泄漏问题key使用了弱引用，不存在内存泄漏问题，但是value存在 先看结构 当我们ThreadLocal tl = new ThreadLocal();的时候，实际上有两个引用指向了ThreadLocal，一个是tl本身是一个强引用，一个是getMap(当前线程)得到的ThreadLocalMap，它里面的Entry的key是一个弱引用，指向了ThreadLocal。 为什么这里要使用弱引用呢？ 如果是强引用，则tl和key都是强引用，我们一般都是操作tl，也就是tl = null，但是key依然存在强引用，于是导致无法被gc回收，存在内存泄漏问题。 使用弱引用就不会内存泄漏？ 不是的，即使key是弱引用，但是如果key被回收变为null，value无法被访问，依然存在内存泄漏问题。解决的办法是主动调用tl.remove(); 对于Entry，key是弱引用，在gc时会被回收，但是value得等到该ThreadLocal/线程没有强引用时才会收，如果线程一直存在，比如线程池会复用线程，那么此时value就一直无法回收，造成内存泄露问题。 解决方法也很简单，养成好习惯，主动调用remove()方法 1234567ThreadLocal&lt;String&gt; localName = new ThreadLocal();try { localName.set(\"张三\"); ……} finally { localName.remove();} 线程之间传递Java中的对象都是在堆中的，是线程共享的，ThreadLocal也一样，只是通过一些手段来实现线程之间的隔离，如果要实现父子线程之间的数据共享，可以使用InheritableThreadLocal 其原理是判断父组件是否有InheritableThreadLocal，有就直接赋值给子线程 1234//Thread的init方法中if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); 常见场景Spring的事务控制最著名的肯定是Spring的事务控制了，操作数据库最终都是dao层的JDBC，那么就需要Connection连接对象，原则上来说增删改查操作都由Connection操作。本来也没什么，但是Spring为了把事务都控制在service业务层（虽然这些什么什么层本质一样，是自己抽象出来的概念），做了两件事： 为了保证原子性：保证单个线程中的数据库操作使用的是同⼀个数据库连接，而且为了让开发者不需要将同一个Connection对象作为参数在dao的函数里传来传去，使用时感知不到Connection对象，于是使用了ThreadLocal+AOP的方式，保证了 为了保证隔离性：使用ThreadLocal，各个线程之间的事务互不影响 贴一个自己使用的场景：存放登录信息 参考 三太子敖丙ThreadLocal bilibili马士兵弱引用","link":"/Java%E5%9F%BA%E7%A1%80/ThreadLocal/"},{"title":"Spring入门笔记2","text":"1. Spring整合junit注意：spring5.x必须对应junit4.12及以上版本，否则报init初始化错误 就是为了避免重复代码 其实可以用junit的注解@Before去做的，但是公司开发的时候开发工程师和测试工程师时两个人，测试工程师只关注service.findAll()这个接口，对于上面红色框框出的代码，可能测试工程师不懂spring，所以必须由开发工程师写，但是开发又不写@before代码块，只写这个空测试类 所以可以通过注解/xml的方式在空类上面创建ioc容器 导坐标 测试类上方加注解 @RunWith(SpringJUnit4ClassRunner.class) 告知spring的运行器用的是注解还是xml @ContextConfiguration 两个属性：locations：指定xml的位置，记得加上classpath: classes：指定注解类所在位置 注入 2. Spring中的AOP2.1 AOP的概念以及作用（了解，代码看看就行）AOP的本质是动态代理，就是方法增强，比如原来有一个方法funA()，里面输出了一句”world”，现在通过AOP/动态代理等方式对funA()进行改造，使得可以在执行funA之前先输出一句”hello”，在执行funA之后输出”!!!!”，这就是方法增强。 为什么要这么做呢？在实际开发中体现为：我们在业务层编写的时候只需要关注业务逻辑，而不用对每个方法都 开启事务 业务逻辑 提交事务(正常) 回滚事务(异常) 释放连接 如果每个方法都要这样写就太麻烦了，因此我们通过aop来实现对业务层的方法增强，之后事务管理器负责： 开启事务 提交事务(正常) 回滚事务(异常) 释放连接 而这样依赖业务层只有： 业务逻辑 使用AOP/动态代理后 而事务的管理交给代理类（这里先用动态代理介绍方法增强，AOP原理相同，随便看一下代码，后期我们使用spring的事务管理器，就不用自己写代码了） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 用于创建Service的代理对象的工厂 */public class BeanFactory { private AccountService accountService; public final void setAccountService(AccountService accountService) { this.accountService = accountService; } private TransactionManager txManager; public void setTxManager(TransactionManager txManager) { this.txManager = txManager; } public AccountService getAccountService() { return (AccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() { /** * 添加事务的支持 * @param proxy * @param method * @param args * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object returnValue = null; try { //1.开启事务 txManager.beginTransaction(); //2.执行事务 returnValue = method.invoke(accountService, args); //3.提交事务 txManager.commit(); //4.返回结果 return returnValue; } catch (Exception e) { //5.回滚操作 txManager.rollback(); throw new RuntimeException(e); } finally { //6.释放连接 txManager.release(); } } }); }} 至于里面的txManager我们用的是自己写的事务管理器（随便看一下代码，后期我们使用spring的事务管理器，就不用自己写代码了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 和事务管理相关的工具类:开启事务。提交事务，回滚事务和释放连接 */public class TransactionManager { private ConnectionUtils connectionUtils; public void setConnectionUtils(ConnectionUtils connectionUtils) { this.connectionUtils = connectionUtils; } /** * 开启事务 */ public void beginTransaction(){ try { connectionUtils.getThreadConnection().setAutoCommit(false); }catch (Exception e){ e.printStackTrace(); } } /** * 提交事务 */ public void commit(){ try { connectionUtils.getThreadConnection().commit(); }catch (Exception e){ e.printStackTrace(); } } /** * 回滚事务 */ public void rollback(){ try { connectionUtils.getThreadConnection().rollback(); }catch (Exception e){ e.printStackTrace(); } } /** * 释放连接 */ public void release(){ try { connectionUtils.getThreadConnection().close(); //还回连接池中 connectionUtils.removeConnection(); }catch (Exception e){ e.printStackTrace(); } }} 同时，为了解决事务和线程没有绑定，导致有异常不能回滚的现象，我们还编写了一个事务和线程绑定的类（随便看看就行，后期我们用spring自带的事务管理器，避免了这个问题） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * 在两次dao.update之间抛出或者主动写一个错误如(int i = 1 / 0;) * 则第一个update提交了，第二个没有，导致一个账户钱减少了另一个账户前却没有增加。这不是我们想要的效果，我们想让前面的操作事务回滚。 * 并不是传统意义上的事务回滚，事务回滚指的是update方法内部错误，回到没有update之前的状态。 * 这里指的是包括前面3次事务已经提交并且成功，后面的事务连提交都没有。 * 所以错不在事务，而在连接。 * 并不是没有事务（没有事务的话save,find方法也不能提交），原因是因为dao方法获取了4次连接，每个connection都有自己的事务。 *//** * 在service中将connection和线程绑定，从而使一个线程中只有一个能控制事务的connection对象，要么一起发生，要么都不发生。 * 事务的控制应该是在业务层而不是在持久层 * @author wjw */public class ConnectionUtils { private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;(); private DataSource dataSource; public void setDataSource(DataSource dataSource) { this.dataSource = dataSource; } public Connection getThreadConnection(){ try { //1.先从ThreadLocal上获取 Connection conn = tl.get(); //2.判断当前线程上是否有连接 if (conn == null) { //3.从数据源中获取一个连接，并且存入ThreadLocal中 conn = dataSource.getConnection(); tl.set(conn); } //返回当前线程上的连接 return conn; }catch (Exception e){ throw new RuntimeException(e); } } /** * 把连接和线程解绑 */ public void removeConnection(){ tl.remove(); }} 2.1.1 动态代理的写法（了解，小插曲）有人说，哎呀 我不会写动态代理，这又是匿名内部类的又是什么Proxy 我说你会你就会，你认真看啊 其实要记的就只有 你得知道动态代理是什么类下的什么方法吧：Proxy.newProxyInstance() 参数列表其实是不用记的，你敲下1就会有提示，按类型填就行了，比如他会告诉你第一个参数是类加载器，你只需要记住填的是“要增强的方法的类”的类加载器，就不会错，第二个也是，你只要记住是“要增强的方法的类”原本实现的接口就行 new InvocationHandler()，这个是要记住的，你敲下前几个字母就会自动补全下面的invoke方法了 至于里面的方法，我们方法增强是为了事务管理，所以里面才写事务的相关代码，如果方法增强是为了别的，那就视情况而定呀，不是固定代码，要注意的只有method.invoke()返回值是个Object的returnValue对象 关于动态代理的内容，在此不做过多的展开（单独做了动态代理笔记），只是为了说明方法增强是怎么回事，如何解决事务等方法重复代码的问题，以及了解AOP其实本质就是动态代理，实现了方法增强。 2.2 spring中基于xml的AOP配置步骤 把通知Bean也交给spring来管理 使用aop:config标签表明开始AOP配置 使用aop:aspect标签表明配置切面 id：是给切面提供一个标识 ref：指定通知类bean的id 在aop:aspect标签内部使用对应标签来配置通知的类型 我们现在的示例是想在切入点方法执行前执行printLog，所以是前置通知 aop:before：表示配置前置通知 method属性：指定Logger类中哪个方法是前置通知 pointcut属性：指定切入点的表达式，指的是对业务层中哪些方法增强 2.3 切入点表达式的写法：关键字：execution(表达式) 表达式：访问修饰符 返回值 包名.包名.包名…类名.方法名(参数列表) 标准写法：public void com.wjw.service.impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略：void com.wjw.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符*表示任意返回值：* com.wjw.service.impl.AccountServiceImpl.saveAccount() 包名可以用通配符表示任意包，但是有几级包（从com开始计算），就有多少个*.：* *.*.*.*.AccountServiceImpl.saveAccount() 或者可以使用*..表示当前包及其子包：* *..AccountServiceImpl.saveAccount() 类名和方法名都可以用*来实现通配：* *..*.*() 参数列表可以直接写数据类型： &emsp;基本类型直接写名称：* *..*.*(int) &emsp;引用类型写包名.类名：* *..*.*(java.lang.String) &emsp;&emsp;可以实现通配： &emsp;&emsp;&emsp;可以用*实现通配，代表有参数且任意类型：* *..*.*(*) &emsp;&emsp;&emsp;可以用..实现通配，有无参数都可以且可以任意类型：* *..*.*(..) 全通配写法：* *..*.*(..) 实际开发中常用切入点表达式写法都是切入到业务层下的所有方法：* com.wjw.service.impl.*.*(..) 2.4 通知类型&lt;aop:before&gt;前置通知，在切入点方法执行前执行 &lt;aop:after-returning&gt;后置通知，在切入点正常执行后执行 &lt;aop:after-throwing&gt;异常通知，在切入点方法执行异常后执行（相当于catch） &lt;aop:after&gt;最终通知，无论是否正常都会执行（相当于finally） &lt;aop:around&gt;环绕通知，其实环绕通知就是上面所有通知的总和，在环绕通知中，代码写在哪里就是什么通知。Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。该接口可以作为环绕通知的方法参数 简单地说，spring的环绕通知就是我们可以用代码的方式写所有的通知，位置就是不同的方式。（其实就是动态代理本来的写法） 2.5 简化重复pointcut，可以单独抽取出来&lt;aop:pointcut&gt;标签 id是唯一标识，expression就是原来的表达式 原来表达式不再用pointcut而是用point-ref，值就是&lt;aop:pointcut&gt;的id 也可以将&lt;aop:pointcut&gt;标签配置在&lt;aop:aspect&gt;外面，这样所有切面可用，注意：一定要在aspect前面 3. 注解方式AOP要使用注解AOP，必须如下配置要注意，这段约束在官网是没有现成的，先搜xmlns:aop的约束复制下来，再找xmlns:context找到红框中的三段复制下来 &lt;aop:aspectj-autoproxy&gt;是开启注解AOP的钥匙 切面类有这几点 3.1 @Aspect类上方添加，表明这是一个切面 3.2 @Pointcut和&lt;aop:pointcut&gt;一样，代表一个表达式，注意写法是通过空函数的形式 123@ Pointcut(“execution(“* com.wjw.service.impl.*.*(..)”)”)public void pt1(){} 3.3 @Before(“methodName()”)注意不要少了括号，前置通知 3.4 @AfterRuturning(“methodName()”)注意不要少了括号，后置通知 3.5 @AfterThrowing(“methodName()”)注意不要少了括号，异常通知 3.6 @After(“methodName()”)注意不要少了括号，最终通知 注意事项：spring的注解方式AOP的通知顺序是：前置 最终 后置/异常 最终通知的位置不对 而使用环绕通知的话，因为是自己写的，所以位置和xml还有理解中的是一致的 完全不用XML的方式12345@Configuration@ComponentScan(basePackages=\"com.itheima\")@EnableAspectJAutoProxypublic class SpringConfiguration {} 就是在“完全不用XML方式实现ioc”的那个配置类上方再加上@EnableAspectJAutoProxy 4. Spring自带的事务管理器：声明式事务控制还记得之前“九.1”那个案例吗(翻回去看)，我们现在使用AOP代替了动态代理，同样解决了事务重复代码的问题，对事务控制可以抽取出来了 可是，之前案例中的两个类是自己写的： TransactionManager：事务控制的类（包含提交，回滚等方法），自己写太不现实，我们现在要改用Spring自带的事务管理器。 ConnectionUtils：这是之前为了防止异常无法回滚的问题而写的类，现在我们通过Spring自带的事务管理器，可以避免这个问题。 4.1 基于XML的声明式事务控制使用步骤： 12345678910111213141516spring中基于xml的声明式事务控制基本步骤 1.配置事务管理器 2.配置事务通知 导入事务的约束，在data access里xmlns:tx，注意这里其实是包含了aop的，事务通知离不开aop 使用tx:advice标签配置事务通知 id：唯一标识 transactionManager：给事务通知提供一个事务管理器引用，注意不是ref 3.配置AOP中的通用切入点表达式 4.建立事务通知和切入点表达式的对应关系 5.配置事务的属性，在事务的通知tx:advice内部 isolation：用于指定事务的隔离级别，默认值是DEFAULT,表示使用数据库默认级别 propagation：用于指定事务的传播行为，默认值是REQUIRED，表示一定会有事务（增删改），查询方法用SUPPORTS read-only：用于指定事务是否只读，只有查询方法才能设置为true，默认为false表示读写 rollback-for：用于指定一个异常，当该异常产生时事务回滚，产生其他异常时事务不回滚，没有默认值 表示任何异常都回滚 no-rollback-for：用于指定一个异常，当该异常产生时事务不回滚，产生其他异常时事务回滚，没有默认值 表示任何异常都回滚 timeout：用于指定事务超时时间，默认为-1表示永不超时，秒为单位 也就是说，对于前置通知是事务的开启，后置通知是事务的提交，异常通知是事务的回滚，最终通知是连接的释放这种基本上是固定操作 spring封装了一个DataSourceTransactionManager自动完成，只要是在2中的transaction-manager中引用了这个类，那么就不必关注这几个操作了 更多的是关注不同方法对于事务的处理（事务的属性）比如在上一个事务未完成前下一个事务是否可以读取（find就可以其他操作则不行） 数据源还是原来的，也给出截图 4.2 基于注解的声明式事务控制使用步骤 1234spring中基于注解的声明式事务控制基本步骤1.配置事务管理器2.开启spring对注解事务的支持3.在需要事务支持的地方使用@Transactional注解(service层实现类上方) 惊喜的发现，由于spring的事务控制是写好的，所以连aop那些@Aspect啊@Before啊都不用了，spring知道执行之后commit，在异常之后AfterThrowing，只要@Transactional后所有方法都自动添加了事务 别忘了这些细节的东西 所以只能自己补上（@AutoWired可以不要，用的是xml） 4.3 纯注解的声明式事务控制算了，别整这些有的没的，反正也没人用 附录：ioc下通过继承JdbcDaoSupport如何注入数据源 这是由于类中使用的是继承方式 事实上就自动获得了所有父类的方法，而父类的class文件里我们可以看到setDataSource方法，因此我们只要根据这个set方法设置dao的注入就好了","link":"/Spring/Spring%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/"},{"title":"fastDFS的安装和springboot完成文件上传","text":"1. 安装fastDFS 安装libevent ubuntu下 1sudo apt-get install libevent-dev centos下 1yum -y install libevent 如果没有gcc（gcc -v没有打印版本）那么要安装gcc 12sudo apt install gccsudo apt install build-essential centos使用yum install 如果没有unzip要安装unzip ubuntu下 1sudo apt install unzip centos下 1yum install -y unzip zip 安装libfastcommon-master 1234unzip libfastcommon-master.zipcd libfastcommon-master./make.sh ./make.sh install 回到压缩包的目录，开始安装fastdfs 1234tar -zxvf FastDFS_v5.08.tar.gzcd FastDFS./make.sh ./make.sh install 检验是否安装成功 输入下面命令有fdfs_trackerd和fdfs_storaged两条记录显示就成功 1ll /etc/init.d/ | grep fdfs 查看是否有3个模板 1ll /etc/fdfs/ tarcker.conf.sample 是tracker的配置文件模板 storage.conf.sample 是storage的配置文件模板 client.conf.sample 是客户端的配置文件模板 配置并启动 先看tracker，storage同理 12cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.confvim /etc/fdfs/tracker.conf 修改base_path为你想要存放的路径（我这里是/home/wjw/fastdfs/tracker） 1base_path=/home/wjw/fastdfs/tracker 自己建立好这个文件夹 storage同理 12cp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.confvim /etc/fdfs/storage.conf 修改的内容如下 12345base_path=/home/wjw/fastdfs/storage # 数据和日志文件存储根目录 store_path0=/home/wjw/fastdfs/storage # 第一个存储目录 tracker_server=192.168.72.128:22122 # tracker服务器IP和端口 自己建立好这个文件夹 开启服务 ubuntu 12fdfs_trackerd /etc/fdfs/tracker.conf startfdfs_storaged /etc/fdfs/storage.conf start centos 12service fdfs_trackerd startservice fdfs_storaged start 如果开启服务报错可以试试先关闭防火墙再开启服务 ubuntu 1sudo ufw disable centos 1chkconfig iptables off 检查是否启动成功： 1ps -ef | grep fdfs 设置服务开机自启动: ubuntu比较复杂，尤其是对于安装了图形桌面版，一登陆默认是非root 下面给出最标准的解决方案 1vi /lib/systemd/system/rc.local.service 修改结果如下 1234567891011121314151617[Unit]Description=/etc/rc.local CompatibilityDocumentation=man:systemd-rc-local-generator(8)ConditionFileIsExecutable=/etc/rc.localAfter=network.target[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0RemainAfterExit=yesGuessMainPID=no#自己添加这一段[Install]WantedBy=multi-user.targetAlias=rc-local.service 退出vi后执行 1ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/rc.local.service 编辑这个（可能原来是空的，没关系） 1vi /etc/rc.local 大胆复制粘贴 1234#!/bin/bashfdfs_trackerd /etc/fdfs/tracker.conf startfdfs_storaged /etc/fdfs/storage.conf startexit 0 编辑完成退出vi后添加权限 1sudo chmod +x /etc/rc.local 可以了 centos比较简单 12chkconfig fdfs_trackerd onchkconfig fdfs_storaged on 2. 安装fastdfs-nginx模块 解压之前从网盘下载的这个文件，进入，编辑配置文件 123tar -zxvf fastdfs-nginx-module_v1.16.tar.gzcd fastdfs-nginx-module/src/vim config 使用替换命令(不需要进入插入模式，直接复制粘贴回车一气呵成) 1:%s+/usr/local/+/usr/+g 设置关联，把当前文件夹下的mod_fastdfs.conf文件复制到/etc/fdfs/ 1cp mod_fastdfs.conf /etc/fdfs/ 1vi /etc/fdfs/mod_fastdfs.conf 修改结果 1234567connect_timeout=20 # 客户端访问文件连接超时时长（单位：秒）tracker_server=192.168.72.128:22122 # tracker服务IP和端口url_have_group_name=true # 访问链接前缀加上组名store_path0=/home/wjw/fastdfs/storage # 文件存储路径 回到网盘下载好那几个压缩包的目录（只能这么描述了，你们放在哪里自己清楚），进入FastDFS文件夹的conf文件夹 12cd FastFDS/conf/cp http.conf mime.types /etc/fdfs/ 3. 安装nginx并绑定fastdfs的nginx模块我这里已经安装过nginx了，如果没有的话我建议手动下载gzip安装而不是apt安装，因为后期要添加模块的话只能修改完模块后重新make，而apt安装就不可以做到（像我一样apt安装的就很麻烦，不仅目录乱而且还是要下载gz包添加模块） 我随便找个教程吧（百度第一个，我没试过） https://blog.csdn.net/qq_23832313/article/details/83578836 而我的目录非常混乱，当事人非常后悔： /usr/bin 启动文件 /opt/nginx 配置文件 /usr/local 安装文件（原始的配置文件，不要动它） 使用命令可以查看是否安装好nginx 1nginx -v 不管是否已经安装好，想添加模块都需要在下载好的nginx目录下执行要添加的模块，然后重新make（add-module后面是第二步解压好的fastdfs-nginx-module那个路径），大家要注意改成自己的目录 1./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/home/wjw/Desktop/fastfds/fastdfs-nginx-module/src/ 1make 备份 1mv /usr/bin/nginx /usr/bin/nginx-bak 替换原本的nginx启动文件，注意改成自己的目录 1cp objs/nginx /usr/bin/ 修改配置文件，注意改成自己的目录 1vim /opt/nginx/conf/nginx.conf 将原来的监听80端口改成如下 12345678910111213141516171819server { listen 80; server_name image.upload.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ { ngx_fastdfs_module; } location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; }} 启动，进入/usr/bin目录，注意改成自己的目录，执行 1./nginx 通过命令看是否启动成功 1ps -ef | grep nginx 设置开机启动，网上的很多ubuntu设置开机启动都是有问题的 先看centos操作 1vim /etc/init.d/nginx 一个空文件？没关系 复制以下内容，注意一下nginx=”/usr/bin/nginx”和NGINX_CONF_FILE=”/opt/nginx/conf/nginx.conf”这两句要对应自己的目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \\# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0nginx=\"/usr/bin/nginx\"prog=$(basename $nginx)NGINX_CONF_FILE=\"/opt/nginx/conf/nginx.conf\"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() { # make required directories user=`$nginx -V 2&gt;&amp;1 | grep \"configure arguments:.*--user=\" | sed 's/[^*]*--user=\\([^ ]*\\).*/\\1/g' -` if [ -n \"$user\" ]; then if [ -z \"`grep $user /etc/passwd`\" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d \"=\" -f 2` if [ ! -d \"$value\" ]; then # echo \"creating\" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi}start() { [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $\"Starting $prog: \" daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval}stop() { echo -n $\"Stopping $prog: \" killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval}restart() { configtest || return $? stop sleep 1 start}reload() { configtest || return $? echo -n $\"Reloading $prog: \" killproc $nginx -HUP RETVAL=$? echo}force_reload() { restart}configtest() { $nginx -t -c $NGINX_CONF_FILE}rh_status() { status $prog}rh_status_q() { rh_status &gt;/dev/null 2&gt;&amp;1}case \"$1\" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $\"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}\" exit 2esac 修改权限 12# 修改权限chmod 777 /etc/init.d/nginx 设置开机启动 12chkconfig --add /etc/init.d/nginx chkconfig nginx on 再看ubuntu操作 网上很多方法比如安装什么sysv，我亲测无效，然后看到这篇博客 https://www.cnblogs.com/hellxz/p/9441949.html 亲测有效，不过原博客似乎漏了修改权限的操作 1sudo vim /etc/init.d/nginx.sh 空文件？没关系，复制下面这段，/usr/bin/nginx改成自己的启动文件下的nginx，/opt/nginx/conf/nginx.conf改成自己的配置文件下的nginx.conf，然后修改成自己的登录密码 123456#!/bin/bash#auto run nginx when system startupsudo -S /usr/bin/nginx -c /opt/nginx/conf/nginx.conf &lt;&lt; EOF登录密码EOFexit 0 修改权限（原文忘了这点，要加上） 1chmod 777 /etc/init.d/nginx.sh 添加开机重启 1sudo update-rc.d nginx.sh defaults 4. java端需要进行的操作 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;1.26.2&lt;/version&gt;&lt;/dependency&gt; 配置类 1234567@Configuration@Import(FdfsClientConfig.class)// 解决jmx重复注册bean的问题@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING)public class FastClientImporter { } yml 12345678fdfs: so-timeout: 1501 # 超时时间 connect-timeout: 601 # 连接超时时间 thumb-image: # 缩略图 width: 60 height: 60 tracker-list: # tracker地址：你的虚拟机服务器地址+端口（默认是22122） - 192.168.72.128:22122 测试类 在G盘根目录下准备一张测试用图1.jpg 1234567891011121314151617181920212223242526272829303132333435363738@SpringBootTest@RunWith(SpringRunner.class)public class FastDFSTest { @Autowired private FastFileStorageClient storageClient; @Autowired private ThumbImageConfig thumbImageConfig; @Test public void testUpload() throws FileNotFoundException { // 要上传的文件 File file = new File(\"G:\\\\1.jpg\"); // 上传并保存图片，参数：1-上传的文件流 2-文件的大小 3-文件的后缀 4-可以不管他 StorePath storePath = this.storageClient.uploadFile( new FileInputStream(file), file.length(), \"jpg\", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); } @Test public void testUploadAndCreateThumb() throws FileNotFoundException { File file = new File(\"G:\\\\1.jpg\"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadImageAndCrtThumbImage( new FileInputStream(file), file.length(), \"png\", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); // 获取缩略图路径 String path = thumbImageConfig.getThumbImagePath(storePath.getPath()); System.out.println(path); }} 我们可以看到getFullPath()打印了组信息，这时候服务器上已经有了上传的图片 浏览器可以通过http://192.168.72.128/group1/M00/00/00/wKhIgF78pUCAPLLYAACFQPZnSLk185.jpg访问到服务器的图片，也就是服务器ip+getFullPath()打印的信息 如果是前端传入的图片，那么应该是MultipartFile file这个类型的 也是一样调用uploadImageAndCrtThumbImage方法，获得相同的参数即可（getInputStream可以获得流，getOriginalFilename经过切割可以获得后缀名，具体操作如下） 12String originalFilename = file.getOriginalFilename();StorePath path = this.storageClient.uploadImageAndCrtThumbImage(file.getInputStream(), file.getSize(), StringUtils.substringAfterLast(originalFilename, \".\"), null);","link":"/Spring/fastDFS%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8Cspringboot%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"java中的引用","text":"强引用(NormalReference)我们平时用的基本上都是强引用M m = new M(); 只要强引用在，gc不回收该对象 123456789//没事不要重写finalize方法，这里是为了演示gc时机public class M { @Override protected void finalize() throws Throwable { System.out.println(\"finalize方法被调用\"); super.finalize(); }} 123456789101112131415public class 强引用 { public static void main(String[] args) throws IOException { M m = new M(); System.gc(); System.out.println(m); //存在强引用，gc不会回收 m = null; System.gc(); System.out.println(m); //引用没了，gc回收 System.in.read(); //阻塞main线程，垃圾回收线程需要时间 }} 打印结果如下 引用.M@14ae5a5finalize方法被调用null 软引用(SoftReference)软引用对象会在堆内存不足时回收 适合做缓存 在开始实验之前，先将右上角run按钮左边的本类名的v按钮选择Edit Configurations在vm options添加-Xmx20M，表示将堆最大值设置为20M 1234567891011121314151617181920/** * 软引用对象会在堆内存不足时回收 * 适合做缓存 */public class 软引用 { public static void main(String[] args) { SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024 * 1024 * 10]); //定义一个占10M的数组 System.out.println(m.get()); //有值 System.gc(); try { Thread.sleep(1000); //睡1s保证gc完 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(m.get()); //因为对内存充足，发现并没有被gc回收 byte[] b = new byte[1024 * 1024 * 11]; //定义一个11M的数组，由于此时10+11大于20M，jvm自动gc回收 System.out.println(m.get()); //被回收，为null }} 打印结果为 [B@14ae5a5[B@14ae5a5null 如果b的内存太大，堆内存装不下，那么会报OutOfMemoryError: Java heap space异常 弱引用(WeakReference)弱引用是遇到gc就回收 12345678910public class 弱引用 { public static void main(String[] args) { WeakReference&lt;M&gt; m = new WeakReference&lt;&gt;(new M()); System.out.println(m.get()); //有值 System.gc(); System.out.println(m.get()); //不管内存是否充足，遇到gc就回收 }} ThreadLocal中的Entry弱引用很经典的一个例子就是ThreadLocal中的Entry，在之前的博客中有分析ThreadLocal为什么是弱引用，这里再次复习一下 当我们ThreadLocal tl = new ThreadLocal();的时候，实际上有两个引用指向了ThreadLocal，一个是tl本身是一个强引用，一个是getMap(当前线程)得到的ThreadLocalMap，它里面的Entry的key是一个弱引用，指向了ThreadLocal。 为什么这里要使用弱引用呢？ 如果是强引用，则tl和key都是强引用，我们一般都是操作tl，也就是tl = null，但是key依然存在强引用，于是导致无法被gc回收，存在内存泄漏问题。 使用弱引用就不会内存泄漏？ 不是的，即使key是弱引用，但是如果key被回收变为null，value无法被访问，依然存在内存泄漏问题。解决的办法是主动调用tl.remove(); 虚引用(PhantomReference)一般没人用，只有写类库的人会用 无论是否被回收，都get不到值 12345678public class 虚引用 { private static final ReferenceQueue&lt;M&gt; QUEUE = new ReferenceQueue&lt;&gt;(); //回收队列 public static void main(String[] args) { PhantomReference&lt;M&gt; m = new PhantomReference&lt;&gt;(new M(), QUEUE); System.out.println(m.get()); //null }} 作用是回收前有个通知，相当于一个钩子函数，堆内存不足的时候并没有直接回收，而是放进QUEUE回收队列里，gc会不断判断队列里是否有值，有则poll，这就相当于一个通知，gc如果想，可以对poll出来的这个虚引用做一些特殊处理 1234567891011121314151617181920212223242526272829303132333435363738public class 虚引用 { private static final List&lt;Object&gt; LIST = new LinkedList&lt;&gt;(); private static final ReferenceQueue&lt;M&gt; QUEUE = new ReferenceQueue&lt;&gt;(); //回收队列 public static void main(String[] args) { PhantomReference&lt;M&gt; m = new PhantomReference&lt;&gt;(new M(), QUEUE); System.out.println(m.get()); //null new Thread(()-&gt;{ while (true){ try { LIST.add(new byte[1024 * 1024 * 2]); Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } System.out.println(m.get()); } }).start(); //模拟简易垃圾回收线程 new Thread(()-&gt;{ while (true){ //垃圾回收线程不断检查队列里面有没有 Reference&lt;? extends M&gt; poll = QUEUE.poll(); if (poll != null){ System.out.println(\"jvm回收虚引用对象\" + poll); } } }).start(); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } }} 实际应用中，虚引用常被用于管理直接内存(堆外内存) 当然，堆外内存不一定是硬件，只是举个例子，硬件通过驱动程序加载到内存中才能供操作系统调用，以前JVM无法直接控制堆外内存， 需要拷贝到JVM的堆中才能控制，这种拷贝需要系统调用，涉及用户态和内核态的转换 零拷贝技术java的nio提出了zero-copy零拷贝技术，可以管理堆外内存 1ByteBuffer buffer = ByteBuffer.allocateDirect(1024); 这个allocateDirect方法源码如下，可以看到是DirectByteBuffer，这个DirectByteBuffer什么时候回收的呢？我们可以看到这个类下有个Cleaner，就这个名字也才得到是用来负责回收对象的 12345678910111213class DirectByteBuffer extends MappedByteBuffer implements DirectBuffer{ ... private final Cleaner cleaner; public Cleaner cleaner() { return cleaner; } public static ByteBuffer allocateDirect(int capacity) { return new DirectByteBuffer(capacity); } ...} 继续跟进Cleaner类 123public class Cleaner extends PhantomReference&lt;Object&gt; { private static final ReferenceQueue&lt;Object&gt; dummyQueue = new ReferenceQueue(); ... 看源码讲究点到即止，是不是跟咱们自己写的 模拟简易垃圾回收线程 一模一样 有点相似？ 也就是说，这个cleaner就是通过虚引用对堆外内存进行跟踪。 参考 bilibili马士兵说弱引用","link":"/Java%E5%9F%BA%E7%A1%80/java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"},{"title":"linux下mysql的安装","text":"网上一大堆乱七八糟的，特别复杂，还自己下载，自己编译，又自己写配置文件。我跟你说：没必要！几个命令就搞定了 跟着这个节奏来 添加仓库 1wget -i -c https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm 安装仓库 1yum -y install mysql80-community-release-el7-3.noarch.rpm 安装mysql 1sudo yum install mysql-community-server 启动mysql服务 1sudo service mysqld start 查看mysql状态 1sudo service mysqld status 第一行绿点 第二行loaded为enabled 第三行active(runing)就成功 查看初始密码 1sudo grep 'temporary password' /var/log/mysqld.log @localhost: 初始密码 使用初始密码登录 1mysql -u root -p 修改密码（可以自己写密码，但是要达到复杂度要求，如果想用简单点的密码，请先用下面这个密码登录进去，再修改密码复杂度） 1ALTER USER 'root'@'localhost' IDENTIFIED BY '123@@@aaa...'; 修改密码复杂度 12set global validate_password.policy=0;set global validate_password.length=1; 重复步骤8，再次修改密码，这次的可以使用简单密码啦（123456也可以） 允许远程连接 1update user set host = '%' where user = 'root'; 其他杂项 关闭防火墙 1systemctl stop firewalld.service 还有一些阿里云啊华为云啊要在网站控制台关闭 开放安全组端口 其他错误参考 https://www.cnblogs.com/z0909y/p/10772854.html","link":"/Mysql/linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85/"},{"title":"markdown使用","text":"123# 一级标题（注意符号后面有空格）## 二级标题... 一级标题二级标题 1&gt; 引用（注意符号后面有空格） 引用 1231. 有序列表1（注意符号后面有空格）2. 有序列表2... 有序列表1 有序列表2 123- 无序列表（注意符号后面有空格）- 无序列表... 无序列表 无序列表 1*斜体* 斜体 1**加粗** 加粗 1~~删除字体~~ 删除字体 1---分割线（三个及以上，无需空格，但是后面不能跟东西，也就是单独占一行） 1`int a = 1;` 单行代码（符号是键盘左上角esc下面的顿号，也就是和~是同一个键的符号） int a = 1; 12345三个反引号int a = 1;int b = 1;三个反引号多行代码可以在上面那行的反引号后面加上语言，可以自动高亮 12int a = 1;int b = 1; 1[插入一个链接](http://wjw/today) 插入一个链接 123使用图床插入图片![随便起图片名字](图床链接)推荐免登录的路过图床https://imgchr.com/","link":"/Others/markdown%E4%BD%BF%E7%94%A8/"},{"title":"java主动发送http请求","text":"原来都是浏览器发送http请求，java接收。java这边也是可以主动发送http请求的。有三种方式 HttpClient OKHttp RestTemplate 1. HttpClient这是apache的一个库，先导入 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt;&lt;/dependency&gt; 看看这个工具类，直接复制过去用就行 1234567891011121314151617181920212223242526272829303132333435363738394041public class HttpTests { CloseableHttpClient httpClient; //通过jackson处理json数据 private static final ObjectMapper MAPPER = new ObjectMapper(); @Before public void init() { httpClient = HttpClients.createDefault(); } @Test public void testGet() throws IOException { HttpGet request = new HttpGet(\"http://www.baidu.com\"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response); } @Test public void testPost() throws IOException { HttpPost request = new HttpPost(\"https://www.oschina.net/\"); request.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response); } @Test public void testGetPojo() throws IOException { HttpGet request = new HttpGet(\"http://localhost:8888/user/1\"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response); //response是json字符串 User user = MAPPER.readValue(response, User.class); System.out.println(user); //user是对象 String value = MAPPER.writeValueAsString(user); System.out.println(value); //又变回json字符串 }} 2. RestTemplate这是spring自带的，在spring-web包中 写在了test包下，所以有了两个注解，也是一样，直接复制用即可。 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests { //除了httpClient，spring官方也提供了一个RestTemplate用于发送http请求 //还包括了像jackson一样处理json字符串序列化和反序列化的功能 //要通过有@Congratulation的java类注入，这个测试用例在HttpDemoApplication引导类中由@Bean注入，可以过去看看 @Autowired private RestTemplate restTemplate; @Test public void httpGet() { User user = this.restTemplate.getForObject(\"http://localhost:8888/user/1\", User.class); System.out.println(user); }}","link":"/Others/java%E4%B8%BB%E5%8A%A8%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/"},{"title":"ribbon和hytrix超时踩坑记录","text":"在学习商城项目时，接触到了搜索，完了以后我看着这搜索时灵时不灵根本没办法实际使用，看着控制台报着zuul和hytrix的错误和警告，陷入了深思… 主要是涉及以下几个错误和警告 ribbon超时时间设置太短，报如下错误 1234567com.netflix.zuul.exception.ZuulException: at org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter.findZuulException(SendErrorFilter.java:114) ~[spring-cloud-netflix-zuul-2.0.2.RELEASE.jar:2.0.2.RELEASE] at org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter.run(SendErrorFilter.java:76) ~[spring-cloud-netflix-zuul-2.0.2.RELEASE.jar:2.0.2.RELEASE] at com.netflix.zuul.ZuulFilter.runFilter(ZuulFilter.java:117) [zuul-core-1.3.1.jar:1.3.1] at com.netflix.zuul.FilterProcessor.processZuulFilter(FilterProcessor.java:193) [zuul-core-1.3.1.jar:1.3.1] at com.netflix.zuul.FilterProcessor.runFilters(FilterProcessor.java:157) [zuul-core-1.3.1.jar:1.3.1] ... 原因：通过源码可以看到ribbon的默认超时时间是1s，毕竟还是要查找数据库的，时间摆在那里，服务器性能又不是很好，不设置或者设置的时间太短的话就容易出现这个问题了 解决方案 zuul网关那个yml设置一下ribbon超时时间，这里我设置成了30000 123ribbon: ReadTimeout: 30000 ConnectTimeout: 30000 也不是越长越好，如果真的发生了错误，一直在等，如果这时候用户再发送其他请求，容易出现如下错误 1你的主机中的软件中止了一个已建立的连接 综上，考虑到服务器的性能（这里是笔记本）和数据量（这里是千），我个人认为30000-40000是比较合理的，甚至可以再大一点 还有一个是hytrix超时时间，如果没有设置好（太短或者小于ribbon总超时时间），造成查询特别慢，甚至触发了hytrix的熔断机制，这个问题比较普遍，网上也有一堆的解决办法，这个警告是这样的 1The Hystrix timeout of 60000ms for the command search-service is set lower than the combination of the Ribbon read and connect timeout, 120000ms. 意思是hytrix超时时间大于了ribbon超时时间，可是我们ribbon设置的明明就是30000呀，这个120000是什么？其实这个120000是读写总时间，具体计算方式是(30000+30000)*(0+1)*(1+1)=120000 我们可以在源码中看到 因此，我们应该把hytrix的超时时间设置成大于这个值 综上所述，我最终的yml配置如下 12345678910ribbon: ReadTimeout: 30000 ConnectTimeout: 30000hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 120000 # 设置hystrix的超时时间为120000ms 感谢这两篇博客的指导 https://blog.csdn.net/a405828/article/details/107302984 https://blog.csdn.net/lidew521/article/details/84661158","link":"/SpringCloud/ribbon%E5%92%8Chytrix%E8%B6%85%E6%97%B6%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"maven笔记","text":"1. maven概念maven是一个项目管理工具，能帮助项目规范的构建（规定了项目的结构和方便的打包）以及方便的管理lib下的jar包 如果所有的jar包都放进目录下，那么项目占用空间就会变得很大，通常来说资源文件（图片）&gt; lib(jar) &gt; java代码，很多时候jar包远远大于了java文件（毕竟只是文本），而maven通过本地的一个仓库专门存放jar包，然后不同的项目都从本地仓库中拿jar包，而项目中只需要给出jar包的坐标，就比较合理。 如果在本地仓库（电脑里存放jar包的目录）中找不到jar包，那么会到maven的中央仓库（就是那个maven官方的网站，那里有基本上所有的开源库）找，还找不到就到远程仓库（局域网的服务器）找。 2. maven项目的结构src/main/java：源代码 src/main/resources：配置文件 src/main/webapp：js，css，web.xml，html，图片等 src/test/java：测试代码（junit） src/test/resources：测试用的配置和资源文件 3. 使用前的一些配置 注意将bin目录添加入环境变量 conf/settings.xml中将 &lt;localRepository&gt;G:\\apache-maven-3.6.0\\myLocalRepository&lt;/localRepository&gt; 补在对应的标签注释下面 下载问题 设置下面这个选项后，会先从本地找jar，再到中央仓库找jar -DarchetypeCatalog=internal https://www.cnblogs.com/del88/p/6286887.html 或者创建项目的时候 4. 关于scope比如servlet,由于maven自带servlet，但是写代码的时候我们必须要javax的servlet，否则会报错，因此我们写代码时用javax.servlet，编译时用maven的servlet，所以我们要指定范围 &lt;scope&gt;provided&lt;/scope&gt;代表写代码时生效 5. maven换源在maven安装目录/conf/settings.xml文件下 &lt;mirrors&gt;标签下添加如下代码 阿里巴巴源（建议不要整那些花里胡哨的源） 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 效果如下：（大概140-160行这里，可能有点不同） 6. maven依赖报红线的终极解决办法这几个按钮依次点几下，就会重新下载了，然后找到报错的那几个dependency剪切再粘贴一遍，包好！！！！ 7. maven父子工程除了maven的包管理（可以在不同的工程下重复使用包），还有maven对代码也实现了可重用，主要体现在同一个项目通常有卖家版买家版，管理员版和普通用户版等等不同的角色版本，这些版本都是针对同一个项目，所以dao层的代码（如findAll, findById）之类的都是查询同样的东西，因此这部分代码可以单独抽离成子工程。 7.1 父子工程使用步骤 父工程 其实只需要一个pom.xml，所以new project也好new module也行。然后删掉src目录。作用就是只管理坐标 创建子模块 比如我们这里创建dao层，因为不跟页面打交道，所以我们不需要webapp骨架，直接对着父工程new module（注意不是对着idea左上角file-&gt;new） 这样一个子模块就创建好了，子模块在自己的pom.xml中添加&lt;parent&gt;标签就可以用父模块的依赖。 12345&lt;parent&gt; &lt;groupId&gt;com.wjw.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; 同样的创建出service层和web层，其中创建web层时需要通过webapp骨架创建，并将自己pom.xml中无用的依赖删掉（packing以下的都可以删掉） 关联 service肯定要用dao里面的方法的，那么就在service中的pom.xml中这样添加 12345&lt;dependency&gt; &lt;groupId&gt;com.wjw&lt;/groupId&gt; &lt;artifactId&gt;maven_day02_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 这个也好理解，其实平时引用的依赖也不过是别人写的代码而已，我们自己的代码当然也可以作为别人的库，只是没有打包成jar而已. 原来项目中的resources文件夹下的东西现在如何分配 以ssm项目为例 log4j.properties属于web模块 springmvc.xml属于web模块 applicationContext.xml需要分为3个部分 dao模块：配置连接池，生产SqlSession工厂，扫描接口包路径，下面直接给出dao模块所需applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--dao层整合配置开始--&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///maven\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"0751@@@wjw\"/&gt; &lt;/bean&gt; &lt;!--配置生产SqlSession工厂（因为SqlSession是线程不安全的，所以通过工厂来创建）--&gt; &lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--扫描pojo包，给包下所有pojo起别名--&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.wjw.domain\"/&gt; &lt;/bean&gt; &lt;!--扫描接口包路径，生成包下所有接口的代理对象，并且放入spring容器中--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.wjw.dao\"/&gt; &lt;/bean&gt; &lt;!--dao层整合配置结束--&gt;&lt;/beans&gt; service模块：开启注解扫描，aop相关，下面直接给出dao模块所需applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--servie层配置文件开始--&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"com.wjw.service\"/&gt; &lt;!--通过spring的aop来配置声明式事务控制： 其实就两个事情：1.通知 2.切面 但这里的通知指的是Spring自带的事务管理器，所以要先将这个事务管理器的bean弄出来，再加入通知中--&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--配置通知--&gt; &lt;tx:advice id=\"advice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\" /&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.wjw.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"advice\" pointcut-ref=\"pt1\"/&gt; &lt;/aop:config&gt; &lt;!--servie层配置文件结束--&gt;&lt;/beans&gt; web模块：只需引用上面两个模块的xml，下面直接给出dao模块所需applicationContext.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;import resource=\"classpath:spring/applicationContext-dao.xml\" /&gt; &lt;import resource=\"classpath:spring/applicationContext-service.xml\" /&gt;&lt;/beans&gt; 启动 方式一 运行父工程的maven自带tomcat 方式二 运行web的maven自带tomcat（只有父工程和web工程需要tomcat），但是web工程pom.xml找的是需要打包好的service的jar包，所以我们需要手动打包一下（maven的install就可以打包），直接对parent模块进行install即可 方式三（重要，使用本地tomcat） 通常我们都是用本地的tomcat的，正常添加就行了，没什么好说的，添加artifact的时候，会发现了只有web模块可以添加。其实就算是上面第一种方式，也是默认路径为web模块 7.2 错误解决 无法在web.xml或使用此应用程序部署的jar文件中解析绝对uri：http://java.sun.com/jsp/jstl/core 参考这篇博客 https://blog.csdn.net/weixin_42634260/article/details/89931226?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task 如果还不行，可以在上面的修改的基础上再在web.xml的web-app标签中添加 12345678&lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/core&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c.tld&lt;/taglib-location&gt;&lt;/taglib&gt;&lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/fmt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/spring-form.tld&lt;/taglib-location&gt;&lt;/taglib&gt; 2.如果报错No tag [formatDate] defined in tag library imported 直接把jsp中的这句删掉吧，少展示一项两项无所谓，jsp的错误实在是没有心情研究，0202年了谁还用这东西 8. maven安装jar包mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.1.0 -Dpackaging=jar -Dfile=ojdbc14.jar","link":"/Others/maven%E7%AC%94%E8%AE%B0/"},{"title":"redis基础","text":"1. 数据存储和查找发展文件：慢，因为全量扫描-&gt;IO，因此慢 mysql：为什么数据库存东西，因为快，为什么，因为做了分块(datapage)，然后对这些块做了索引，所以我们先查索引，找到对应是哪块，然后只查这一块，就快很多。那要扫描索引？，将索引加载进内存并且采用B+树结构可以避免扫描整个索引。 面试题：如果表很大，增删改查会变慢吗？数据量大了，增删改是一定会变慢的。查询：得分场景，即便表很大，但是如果一个客户端发送一个简单的查询请求，索引命中了情况下，查询还是毫秒级的。但是如果高并发情况下，查询是变慢的，因为查询时间应该包括寻址时间和磁盘io时间，即使寻址是毫秒级的，但是由于带宽，吞吐等硬盘限制，高并发场景下会受到硬盘的限制而变得很慢，否则也不会出现分布式微服务上来就是redis这种事情 redis：综上所述，并发情况下限制主要在硬盘，那所有数据存在内存中呢？那当然快了！还真有这么一种内存型关系数据库：SAP HANA，可是内存它贵呀，动不动就上T的数据存在内存中太烧钱了。redis的产生理念：其实只有一小部分数据频繁被访问（被称为热点数据），很大一部分数据都是不经常用的就存在mysql里，因此使用redis一定要明确使用场景：热点数据。 2. Redis特点面试可不要只说一点啊，看我的！ NoSQL系列，key-value形式，内存数据库：NoSQL是非关系型数据库的统称，redis以键值对的形式存在，在内存中速度会比mysql快几个量级。为什么redis是key-value型的而不是sql形式：不妨根据上面所说的大胆猜测一下，关系型数据库中通常会接触到范式，A表外键为B表的主键，而redis设计初衷就是只存一部分热点数据，因此无法确定是否包含在B中，因此redis应该只关注自身，不关注依赖。 有自己的数据类型，实现了计算向数据移动（这个词就很专业）：有String, Set, List, Hash, Sortedset五种类型，并且每种类型有自己的本地方法，对比memcache（所有的value都是string类型并通过json转换），如果需要取出数组第二个元素，memcache需要将整个list字符串返回，调用方拿到数据转换成列表再取第二个元素，redis可以读取list并通过lindex命令取出第二个元素并返回，也就是先计算再io，这种计算向数据移动的思想在map-reduce中有体现，可以减少传输的数据量，很快。 工作线程是单线程的，看下面第四点 3. 五种数据结构 api我就不多说了，可以看官方文档/中文文档/菜鸟教程 https://redis.io/commands https://www.redis.com.cn/commands.html https://www.runoob.com/redis/redis-lists.html StringString数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数值和Bitmap。 使用场景包括 常规计数：微博数，粉丝数等 bitmap重点说一下这个，有一些特殊的场景运用 SETBIT key offset value 8个位为一个字节，SETBIT key1 6 1为00000010，offset为从左往右从0开始数 超过了7，则为第二个字节，SETBIT key2 9 1为00000000 01000000 BITCOUNT start end 统计有多少个位为1，注意start和end以字节为单位而不是以位为单位 场景1：统计某个用户某段时间内的登录天数 这个如何用bitmap巧妙完成呢，用户在哪天登录，就将其作为offset，比如用户在第1天和第365天登录 SETBIT wjw 1 1 SETBIT wjw 365 1 统计的时候就可以 BITCOUNT wjw 0 -1 可以计算一下，这个key最多也就占46个字节（46×8=368，因为一个bitmap是8的倍数） 场景2：统计某段时间内的活跃用户数量 key是日期，offset是用户id，value是1 如wjw的用户id是1，whx的用户id是2,那么 SETBIT 20200101 1 1 SETBIT 20200101 2 1 SETBIT 20200102 1 1 也就是wjw在第一天和第二天登录，whx只在第一天登录 那么这两天的活跃用户数量为 BITOP or res 20200101 20200102 BITCOUNT res 得到res等于2 Hashhash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等 底层数据结构如下 Redis中的字典使用哈希表作为底层结构实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。 Redis使用MurmurHash2算法来计算键的哈希值。 哈希表使用链地址法来解决键冲突。 注意：这里和Java的HashMap不同的rehash过程 Redis的rehash过程是扩展和收缩，而且还是渐进式的rehash Redis的字典有两个哈希表ht[0]和ht[1] 为字典的ht[1]哈希表分配空间，如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used *2的2^n；如果执行的是收缩操作，那么ht[1]的大小第一个大于等于ht[0].used的2^n。（举个例子，ht[0]的长度为10，那么扩展就是2^5的32，如果是压缩的话2^4=16） 如果ht[0]的键值非常多的话，一次性转移过去，是一个非常耗时的操作哦，因此并非一次性，采取渐进式rehash转移。 Listlist 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表、粉丝列表、消息列表、评论列表等功能都可以用Redis的 list 结构来实现。 Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高 Set当你需要存储一个列表数据，又不希望出现重复数据时用set，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作 场景1：抽奖 SRANDMEMBER key 3，不重复的随机抽3个 SRANDMEMBER key -3，可重复的随机抽3个 场景2：推荐系统 交集：共同关注：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常 方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：sinterstore key1 key2 key3将交集存在key1内 差集：可能认识的人：SDIFF 并集：好友圈：SUNION Zset和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。 举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。 底层实现是一个跳表SkipList 放知乎程序员小灰的两篇文章 https://zhuanlan.zhihu.com/p/53975333 https://zhuanlan.zhihu.com/p/200815425 简单来说跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 跳跃表平均O(longN)，最坏O(N)复杂度的节点查找 跳跃表有个层的概念：层带有两个属性：前进指针和跨度，前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。一般情况下，层越多，查找效率越高。 4. Redis的NIO和线程模型redis是单线程的还是多线程的？ 用户对redis操作是单线程的（worker单线程），redis 6.x支持多线程，但是！！！这叫io threads，用于处理用户的请求，实际操作还是单线程的。 5.x和6.x对比如下 可以看到在6.x的时候worker线程（计算那里）还是单线程，但快了不少。 4.1 为什么是单线程的因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。redis核心就是：如果我的数据全都在内存里，我单线程的去操作就是效率最高的，因为免去了线程之间的上下文切换开销。 4.2 秒杀场景的redis使用高并发场景，多个service线程。如果是mysql不加锁，必定会脏读，造成超卖，必定加锁同步，实际退化成所有service串行，加上前后其他业务逻辑，很慢。改用redis，单线程，本身就是串行化操作，通过decr进行商品数量减一 4.3 strace追踪线程strace可以追踪一个进程以及所有线程对操作系统的系统调用有哪些。比如是否使用了fork，是否使用了epoll，是否又创建了线程 1sudo apt install strace 进入redis目录（src或者守护进程的都行） 1strace -ff -o /home/wjw/stracelog/out -ff表示监听fork系，第二个f表示包括线程 -o表示输出目录为/home/wjw/stracelog并以/out为前缀 可以进入/proc/3324/task目录下 这些是什么？3324是线程号，task代表任务，也就是开启了4个线程 用vi或者gedit打开out.3324可以看到很多epoll相关的系统调用，因此redis的线程采用了epoll多路复用的技术 客户端输入bgsave，服务端3324线程开启了新的线程3829进行保存，使用clone系统调用，copy on write技术 查看strace的跟踪 5. 缓存雪崩，穿透，击穿缓存雪崩：是说redis大量内容同时过期，因此db突然之间多了很多请求。解决方法就是随机过期时间 缓存穿透：查询id=-1，第一次查db，查不到就不放进redis，第二次查一定不会在redis中，又去查db，如此往复…恶意发送大量查询请求，导致一直查db，就是缓存穿透。解决办法就是把-1: null存进redis，或者限制同一个key在一段时间的请求次数，或者是使用过滤器过滤掉 布隆过滤器：就是一个很长的bit数组，通过一级或者多级不同的hash函数之后将key转换成多个位的1，然后在bit数组上看是该key否存在，然后每次添加入redis时也会将这个key的hash位置为1。需要注意的地方有两个 这里既然是Hash函数，那就存在一个问题，不存在的key也有可能经过hash函数之后对应位全为1，被误判为key存在，不过没关系。hash判断存在，key不一定存在。hash判断不存在，key一定不存在 bit数组里面的位只能添加为1不能修改回0，因为改为0可能会影响多个key。所以要判断好这个数组的长度，否则经过多次置1后数组全为1，过滤器就失去了过滤意义，可以重新扩容。 因为这些问题，后面还有其他的过滤器比如布谷鸟过滤器 缓存击穿：跟缓存雪崩类似，是因为过期导致的，但是不是大量内容，而是说对同一个key发出大量的请求（比如秒杀），突然过期了，导致查db。这种场景解决办法就是查db的时候加锁，过期–&gt;加锁查db–&gt;db压力小–&gt;重新放进redis–&gt;查redis 6. Redis内存回收策略两个方面： key过期时被删除 内存占用达到maxmemory触发内存溢出控制策略 6.1 删除过期keyredis不会实时监控每个key的过期时间并删除，而是采用惰性删除和定时任务删除 惰性删除：过期的key并没有被直接删除，而是等到下一次访问的时候才删除。访问一个key，判断ttl，如果为0过期了，则删除并返回null，否则正常返回value。如果一直没有被访问，则会造成内存泄漏 定时任务删除：为了解决上述内存泄漏问题，redis每秒运行10次定时任务 慢模式：随机检查20个键，过期则删除，过期超过25%，循环执行上述过程直到低于25%，超时时间为25ms 快模式：逻辑和快模式相同，只是超时时间不同。如果慢模式超时则先执行一次快模式，快模式下超时时间为1ms且2s内只能运行1次 6.2 内存溢出控制策略当Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemory-policy参数控制，Redis支持6种策略，如下所示： noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。 allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。如果没有对应的键，则回退到noeviction策略。 参考作者：杨鑫科链接：https://www.jianshu.com/p/6a5eb0ddf57b来源：简书 7. Redis持久化redis存在内存中，服务器故障就造成了数据丢失，可以通过一些持久化策略来保护数据 7.1 RDB（redis database）默认开启，将redis中的数据转换成二进制文件，调用save/bgsave/自动化时产生dump.rdb文件，适合全量备份。 save：阻塞（调用时其他client的命令不能执行），覆盖（有旧的就替换） bgsave：后台进行，原理是保存fork出来的副本，因此调用bgsave后即使修改了也不会被保存，因为副本没有变。也阻塞但阻塞的只是fork阶段，不阻塞客户端命令，缺点是需要消耗额外的内存 配置自动触发：redis.conf配置文件中设置save m n。表示m秒内数据集存在n次修改时，自动触发bgsave。 rdb的三种触发方式都是保留了触发前最后一刻的状态，因此也称为快照 恢复：将dump.rdb放在redis安装目录（可以通过config get dir命令获取）并启动redis即可 7.2 AOF（append only file）默认不开启，记录的是操作命令而不是内存数据，类似于日志文件。他不是记录每一步操作，而是调用bgrewriteaof命令时将当前内存中的数据生成命令的形式保存下来 也有三种触发方式 （1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 （2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失 （3）no：从不同步 redis4.x之前开启了AOF就不用rdb了，4.x及以后用混合模式，恢复很快 8. 高可用架构主从架构+哨兵模式+集群 8.1 主从架构作用 读写分离：从机只读不可写，缓解了主机读压力，写从机会报错（you can’t write read only slave） 容灾恢复：从机会复制主机的数据，相当于备份(采用的是记录复制的偏移量的方式，可以断点续传 ) 高可用：主机一挂，从机能升级为主机 配置方法 如果是同一台主机做实验，那么要修改redis.conf(默认为6379.conf)中的端口号、pid、日志名、rdb名(默认为dump.rdb，会覆盖) 查看角色命令为info replication 主机会显示 role: master 并显示从机的ip和端口 从机会显示 role: slave 并显示主机ip和端口 从机执行命令slaveof 主机ip 主机端口并配置认证密码即可，主机无需配置 主从复制过程 首先明白两个关键字 runid: master节点的唯一标识，每次启动时生成，可以通过info server查看 offset: slave需要从哪个位置开始同步数据(可以断点续传) 除了全量复制，还有部分复制，防止全量复制中因网络抖动而失去连接 8.2 哨兵模式哨兵就是用来监管各个机器的健康状态的，当主机宕机时，根据偏移量将某一台从机通过slaveof no one变成主机，其他主从机slaveof newIp newPort，哨兵可以帮我们自动完成这个过程。 8.3 Redis集群redis3.0之后的新特性，主从复制还不能实现高可用，因为只分担了读压力，使用Redis Cluster，多个”节点”，每个节点都采用s主从架构，每个主节点都可以支持读写操作 每个节点负责的区域不同，数据是不一致的，要获取数据时必须先通过crc16算法再%16384得到对应的节点地址 后期新增节点可以进行hash迁移，潜移部分数据分担其他节点的压力","link":"/redis/redis%E5%9F%BA%E7%A1%80/"},{"title":"mysql索引","text":"1. 为什么是B+树1.1 哈希索引哈希胜在查找单条数据快，只需要计算哈希函数就可以定位到索引数组下标，继而得到值，ps：索引存储的不是直接的数据库中的值，而是地址，通过索引找到地址然后就可以取数据库中地址对应的值了。 但是如果使用哈希表做索引，是无序的（30 % 29 = 1会在2的前面），但是数据库经常需要范围查询，大于小于，排序等操作，因此哈希索引不合适 1.2 AVL树平衡二叉树作索引，查询效率是O(logn)，但是有两个缺点 树越高查询速度越慢 中间的某个id比如0005去到了叶子节点，那么要查找id大于0005的就需要回旋查找0006 1.3 B树一个节点可以存多个值，解决了AVL树高度过高的问题，但是回旋查找的问题依然存在 1.4 B+树B+树就是为了解决回旋查找的问题，每个根节点出现过的元素都会在叶子节点出现一次（非叶子节点只存key，叶子节点还存了地址，用于在数据库中查找），最底下的叶子节点层直接指向了下一个节点，这样查询大于某个id的时候就可以先通过树找到对应的节点，然后通过链表一直往后查询要找的数据 最后贴上这个数据结构可视化网站，好像是旧金山大学的网站 1https://www.cs.usfca.edu/~galles/visualization/Algorithms.html 2. explain查看索引使用情况只需要在select语句前面加上explain关键字即可解释查询 1explain select * from table_name where id &gt; 9 关注几个字段 type：代表了索引的级别，有以下几个级别 system：查找只有一条数据的系统表，基本不可能达到 const：查主键（where id = 1）因为主键是唯一的，而且mysql自带主键索引 eq_ref：建立了唯一索引/主键索引+要求查出来的索引列是唯一的（where 身份证号 = “123”） ref：对应列建立了索引（可以是联合索引）+在索引列上查询（where name = “张三”），是一般sql优化期望达到的级别 range：对应列建立了索引+在索引列上范围查找（between、in、&gt;、&lt;、&gt;=等），要注意in只有在数据量大的时候才生效 index：也叫覆盖索引，对应列建立了索引+查询结果返回字段限定（select name比select *好的原因），要注意如果name列没有建立索引是不可以的！这种情况下实际还是遍历了所有数据，但是遍历的是索引树（内存），而不是数据库（硬盘） all：没有用到索引 possible_keys：代表可能用到的索引 key：代表实际用到的索引 rows：实际扫描的行数，越小越好，说明过滤的越彻底 ref：索引各个字段的级别（因为有可能是复合索引但不是所有都同一个级别） key_len：索引占用的空间，越小越好，因为有可能你用到了索引，但该索引可能不是最优（多了不必要的字段） 实战环节！ 环境：1000条数据，表结构如下 2.1 无索引效果1SELECT SQL_NO_CACHE * FROM `test_user` WHERE phone = &quot;13542831871&quot; AND lan_id = 702 AND region_id = 94 加上SQL_NO_CACHE指定不使用缓存，查询更接近真实值，当然我觉得还是有缓存的，第一次5s，第二次开始稳定在3.7s左右 解释执行，可以看到type为all，也就是没有使用索引，扫描了全表 2.2 有索引效果1ALTER TABLE `test_user` ADD INDEX idx_phone_lan_region(phone, lan_id, region_id) 随后再解释查询，第一次执行1.3s，随后稳定在0.03s，可以看到提升还是很大的 可以看到type为ref，代表使用了索引，key说明最终使用的索引名称，ref为const表示三个字段都用到了索引，rows为1表示共扫描1条。这就是最好的状态了，能用的索引都用上了，精准定位！ 3. SQL调优整个流程是这样的 使用explain查看sql执行计划并排除缓存干扰 analyze table和force index强制走索引 检查是否能优化SQL中的函数和计算 检查是否存在类型/编码转换导致的索引失效 检查like左边是否有%导致索引失效 order by文件内排序优化 检查是否能使用覆盖索引代替select * 检查是否能通过联合索引减少回表次数 检查是否能优化最左匹配法则的顺序 长字段使用前缀索引优化 普通索引和唯一索引的选择优化 考虑MySQL5.6以上版本带来的索引下推优化 防止像我这种啥也不懂的菜鸡乱加索引导致的索引失效问题(●’◡’●) 其实根本原因就是前面说的B+树的结构，结构决定性质，能根据B+树找到对应的节点，那么就不会失效，下面一一介绍。 3.1 函数如使用了count(*)、sum()、round()会导致失效，注意：计算/函数导致的失效指的是“select后”和“=前”的字段，因为=后面的函数是能用到索引的比如where lan_id = 1 + 1和where name = lower(s) 3.2 计算字段后面的字段计算字段：+、-、*、/、!=、&lt;、&gt;、is null、is not null、or 先来看这个range，说明索引列+&gt;是可以用到range级别的索引的 接着把这个&gt;后面的region_id字段去掉 这就说明实际上复合索引的最后一列region_id是没有被用到的，只用到了前两列。 另外就是id + 1 = 1000改成id = 1000 - 1才能走索引 3.3 类型转换id = “1”本来是数字，虽然也能查，但是索引失效（5.7之前不失效） 都会显示如下 也就是看到查询phone字段说明可能会用到索引，但实际上用不到 3.4 编码不一致utf8mb4和utf8两张表联查时，会自动转换成utf8mb4，如果索引在utf8的表中，这样是用不到索引的，究其原因是二叉树查找也是得判断是否相等，编码不一致找不到 3.5 like的失效和优化like左边有%是用不到索引的 只有右边有%可以用range级别的索引 由于模糊搜索业务场景通常需要两边%，这时候如果只搜索这个字段，我们可以使用覆盖索引（前面介绍的index）优化，也就是select phone而不是select *，可以看到也是有索引的 如果需要全部字段，根据本次的phone结果再搜索一次=，总体会比全表扫描快 另一种优化方案是建立一个反向列，很不错的思路，可以参考这篇文章 https://blog.csdn.net/weixin_38106322/article/details/106583450 mysql5.7后可以建立虚拟列，参考这篇文章 https://blog.csdn.net/JiSoBeautiful/article/details/96433283 也可以直接上es，可以进行隔字查询，适应更多业务场景 3.6 order by的失效和优化order by会使索引失效 先对create_time列建立索引 1ALTER TABLE `test_user` ADD INDEX idx_create_time(create_time) 查询时间5s+ 解释查询，可以看到type为all，另外要看extra列，using filesort说明使用了文件内排序：意思是它在内存中开辟了一个空间，将数据复制到内存里面，进行排序再返回，这是很恐怖的一件事情，浪费了大量的内存 优化方案：使用覆盖索引select create_time 时间如下 覆盖索引虽然速度提升明显，但是只查一列很难满足业务场景，如果结果为一条，那么还好，可以根据这一条再查一遍=，但是如果有多条，使用in不一定能带来很大的提升，时间和解释如下图 因此，不如读取到java中进行排序来的快 3.7 最左匹配法则最左匹配法则：我们的索引字段依次是phone, lan_id, region_id，因此能匹配的组合实际有： phone, lan_id, region_id phone, lan_id phone 我们试一下查询条件只有第一个和第三个 可以从type和key中看出，依然使用了这个复合索引，但是从ref看到破坏了最左匹配法则情况下，只有第一个字段phone使用了索引。时间的话由于结果都只有1条数据，所以相似，参考意义不大。 可以简单的想象成几座连续的桥，只有过了第一座桥才能过第二座桥。当然知其然也要知其所以然，要知道究竟为什么还是得自己心里有B树( •̀ ω •́ ) 联合索引的树节点是这样的，data里面存了一个元组（三个就是三元组） 因为在建树和查找的过程中需要比较大小（中文也支持），是按照索引的顺序来的：先比较第一个，第一个相同再比较第二个…以此类推，因此只有在前面的字段有序（能找到）的情况下后一个字段才有序（能找到），比如上图只有在字段a为1的情况下b才是有序的，总体看b是没有序的。因此这就是为什么出现最佳左前缀法则的根本原因。 3.8 前缀索引简单说就是对于长字段，比如descirption，或者短字段但想节省索引长度，可以截取字段的一部分作为索引，从而节省索引key_len。因为索引越长，占用磁盘越大，一个数据页存的索引就越少，会降低效率，举个例子： 邮箱xxxx@qq.com，我们索引可以只做xxxx 网址www.abc.com，我们可以截取第一个.后面的来建立索引 身份证前面是区号，区分度不高，可以reverse后再截取 那么如何评价区分度，前缀需要截取多少位呢？参考这篇博客 https://blog.csdn.net/u013295276/article/details/79105163 12345678910-- 计算出完整字符串的选择性(比如0.3)SELECT COUNT(DISTINCT city)/COUNT(*) FROM city_demo;-- 计算各个前缀的选择性(前34567个字符)，然后找比较接近的且前缀最短的SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*) pref3, COUNT(DISTINCT LEFT(city,4))/COUNT(*) pref4, COUNT(DISTINCT LEFT(city,5))/COUNT(*) pref5, COUNT(DISTINCT LEFT(city,6))/COUNT(*) pref6, COUNT(DISTINCT LEFT(city,7))/COUNT(*) pref7FROM city_demo; 3.9 唯一索引和普通索引的选择这里涉及到一个概念就是change buffer： MySQL查询的时候会将数据页加载进内存中，更新的话就可以直接更新内存中的数据，而不是直接刷写硬盘（这是最耗时的）。如果没查询，那么内存中没有数据，更新操作缓存在change buffer中，下次查询的时候再将数据页读入内存，然后执行change buffer中与这个页有关的操作，这个过程叫做merge。 唯一索引的劣势：需要进行唯一性检查，那么会读取数据页到内存，无法使用change buffer 唯一索引的优势：因为是唯一的，查询的时候找到即可，不需要往右继续查是否相同 综上所述 3.10 索引下推5.6之后mysql自带的优化，看下面这个语句，假设建立了索引(name, size) 1select * from itemcenter where name like '张%' and size=22; 5.6之前，在B+树中找到10个张%，那么会将这10条数据的id进行回表找到size=22 5.6之后，在B+树中找到10个张%，先判断索引中的size=22，过滤后可能剩2条，再根据id回表 参考本文参考 IT老哥公众号和bilibili视频（https://space.bilibili.com/526653251?from=search&amp;seid=7511781974100514678） 三太子敖丙公众号MySQL系列文章 SCDN博客：https://blog.csdn.net/u013295276/article/details/79105163","link":"/Mysql/mysql%E7%B4%A2%E5%BC%95/"},{"title":"为什么我的博客提示不安全","text":"1. 前言很有意思的一件事，万万没想到我面试时被问了这个问题。 ”你有没有发现你的博客url旁边提示网站不安全？请问你有没有思考过是为什么？“——同盾科技面试官打开了我的博客并如是说道 当时我内心颤抖了一下，不知道这个是因为https的原因还是我的域名没有备案的原因，想了想我直接回答了不太清楚…接着第二个问题就是http/https的区别，我只知道名字s代表security… 2. 解决方法其实当初搭建博客也只是为了记录一点学习心得，主要都是在内容上，确实没有认真端详过配置，选hexo搭建也就是因为部署简单。 今天我了解了一下 网站不安全这个其实很容易解决，是因为http/https的问题，因为是github pages托管，所以只要在项目的settings下打开这个选项即可 想起来这个按钮之前有一次博客被我搞挂了，后面就重新搭建就没开了。打开再看就已经安全了 当然者是github pages托管的情况，如果是自己的网站部署到了华为云/阿里云，那么可以在对应的云平台申请SSL证书的，免费的只有一年，想要永久免费就要每年手动购买一次，然后在服务器的nginx里配置下载好的证书，具体操作可以参考这篇文章 https://www.jianshu.com/p/8046a12fec4a 需要注意的是，如果你的域名没有备案，只能选DNS验证申请SSL证书的，文件验证是不可以的 3. HTTP/HTTPS的区别知其然也要知其所以然 为什么网站提示不安全？ 因为现在的浏览器基本都要https才提示安全 https和http有什么区别？ HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）是身披SSL外壳的HTTP，与HTTP明文协议对比，HTTPS具备两大网络安全功能：加密以及身份验证。 加密：HTTPS传输协议可对客户端与服务器之间的传输数据进行加密，防止第三方的窃取、篡改、窥视等中间人攻击（中间人攻击可以看大佬的讲解https://www.zhihu.com/question/304030251）。 身份验证：客户端用户可通过HTTPS背后的SSL证书对服务器进行身份验证，辨别真假网站，避免掉入钓鱼网站的陷阱。 如何才能使用https协议？ 通过CA机构（数字证书颁发中心，如GDCA）申请SSL证书，然后在网站服务器上正确部署SSL证书即可，具体操作方法参考第二节 CA机构颁发的证书有3种类型： 域名型SSL证书（DV SSL）：信任等级普通，只需验证网站的真实性便可颁发证书保护网站； 企业型SSL证书（OV SSL）：信任等级强，须要验证企业的身份，审核严格，安全性更高； 增强型SSL证书（EV SSL）：信任等级最高，一般用于银行证券等金融机构，审核严格，安全性最高 其中，阿里云，腾讯云，百度云，又拍云等等 可以免费申请域名型SSL证书（DV SSL） 参考https://www.cnblogs.com/zhanglw456/p/13266493.html 4. 感想 打算把博客配置搞一下，开启评论功能，目录跟随滚动等等，优化一下阅读体验 域名是不可能备案的，嘿嘿 这次面试一二面感觉都还不错，查漏补缺，春招加油","link":"/Others/why-my-blog-tips-unsafe/"},{"title":"volatile","text":"1. 线程之间可见性1.1 问题引出Volatile到底是用来干嘛的，来看一段程序 1234567891011121314151617181920212223242526272829303132public class Volatile问题引出 { private static /*volatile*/ boolean flag = false; public static void main(String[] args) { A a = new A(); a.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } flag = true; } static class A extends Thread{ @Override public void run() { while (true) { if (flag){ System.out.println(\"知道主线程将flag变为true了\"); break; } } } }} 两个线程共同维护一个变量flag，一个睡1s后修改flag为true，另一个等待它变为true后输出一句话 运行就会发现永远不能输出，因为一个线程感受不到另一个线程对它的改变，这是为什么呢？ 因为JMM中有规定，线程不能直接操作主存中的值，只能拷贝到自己的工作内存再进行操作 也就是说线程改变了自己工作内存中的flag的值，并没有影响到另外一个线程的工作内存。明白了这点后，再把上面的代码volatile注释放开，这时候就能输出并结束了，这就是volatile的其中一个作用：线程间的可见性 误区：缓存一致性协议其实volatile跟缓存一致性协议根本没什么关系，网上很多文章会将其和缓存一致性协议放在一起说，其实他们不是一回事 再看刚才的这一句，还是注释掉了volatile，但是while循环中多了一句打印System.out.println(“随便打印一条语句”);其他地方完全一样 123456789101112131415161718192021222324252627282930313233public class Volatile问题引出 { private static /*volatile*/ boolean flag = false; public static void main(String[] args) { A a = new A(); a.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } flag = true; } static class A extends Thread{ @Override public void run() { while (true) { System.out.println(\"随便打印一条语句\"); if (flag){ System.out.println(\"知道主线程将flag变为true了\"); break; } } } }} 运行，看到可以经历很多次循环后还是打印了flag 这就是因为缓存一致性，更新了主存里面的东西，比如同步锁，可以看到volatile被注释掉了还是能更新，跟volatile没有半毛钱关系 2. 禁止指令重排序2.1 什么是指令重排序就是说cpu为了运行效率可能会将两条没有依赖性的指令顺序进行对调 这里有一段很巧妙的程序证明指令重排序存在 1234567891011121314151617181920212223242526272829public class 证明指令重排序 { private static int a = 0, b = 0, x = 0, y = 0; public static void main(String[] args){ long time = 0; while (true) { time++; a = 0; b = 0; x = 0; y = 0; Thread thread1 = new Thread(() -&gt; { a = 1; x = b; }); Thread thread2 = new Thread(() -&gt; { b = 1; y = a; }); thread1.start(); thread2.start(); try { thread1.join(); thread2.join(); } catch (Exception e) {} if (x == 0 &amp;&amp; y == 0) { break; } } System.out.println(\"time=\" + time + \",x=\" + x + \",y=\" + y); }} 这段程序巧妙在哪呢？看两个线程的任务逻辑，可以分析出不管哪个线程先执行，或者交叉执行，只要a = 1在x = b之前，b = 1在y = a之前，都不可能出现x = 0, y = 0的 说的再简单点： 如果a = 1先执行，那么y必为1 如果b = 1先执行，那么x必为1 如果a = 1, b = 1先执行，那么x, y都为1 只有被重排序为 1234567//线程1x = b;a = 1;//线程2y = a;b = 1; 才有可能x = 0, y = 0，明白了吗？ 我们来看下指令重排序的底层原因 在java中Object o = new Object();产生了以上汇编指令 123new -&gt; 生成一个初始值m=0invokespecial -&gt; 赋值m=8astore -&gt; 将指针t指向这个m 指令重排序，可能会调整为如下 123new -&gt; 生成一个初始值m=0astore -&gt; 将指针t指向这个minvokespecial -&gt; 赋值m=8 这就有可能会造成我们拿到的指针不为null，但是此时的值还为0 2.2 DCL单例要不要加volatile单例模式的一种实现：double-checked locking 1234567891011121314public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; }} 这种方式高效，且实现了线程安全和懒加载 懒加载就是说定义的时候没有直接new，而是在调用getInstance的时候new 线程安全是说synchronized包裹了判空和new， 高效是说锁的粒度很细，只锁住了判空和new，因为外层可能会有别的业务代码。另一方面，DCL中外面的那层判空，避免了直接的synchronized锁竞争，提高了效率 好了，简单介绍完后，来说为什么要加volatile，一定要加，因为之前说了指令重排序，可能造成指针先存在，后赋值的现象。如果线程1发生指令重排序，先astore有了指针，此时停下，第二个线程走完整个流程，判空不为空导致直接return，但是又还没有new，因此return了个半初始化状态的对象 因此DCL单例一定要加volatile，禁止指令重排序 2.3 volatile如何做到禁止指令重排序的？内存屏障，在JVM级别，内存屏障只是一个规范，就像是接口一样，交给不同的CPU实现，这个东西不同的硬件实现不一样。 JVM中规定有4中屏障 LoadLoadBarrier读读屏障 LoadStoreBarrier读写屏障 StoreLoadBarrier写读屏障 StoreStoreBarrier写写屏障 在volatile写之前加写写屏障，之后加写读屏障 在volatile读之后加读读屏障和读写屏障 不同的硬件厂商有自己不同的实现，其实并没有严格遵循规范（比如因特尔的sfence、ifence、mfence指令），但不管怎样都遵循两个最基本的原则： happens before：销毁必不可能在创建前 as-if-serial：这个单次翻译过来就是“看起来像顺序执行”，也就是说不管你怎么重排序，单线程下执行出来的结果永远不变 再看看hotspot的实现 用的是lock，为什么？因为偷懒，没有针对不同的厂商进行不同的指令，而是汇编lock","link":"/Java%E5%9F%BA%E7%A1%80/volatile/"},{"title":"为毕业做准备","text":"[DONE] 3D数学基础 D3D作业 游戏体验报告 力扣3月勋章 [TODO] 毕业设计 unity3D D3D知识补充 3月悄然离去，这个月（或者说最近两个月）都在忙着-1项目相关的东西，直到前两天才弄完d3d作业，终于有时间写点东西。回顾这段时间，-1项目的作业已经完成了游戏体验、python测验、d3d作业，已经完成3/5了，也终于赶上了标准进度。 群里面大佬们个个都是名校毕业，进度也远超标准，我只敢看不敢出声…大概在上个月底有位同学和我交流作业中遇到的问题，邮件末尾是一张名片，上交大！硕士！旁边还附有学校的logo，我瑟瑟发抖。想到入职以后周围都是来自各个学校的优秀毕业生，想到将来能和一群如此优秀的同学一起学习共同进步，到现在我还是有点恍惚，精彩！自己也会不断努力耳濡目染，加油。 3d数学和d3d作业还是有点难度的，作业要求编写的游戏逻辑并不难，只是d3d本身是比较底层的库，渲染管线、整体流程、各种API，加上各种数学知识，让人难以一下子就琢磨透。即使到现在完成了作业，也只是对其整体渲染流程和开发步骤有了个基本的了解，龙书也只看了一半，还有许多的东西和原理没有搞清楚。将来再慢慢深入研究即可，放上一张我做的简陋的小车吧！ 虽然一直在忙作业，但是作为一个程序员，算法功底还是要有的。本月力扣打卡每日一题终于满了！恭喜自己获得三月勋章一枚！ 这也是我的第一次圆满打卡记录，666，感谢我德硕深夜陪码（感觉gay里gay气的？？） 想想不能每天肝作业，这个月换了个手机，又把王者下回来了，又上了个王者。又想想也不能每天对着电脑和手机屏幕，身边的朋友又都去学校了，现在玩也找不到人，于是每天下午放晴的时候爬爬山，害，就是这么养生！ 最近考研的小伙伴最近都陆陆续续上岸了，现在周围的朋友都是：浙大制药付硕，中大保研王硕，深大计算机德硕，复旦计算机肥硕，我只能说：牛蛙！！恭喜恭喜。 接下来的重心要放在毕业设计，我的Freework招聘平台可是一点都没work。和老师了解到将在6月第一个星期答辩，得抓紧。 还有就是博客的图片放在图床上容易挂掉，准备搭建一个自己的图片服务器，刚好顺便能用在毕业设计上。 想想提前弄完5月份还能有个时间约朋友弄个毕业旅游什么的（嘿嘿嘿）","link":"/life/%E4%B8%BA%E6%AF%95%E4%B8%9A%E5%81%9A%E5%87%86%E5%A4%87/"},{"title":"二分查找模板","text":"本文取自labuladong的算法小抄，并对while结束后的left和right位置做了补充说明，大佬太强了 https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie 所有模板统一采用开区间[left, right]做法 1. 二分查找模板找到返回下标，找不到返回-1 123456789101112public int binarySearch(int[] nums, int target){ int left = 0, right = nums.length - 1, mid; while (left &lt;= right) { //防止溢出 mid = left + (right - left) / 2; //细粒度if if (target == nums[mid]) return mid; else if (target &lt; nums[mid]) right = mid - 1; else if (target &gt; nums[mid]) left = mid + 1; } return -1;} 力扣704 https://leetcode-cn.com/problems/binary-search/ 2. 二分查找最左侧[1,2,2,2,2,3]找最左边的2，也就是下标返回1 1234567891011121314public int binarySearchLeft(int[] nums, int target){ int left = 0, right = nums.length, mid; while (left &lt;= right) { //防止溢出 mid = left + (right - left) / 2; //细粒度if if (target == nums[mid]) right = mid - 1; //不返回而是修改右侧边界 else if (target &lt; nums[mid]) right = mid - 1; else if (target &gt; nums[mid]) left = mid + 1; } //边界判断 if (left &gt;= nums.length || target != nums[left]) return -1; return left;} 3. 二分查找最右侧[1,2,2,2,2,3]找最右边的2，也就是下标返回4 1234567891011121314public int binarySearchRight(int[] nums, int target){ int left = 0, right = nums.length, mid; while (left &lt;= right) { //防止溢出 mid = left + (right - left) / 2; //细粒度if if (target == nums[mid]) left = mid + 1; //不返回而是修改左侧边界 else if (target &lt; nums[mid]) right = mid - 1; else if (target &gt; nums[mid]) left = mid + 1; } //边界判断 if (right &lt; 0 || target != nums[right]) return -1; return right;} 力扣34 https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 4. 循环结束时的left和right如果找不到target，则程序会走到while循环结束后面的语句，此时right会比left小1，left为数字本应该在的位置，因此只需要返回left即可 如：[1,3,5,6] target=2，找不到，则while结束后left=1, right=0 力扣35 https://leetcode-cn.com/problems/search-insert-position/ 12345678910public int searchInsert(int[] nums, int target) { int left = 0, right = nums.length - 1, mid = 0; while(left &lt;= right){ mid = left + (right - left) / 2; if(target == nums[mid]) return mid; else if(target &lt; nums[mid]) right = mid - 1; else if(target &gt; nums[mid]) left = mid + 1; } return left; //返回left即是本来应该在的位置} 其他动态规划的题目可以点击这里","link":"/algorithms/binary-search-template/"},{"title":"九月随笔 似乎一直在做没有意义的事","text":"[DONE] 实习 刷题 [TODO] 校招 实习 实习先说说实习吧，2020.9.28，实习已经快两个月了，国庆8天假，10月底我应该就要走了，剩下的时间不多了。emmm总的来说其实体验还是不错的： 官网项目，不管难度怎样也算是全程跟进，展南、萌萌、学宇可以说非常放心我…这个官网项目虽然简单，但是我作为一个实习生可以说是任我提交，随意操作…好吧，你们都放心，那我自己担心什么。但要说学到什么新技术，我自认为没有多少，期末难度吧 至于生态圈，项目实在复杂，处理也比较谨慎，展南安排任务的时候我总是听的一头雾水，写完还是得叫萌萌code review，发现bug也是先怀疑是不是自己没明白其中的逻辑。总体也还不错，我共发现处理过2个小bug，对接一次测试人员，开发三个接口，其中一个现在还没搞明白。苍穹？我来的时候就叫我搞这个，我走了项目还没开始吧。 说说技术上的收获：最大的收获是git的使用，感谢萌萌的悉心教导，以前用git只是命令行拉取，提交，现在能处理多人开发中的冲突，合并分支问题了。其次是接触了mongoDB，是我接触的第二个nosql，当然得益于mongo丰富的特性和spring data的整合，用起来跟关系型差不多，除了事务和表连接不方便以外，我觉得还是很强大的，性能也高，i了i了。rpc远程调用和k8s持续集成，我还是懵的，因为我一直都是接触的http系的springcloud这块，dubbo和rpc那就算是接触过，也是好的，起码将来学到了可以回想起这么个东西。 其他方面，见识到技术厉害的人，没有人比他更懂java！代码风格和实现思路等潜移默化学到了很多。 后面，实习公司肯定不会留我，毕竟只来两三个月，而且公司也有不好的：和管理的关系有点压抑，反正我不是很喜欢。那就10月底就此别过吧。 感情线有点意外，这件事说起来很复杂，虽然我很高兴有女生关注我这么久，可是没有办法，喜欢是两个人的事，而且她这太卑微了。不养鱼也不需要舔狗，害，程序员的生活总是孤独的。所以没办法了，说了点绝情的话拒绝了，终于算是结束了。 秋招秋招，也就是我最关注的一件事，说实话，这两天一直很焦虑。之前都是很随性的笔试面试，我也没当回事，前天开始看到知乎推送秋招快结束，0offer怎么办之类的。我开始正视这个问题，说来好笑，机会似乎慢慢离开了，我似乎一直在做没有意义的事，就算我把实习的这个项目做的很出色，又能怎么样？，这个项目吧，其实就算我一个人拿来练手，自己做完前后端，我应该也不会有什么成就感，而我现在最要紧的应该是秋招。我开始紧张，开始慌乱，本来就是很懒散的一个人，要是我给自己一个评价就是：我自己都没有欲望找工作，怎么能找到工作？说笔试吧，我的算法水平呢，中等吧，笔试不足，比下有余。可是每场笔试，我总是慢悠悠的做题，偶尔还发会呆，我吐了。总结：废人一个，真是想骂醒自己，再这么下去可就真无缘互联网了。 夜深人静的时候，我写下这些话，成年人的崩溃往往总是一瞬间，看着身边的伙伴保研的成功了，考研的在奋战，工作的收获了offer。而我呢？天天看着这个其实学不到什么东西的官网项目，一调就是一整天。晚上躺在床上看窗外的星星，觉得自己能力不行却又不想努力，心里其实也很难受的，我的未来会是怎么样的？ 没有办法，生活像一把无情刻刀，实习还是得继续下去，只是后面我会把重心放在秋招上，现在我只能化焦虑为动力了，还说再也不碰秋招一道题，草率了，以后我会认真对待每一次笔试，好好总结，争取早日拿到保底offer，加油了，我真的不想掉队。","link":"/life/%E4%B9%9D%E6%9C%88%E9%9A%8F%E7%AC%94%20%E4%BC%BC%E4%B9%8E%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%81%9A%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E4%BA%8B/"},{"title":"八月随笔","text":"八月，踏出一大步 [DONE] 找实习 租房 秋招 [TODO] 秋招（求求了，投多点吧） 补博客（博客这都快废了，有时间把之前的笔记和知乎的那篇文章搬运过来吧） 学项目（crud和业务逻辑大致看看就行了，多关注redis，motan，总体架构的设计这些） 在家堕落的日子疫情已经进入了中后期，7月，我开始为我的未来担忧。疫情在家躺了半年，浑浑噩噩，懒惰的我，每天睡到中午，下午低效学两三个小时，有时候做leetcode算法题难的可能一下午做不出一道，有时候学学spring系列框架，五点出门和兄弟们打球，回家洗个澡，吃晚饭，继续下午的低效学习（不小心掏出了手机），十一点的时候和sai雄出去吃宵夜，晚上一点到家，玩手机两三点睡…在如此规律的作息下，我慌了。 像我这么懒惰且喜欢睡觉的人，完全无法产生朋友圈那种“玩厌了，好想回校”的念头，但是那段时间我总是担心我的未来。大概在7月中旬，我常和sai雄在宵夜场透露我的苦恼，在青爷那里倾诉我的忧愁，但我不愿意带给朋友们太多的负能量，更多的是夜里一个人对着窗外发呆。我担心以我的能力，我的背景，我的出身，我的学历…在毕业后找不到一份能填饱我的肚子的工作（可能我太能吃？且吃不胖？）。 找实习，去深圳总之，在sai雄的建议下我开始在boss直聘上面投了第一份实习简历，那段时间在boss直聘和实习僧上面每天疯狂点击投递，要么没有回应，要么天天有八竿子打不着的营销岗位来找我，有一两家接到面试但是都是要求当面面试。人在韶关，刚下床。我怎么第二天到广州深圳去面试嘛？也不知道那些没有回应的公司是hr为了kpi指标还是我的能力达不到要求。当时也正好看完“黑马乐优商城”最后一节视频，我接到了云之家的面试通知，也就是我现在的导师展南。 这是我的第一个且是最后一个视频面试，我还隐约记得当初展南问我的几个问题： ArrayList和LinkedList的区别（我解释了他们的结构区别，操作上的性能区别） 函数重写override和重载overload（讲了他们的使用方式，继承，参数类型或者个数或者顺序什么的） 线程的状态（他之说对线程的理解，这就很大范围，在他的提示下我重点讲了这个） 多线程的实现方式（Thread，Runnable，Callable，线程池，介绍了一下他们的区别） 死锁（没答好，稀里糊涂居然描述了一下哲学家进餐问题…） java种的内存（我解释了jvm的内存模型，抛出什么异常） 集合类型（List，Set，Map，现在看来，答的很差，分类都没分好，至少应该Map和Collection同一级） MySQL的事务的特性（提示了一下才想起来问的是ACID，但我也只是说了ACID的中文…） 事务隔离界别（没答出来） MySQL优化（我只说了索引，查询快但是增删慢，但是我是入职后才真正用到索引进行优化） Spring的IOC和AOP（这个我描述的不清楚，其实就算是现在我也描述不清楚，但是原理我是理解的，可以看我的Spring相关博客） 项目中的秒杀如何实现的（我说用redis） 项目中用MQ做什么（只有乐优商城用了mq，我直接解释了乐优商城的内容，用来更新商品的时候发送消息让其他模块一同更新保持同步什么什么的） 别看问的多，我觉得是因为我答得少……总之，云之家的速度很快，投递简历后两天约面试，面试完当天下午我就出发和家里人去珠海玩，当天就接到了offer。不高，120/天，一个月除去周末算下来2700这样子，但是我还是很开心，因为我那时候的状态不拉自己一把就没了。 珠海玩了两天我直接去了深圳没有回家，只有一个背包几套衣物，住同学家后来住亲戚家再后来租了蛋壳公寓。我算了算，其实一个月估计得倒贴…尤其第一个月 这个月如此特殊8.3我来到云之家，那天他们很忙在开会，我就在前台等hr，等了半个多小时，我以为还有hr面，结果她来了就开始签合同…实习生活开始了 第一个星期：求爷爷告奶奶的要权限，这个不对那个不懂，装个软件启动项目都碰壁（不是我的问题，公司电脑真的什么环境都没有，装起来缺这个缺那个，第一天好第二天又有问题…），我记得那时候弄得我自己都乱了，展南说看下环境变量我居然愣了一下：什么环境变量，他噗嗤笑了一下（可能觉得自己被骗了，招了个背面经的进来？），算了，反正本来就不强，让大佬觉得自己弱后面安排点轻松的任务岂不是美滋滋？ 花了很大功夫启动好了，哇这个代码量是不是太大了，随便点开一个类5000多行？怎么看得完，那么多奇奇怪怪的id，弄懂我都离职了，包怎么这么多！git？命令我就只会add，commit，clone和push，之前都是一个人哪里懂解决冲突。mongo？我没用过咋整。100多张表!我人傻了… 第二个星期：东看看西看看，算了，一时半会也搞不明白。接到的第一个任务是测试一个接口，给个接口告诉我在哪个类里面，那部分crud弄懂了就行。 左边是一个后端妹子，萌萌（不是外号），有问题我就去烦她，谁叫我是实习生，我菜我有理！好奇一些实现细节又被复杂的逻辑搞蒙？问萌萌；如何同步代码解决冲突合并分支使用git工具？问萌萌；代码报各种错误，各种环境各种隐藏操作奇怪逻辑？问萌萌；为什么不问展南？我莫名有点怕他（可能当初面试没答好），虽然抛开工作，吃饭的时候我跟他谈笑风生… 我特别喜欢我的座位：左边后端，右边前端，对面产品。这个位子，堪称坐北朝南，风水宝地！我愿称之为实习生学习专用位！！我找不到入口就问前端，弄不懂类就问后端，偶尔偷听产品就能知道大家目前在搞什么，绝了！还有就是，三个都是妹子？？我们班40个人也才两个妹子…恍惚觉得有点不科学！ 第三个星期：我终于开启了知乎实习生状态：中午吃啥，晚上吃啥…倒不是说技术完全弄懂了，其实弄不懂也没啥，安排的任务能有多难，难的也不敢安排给你一个实习生，写写crud极限了，一些技术栈和自己学的不匹配又如何，要写一个接口，在同一个类里面找找类似的，参照着写一个就完事了。公司有早报制度，每天写DONE和TODO（本文开头就是从那里学来的，又学到了，开心！），我还担心完成的太快没东西写，写完了我也分两天，第一天排查/编写，第二天测试之类的，不然没任务，TODO都没得写，多尴尬！ 跟部门的人玩的熟了，学宇大佬（早我一个星期跳槽过来）教我一门秘技！绝了！学宇牛逼，我快乐了 第四个星期：没事找展南要个简单点的任务，展南挺负责，对我相当好，跟我交流生活上学习上工作上的问题，安排的任务也从开始的测试一下接口，到编写接口，慢慢的给我对接测试人员，不放养让我进步很快涉及到跨部门的沟通确实难搞。 特别鸣谢这个月真的跟以往任何一个假期都不一样，整个人推着就这样稀里糊涂的向前走了。这个实习确实开始的太晚了，这样我就必须逃课完成实习，期间学校那边也出了很多问题。我不知道这个选择是否正确，但是就目前情况来看，我不后悔，不仅是因为工作代替了颓废，而且是在这之前，在这期间，遇到许许多多可爱的人。 sai雄：开心时能叫我打球上分，失落时能陪我渡过灰暗的日子，调侃时能在宵夜场疯一把并给我建议 青爷：感谢青爷一路的陪伴，在我青春岁月留下痕迹。朋友也好知己也罢，在将来漫长的人生路上，酸甜苦辣一同分享。愿友谊长存，共勉 展南：我的导师，我还记得招聘公告上那句“90后激情团队”…确实非常年轻有才华。工作上给我合理的分配工作，不会太难又能学到东西，并且渐渐深入，慢慢的也开始对接测试人员，独立完成一些简单的功能，让我切实的体会到了自身的成长，以及快速的融入公司的运作体制。生活中也非常照顾我，午饭时间会谈及学业和过往，让我了解到自己和大佬的差距！ 萌萌：专业的东西就是问她了，业务是真的熟练啊，代码风格也好，经常会从她的代码中发现一些意外的惊喜，比如写注解、用stream流等，很多“虽然我会但是我从来没想过要用”的东西真正的被应用到了工程实践中。说来我也经常烦她，问的最多的也是她，有时候在我这里耽误的时间比她自己的工作时间还多，在此表示感谢。一开始我还觉得很高冷，自从给我发了一个牛啤表情包，发现事情并不简单。总之：太强了 德龙：你头发到底是怎么保养的？？教教我 黄琴/佳捷：虽然工作内容我看不懂，但并不影响你们中午吃饭时吐槽带来的无限欢乐，让中午的饭堂内外充满了欢快的气氛。刚入职的时候我觉得其他人都挺高冷，唯独这两位让我感受到展南说的“90后激情团队”…啊哈哈哈哈哈，这个说的可能就是你俩？ 学宇：嘿嘿，能和我玩的最欢的就是他了，各种那啥操作可太秀了！第一回跟我说的时候我人都直接傻了，不得不说带我领略了一片全新的国度，让我顿悟了工作的最高境界！！这不是技术厉不厉害的问题，他真的就是 非常的牛逼的那种 华刚：华刚先生是我的合租舍友，感谢三个月以来对我的照顾，像个兄长一般带我爬山游玩，分我零食，给我添菜（厨艺真不错！）。在深圳这个陌生的城市让我感受到关怀，重要的是在和华刚的交流中开阔了视野，给我传授许多工作的经验，未来的规划，社会的现象，深圳的发展，经济的走势…每一次和华刚先生谈天阔地都宛如一场视野的升华，并将在今后的生活中影响着我 spring data：虽然您不是人，但您依然可爱，得益于您全家，给用户提供的模板，让我在spring data jpa/redis/elasticsearch/mongo之间自由切换，给您拜个早年","link":"/life/%E5%85%AB%E6%9C%88%E9%9A%8F%E7%AC%94/"},{"title":"分布式锁","text":"1. 前言网上看到一个网友的评论：现在本科应届毕业生都要求会分布式了吗？ 真的太卷了！！！学不动了 听这个概念也很久了，而且其实我对分布式的学习也没那么深入…可是面试又要问，害！ 先说说这个东西吧，本来单体应用情况下，我们经常说线程安全，于是出现了锁和同步的一系列操作(synchronized啊，Lock啊，JUC啊之类的)，数据库方面也出现了事务的隔离性。现在问题是分布式场景，集群环境，实际上开了多个进程，那么java的这些并发相关api就无能为力了，只能借助一些第三方的工具，所有的服务器都通过这个第三方来获取锁。 这就叫分布式锁，目的是为了保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行 目前分布式锁的三种主流实现方式 基于数据库 基于redis 基于zookeeper 目的： 可以保证在分布式集群下线程安全，同一个方法在同一时间只能被一台机器上的一个线程执行。 这把锁要是一把可重入锁（避免死锁：同一个线程同一次事务访问同一行两次，拿不到锁） 有高可用的获取锁和释放锁功能（加锁失败能重加，解锁失败能让锁过期） 获取锁和释放锁的性能要好 2. 基于数据库的分布式锁2.1 基于表（乐观锁）实现： 就是记录一张lock表，加锁：添加一条记录，有当前线程名和锁定的方法名。解锁：删除这条记录。 注意事项： 针对线程安全问题：锁定的方法名这一个字段当然要unique，否则失去意义（只能一个线程执行一个方法） 针对可重入问题：请求锁时除了要判断该方法是否已经存在以外，还要判断是否就是本线程，是则直接return true 好处和问题： 数据库挂掉：需要多个数据库备份和同步 针对加锁失败：insert插入失败，没有获得锁，就直接回滚事务不能后续，解决办法是while循环一直请求到成功才return 针对解锁失败：delete解锁可能失败，没有失效时间，导致记录一直在数据库中，之恶能定时任务清理该表 2.2 基于排他锁（悲观锁）实现： 表和上面一样，加锁：connection.setAutoCommit(false);开启事务但不提交，加锁语句为select * from lock where method_name = xx for update。解锁：connection.commit(); 注意事项： 针对线程安全问题：for update是mysql的innodb一种行锁排他锁实现，因此一定要引擎支持行锁，且必须加唯一索引才会走行锁，否则锁表 针对可重入问题：同上 好处和问题： 不存在加锁失败问题：因为for update失败会阻塞直到成功 不存在解锁失败问题：因为锁并不是插入的数据，而是事务，出错了会回滚，数据库会把锁释放掉 性能问题：有时候sql优化器优化了，表太小时不走索引，导致锁表，影响其他方法的进行 性能问题：事务长时间不提交的性能问题，同时占用连接池 2.3 总结容易理解，性能有问题，考虑的多了写起来越来越复杂。不推荐 2. 基于redis的分布式锁实现： 这个最简单，就是一条记录key: 方法名 value: 当前线程 注意事项 针对加锁失败问题：要while循环，同上 针对解锁失败问题：要记得设置过期时间 针对可重入问题：同上，判断是否本身 问题： 解锁失败可以通过过期时间来完成：但是过期时间设置多少呢？少了可能事务没完成就过期了，线程不安全。多了的话虽然安全，但是如果真的解锁失败，要白等很久 总结： redis可以简单的部署集群，而且支持过期时间，解决了可用性的问题，而且性能也好，问题就在于过期时间的设置 3. 基于zookeeper的分布式锁实现： 虽然我没用过zookeeper，但是这个点还是看过，基于临时有序节点，加锁：添加有序节点，解锁：删除有序节点。可以直接使用zookeeper第三方库Curator客户端，这个客户端中封装了一个可重入的锁服务。 总结： 针对线程安全问题：没问题，zookeeper本身就是为了一致性 针对可重入问题：没问题，创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果不一样就再创建一个临时的顺序节点，参与排队。 针对加锁失败：没问题，本身就是阻塞的，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁 针对解锁失败：没问题，临时节点在session断开时自动删除 本文参考： https://www.cnblogs.com/austinspark-jessylu/p/8043726.html redis部分的实现参考： https://www.cnblogs.com/barrywxx/p/11644803.html","link":"/SpringCloud/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"title":"回溯模板","text":"从大佬那里学的https://zhuanlan.zhihu.com/p/93530380，再加上自己做题过程中的一些心得 模板伪代码（python看起来简洁一些） 1234567891011result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 剪枝 做选择 backtrack(路径, 选择列表) 撤销选择 需要注意的几点： java中由于路径通常是引用类型，所以在加入结果集的时候往往需要new一下，以免路径改变时将res里面的元素也一起改变 java/c++中，选择列表往往会通过一个index来代表到了哪个位置，而保持总列表nums的不变性，至于python和js，天生list就是可变的，append和remove并不会造成太大的开销，所以选择列表可以变而不需要index变量记录 总体框架不变，但是有时候for循环可以使用枚举代替（上下左右方向） 去重用Set，不要每次加入前判断list.contains，那样很慢 1234567891011121314151617private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //外面一个变量记录结果public void backtrace(int[] nums, int index, List&lt;Integer&gt; track){ if (结束条件){ res.add(new ArrayList&lt;&gt;(track)); //加入结果时要new，否则所有路径变成最后一个的引用 return ; } for (选择 : 选择列表) { //剪枝 if (不满足条件) continue; //做选择 track.add(nums[i]); //递归 backtrace(nums, i + 1, track); //撤销 track.remove(track.size() - 1); }} 毋庸赘言，直接结合回溯题目一起看，看几题就明白了","link":"/algorithms/backtrace-template/"},{"title":"反射和类加载器","text":"1. 程序运行阶段 代码阶段（硬盘阶段）：比如编写一个Person.java，编译成字节码Person.class，这都是存在硬盘的，而程序运行是要在内存中的 类加载器ClassLoader阶段：在第一阶段和第二阶段中间，也就是本文要讲的内容，先卖个关子，知道有这个阶段 Runtime运行时阶段：也就是new Person()，那么此时已经在内存中 2. “第二阶段”：Class类对象阶段通过第一第三阶段，可以推测出第二阶段其实是把硬盘上的class文件加载进内存变成java可以识别的内容（术语叫做Class类对象）的过程，随后第三阶段便可读取。那么究竟是如何做的呢？ 在这个阶段会把Person.class（泛指所有.class文件）文件分解成三部分加载进内存（当然不是加载成Person这个类，程序没有new，java是不知道你要什么类的，所以他是加载成上面说的统一的“Class类对象”），这个对象包括了三个东西： Filed[] fields：里面存放.class分解出来的成员变量 Constructor[] cons：存放构造方法 Method[] methods：存放成员方法 这个从.class文件分解为各个部分并封装为Class类对象的过程其实就叫反射 这不是很抽象的东西，来个具体应用举例：idea对着一个String对象敲下.，会提示chatAt等一堆可以用的方法，这方法从哪来？idea内部判断了String然后提示？怎么可能，其实这就是运用了反射，读取了Method[]列表，显示出来。可以把idea看作是一个运行中的java程序，因此反射可以在运行的时候获取类的信息 3. api既然知道了反射就是为了获取”Class类对象“（再次重申，不是Person类对象，他就叫Class类对象！！），那么我们可以看如何获取了，刚刚说了三个阶段，那么每个阶段都有对应的api用于获取Class类对象。 Class.forName(“全类名”)：第一阶段，将字节码文件加载进内存，返回Class类对象（全限定类名：包名+类名，这个阶段没有类名，因此必须手动写全限定类名，） 类名.class：第二阶段，通过类名的class属性获取（这一阶段jvm已经加载好了，知道了类名，因此需要的话只要直接用类名.属性名就可以了） 对象名.getClass()：第三阶段，这时候你已经new Person()了，已经有对象了，getClass()是Object类提供的方法，因此你的Person类必有这个方法 12345//1.自己写一个Person类，随便给个name和age属性，略Class cls1 = Class.forName(\"com.wjw.domain.Person\");Class cls2 = Person.class;Person person = new Person();Class cls3 = person.getClass(); 同一个字节码文件只会被加载一次Class类对象，三种方式获得的地址都是同一个 4. 双亲委派机制如果自己建立一个名为java.lang.String的包和类，能不能替换掉真正的String类呢？答案是不行的。 ClassLoader有三种 BootstrapClassLoader ==&gt; $JAVA_HOME/jre/lib ExtClassLoader ==&gt; $JAVA_HOME/jre/lib/ext AppClassLoader ==&gt; 第三方和自己项目下的类 所谓双亲委派机制，就是当程序读取String的时候，先从BootstrapClassLoader开始，层层往下读取，如果能够加载String，那么交由该类加载器加载，如果到AppClassLoader都没有发现该类，会报ClassNotFoundException String在$JAVA_HOME/jre/lib/rt.jar下，所以被BootstrapClassLoader加载。 需要查看是什么类加载器，Class类提供了getClassLoader()方法，如下 12Person p = new Person();System.out.println(p.getClass().getClassLoader()); 如果要看上一级，就通过类加载器的getParent() 1System.out.println(p.getClass().getClassLoader().getParent()); 要注意的是，由BootstrapClassLoader加载的类getClassLoader()会为null，不是没有该类（没有会报错），而是显示不出来，已经去了c写的native里面","link":"/Java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"title":"字符串中的成对括号问题处理技巧","text":"1. 前言遇到成对括号问题，我相信大家第一个想到的就是栈，因为我们自从翻开严蔚敏的《数据结构》开始，就习惯于将“栈”和“成对括号”联系起来。 其实还是挺麻烦的，遍历一遍，遇到(入栈，)出栈，最后判断栈是否为空，中间还夹杂着一些其他技巧（栈底是)就直接结束之类的）。诚然，这是一个好方法，但是做题的时候讲究快速编写，研究的时候才讲究快速运行，而且通常题目不仅仅考括号匹配，括号只是题目的一部分，这时候，我们写起来就比较复杂。看我这新思路！ 2. api用的越熟，写起来就越轻松！这是我在牛客某一题看到的，叹为观止，真的对api了然于心，后来又遇见了一道题，自己试了一下，发现异常好用，因此记录下来。 先看这两个大家很熟了 int IndexOf(String str)：字符串中查找某个字符的第一次出现下标，没有则返回-1 int lastIndexOf(String str)：也是找下标，但是是最后一次出现的下标，没有则返回-1 奇妙的是，他们的重载方法，这两个参数！ int indexOf(String str, int fromIndex)：第一次，从指定位置往后找，没有则返回-1 int lastIndexOf(String str, int fromIndex)：最后一次，从指定位置开始反向搜索，没有则返回-1 认真观察，你就会发现…OHHH！！！搭配以下绝了，括号匹配思路：可以先找到第一个)，然后从这个)开始往前找(，绝了！！！匹配上了，一定是最靠近的一对 12int r = str.indexOf(\"]\");int l = str.lastIndexOf(\"[\", r); 无需考虑是否嵌套括号((())())！！！这两行代码一定是找到最内层最左边那个！！简直将java的api完美的使用上了，这得对api多熟练啊！！ 3. 最喜欢的实战环节3.1 腾讯2020春招后端-压缩算法 原题链接https://www.nowcoder.com/test/question/c27561e5b7e0441493adb9a54071888d?pid=21283868&amp;tid=37272348 题目： 小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为m|S，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？ 输入描述: 12345输入第一行包含一个字符串s，代表压缩后的字符串。S的长度&lt;=1000;S仅包含大写字母、[、]、|;解压后的字符串长度不超过100000;压缩递归层数不超过10层; 输出描述: 1输出一个字符串，代表解压后的字符串。 输入例子1: 1HG[3|B[2|CA]]F 输出例子1: 1HGBCACABCACABCACAF 例子说明1: 1HG[3|B[2|CA]]F−&gt;HG[3|BCACA]F−&gt;HGBCACABCACABCACAF 题解： 为了简洁，这里除去了main部分，只给出核心函数 1234567891011121314151617181920212223/** * 思路：直接字符串替换，但是要注意从内层开始，看你的String类api掌握程度了 */public static String zxvf(String str){ //找最里面那对括号位置 int l = 0, r = str.length() - 1; if (str.contains(\"]\")){ //妙的开始 r = str.indexOf(\"]\"); l = str.lastIndexOf(\"[\", r); }else { return str; } //截取字符串并替换 String words = str.substring(l + 1, r); //妙的结果 String[] split = words.split(\"\\\\|\"); int time = Integer.parseInt(split[0]); String word = \"\"; for (int i = 0; i &lt; time; i++) { word += split[1]; } str = str.replace(\"[\" + words + \"]\", word); return zxvf(str);} 你细品，注释里面标明的妙的地方，非常方便 3.2 小红书2020校招测试开发&amp;后端笔试题卷三 原题链接https://www.nowcoder.com/question/next?pid=23567650&amp;qid=982135&amp;tid=37272851 题目： 薯队长写了一篇笔记草稿，请你帮忙输出最后内容。 1.输入字符包括，”(“ , “)” 和 “&lt;”和其他字符。 2.其他字符表示笔记内容。 3.()之间表示注释内容，任何字符都无效。 括号保证成对出现。 4.”&lt;”表示退格, 删去前面一个笔记内容字符。括号不受”&lt;”影响。 输入描述: 1输入一行字符串。长度&lt;=10000. 输出描述: 1输出一行字符串，表示最终的笔记内容。 示例1： 输入 1Corona(Trump)USA&lt;&lt;&lt;Virus 输出 1CoronaVirus 题解： 由于是acm模式，我直接贴出完整代码 1234567891011121314151617181920import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String note = sc.nextLine(); StringBuilder sb = new StringBuilder(); while (note.contains(\")\")){ //去掉注释 int r = note.indexOf(\")\"); int l = note.lastIndexOf(\"(\", r); note = note.replace(note.substring(l, r + 1), \"\"); } while (note.contains(\"&lt;\")){ //退格 int idx = note.indexOf(\"&lt;\"); note = note.replace(note.substring(idx - 1, idx + 1), \"\"); } System.out.println(note); }} 其实没什么原理，api摆在那，看你熟不熟练罢了，要是知道这个api搭配的话，做这题是很轻松的。那么对于括号匹配问题：while循环判断是否contains(“)”)，只要有就replace为空串，最后判断整个字符串是否为空即可，应该都有思路了吧。","link":"/algorithms/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%88%90%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/"},{"title":"大创论文","text":"大创相关的工程我是没有上传到github的，太麻烦了，效果就就直接摆在博客里好了 2019.04-2020.04 感谢团队小伙伴共同奋斗，从申请立项，到答辩流程，项目编写，论文攥写，软著申请。虽然我们是个小团队，会议也是不出名的辣鸡会议（逃~），但无论如何，算是我平凡的大学生涯中为数不多的精彩。 也很感谢团队指导老师苏静，为人和蔼亲切，给本科生参与科研的机会，愿意尽力所能及之力帮我们拿到诸多资源。 录用通知 项目关键部分展示登录页面 数据管理页 模型和因素选择 训练效果和模型对比 最近很火的网红算法Xgboost 预测效果 简单而形象的架构设计！ 感慨真的很开心，虽然学校有很多大佬，本科就好几个软著好几篇论文甚至还有顶会…我们也比不了。作为一名平凡的学子，那时候才大二大三，编程能力要说有多好简直是放屁，java也才学了没多久，真正的纯萌新小伙伴。从听说人工智能很牛逼，带着好奇自学python和斯坦福的cs231n课程，对神经网络有个有了大概的了解。 说起来很梦幻，大二下学期选导师，嘉鸿的导师也就是苏静老师，在搞nlp相关的东西。一天中午把我们几个叫出去，还叫了几个师兄，就这样组了个团队，可是师兄都准备秋招了，而且他们也没有搞过神经网络相关的东西。得，我们成了第一批核心成员？我们相比其他技术团队，没有师兄，没有经验，没有资源。 后来就是学习模型和框架，什么bp、cnn、rnn、lstm，也接触过sklearn、tensorflow，pytorch，opencv，概念很多，很晦涩难懂，什么梯度下降，数据集，epoch，交叉验证，loss损失，真的听个一知半解的，随之而来的是一些经典的网络结构和模型，vgg16，fastrcnn系列、ssd系列、mtcnn、mobilenet、resnet、yolo系列，都基本上只是知道有这么个东西，太多了。那时候概率论还没学，学校教的线代往往不够用，而且还要兼顾学校课程。 一开始是跟着老师搞image-caption的，也就是输入一张图像，能给出一句描述，那时候attention机制很火，加上老师本身就是搞nlp的，我们就帮她处理一些数据上的东西（打个经纬度标注什么的），老师想弄成一系列图片，生成一篇语意连贯的文章这样，idea确实很精彩，我听得都觉得很精彩，不过这事后来没消息了，不知道他们自己有没有继续搞，论文有没有发成功，将来有机会，我还想做这个！！！。老师后来也说了，搞研究方向的可能毕业了也没有成果，况且训练模型没有资源，玩具模型拿个笔记本跑啊跑，大一点的远程连接老师的服务器（好像是1080），老师就说：做应用吧。 其实我内心还是很佩服嘉鸿的，如果换成是我，这团队组不起来，嘉鸿是很有领导能力做事很靠谱的，而靠谱是我对一个人的最高评价（我就不可靠），嘉鸿可能不是编程能力最强的那个，但他肯定是最适合带队的那位。在我们都还不成熟的情况下，远见性的提出参加大创比赛，做水质决策。那段时间就是申报项目，和水产学院学生要数据（所谓广东海洋大学，比赛或者什么项目搭上了水产这条线，是很吃香的），这应该也是省级立项的很大一部分原因，嘉鸿这方面考虑还是很精妙的。 后来就是这个了，零零散散的参考了网上不少的东西，拼拼凑凑，修修改改，总算弄出个像样的东西，也加入了不少特色功能，嘉鸿对数据进行了处理（水产学院的学生记录数据能不能用点心！），我将数据放到了我的华为云（薅羊毛薅的，毕竟不用钱！），模型这块主要是嘉鸿在做，处理成sklearn的数据格式，我也帮忙写了一部分，处理了部分模型上的时间问题。结构上，模型这块紧紧围绕： 多因素交叉预测单因素 多模型对比 模型融合和提出择优算法 文德和慧玲的中途加入，我后来也转向了java后台，web这边是我和文德在搞，web这边封装数据给python，用于模型的训练和预测，逻辑上有交叉，数据处理起来比较困难。因为是水质决策和预警，文德不了解模型，嘉鸿不了解后台，只有两边我半斤八两！我又将水质预警功能嵌入在模型训练的评价之后，后来又加入了特色的邮件提醒功能小彩蛋…慧玲前端，让整个项目的视觉效果提升了不少，明杰负责主要论文编写，大家一起慢慢的就做完了。 真的很感概，团魂max，在大学也拼过也闯过，不至于是个碌碌无为的四年。","link":"/Others/%E5%A4%A7%E5%88%9B%E8%AE%BA%E6%96%87/"},{"title":"对1000000007取模和0x3f3f3f3f","text":"1. 结果可能很大的题目会要求对1000000007取模(1八个零7)，为什么？最终我在柳神的博客下找到了答案 1000000007是一个质数（素数），对质数取余能最大程度避免冲突 int32位的最大值为2147483647，1000000007同一个量级，足够大 int64位的最大值为2^63-1，对于1000000007来说它的平方不会在int64中溢出 所以在大数相乘的时候，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出 柳神说她猜的！https://www.liuchuo.net/archives/645 论述生动，内容充分，细节丰富，令人信服！反正我信了 2. 有些题解不是用Integer.MAX_VALUE而是0x3f3f3f，为什么？ Java提供了Integer.MAX_VALUE，Integer.MIN_VALUE，c++在climits头文件也有同样的符号定义，这两个的值通常是为了初始化比较值 12345int max = Integer.MIN_VALUE;···while(){ max = Math.max(a, max);} Integer.MAX_VALUE值就是int的最大值，也就是0x7fffffff（7七个f），即2,147,483,647 有些题目不仅仅是要比较，还需要其他运算，如果进行了+1，那就会溢出成负数。因此有的acmer会采用0x3f3f3f3f，满足“无穷大加无穷大依然是无穷大”，这个设置非常精妙 0x3f3f3f3f足够大，十进制是10^9仍然和0x7fffffff在同样的数量级 0x3f3f3f3f+ 0x3f3f3f3f结果仍在32-bit int的表示范围之内，满足了“无穷大加无穷大还是无穷大”的需求 意想不到的额外好处：c++中通常会使用memset(a,0,sizeof(a))这样的代码来将数组清零，因为memset是按字节操作的因此非常高效，它能够对数组清零是因为0的每个字节都是0。但是当我们想将某个数组全部赋值为无穷大时就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。至于Java尚不清楚Arrays.fill(arr,0);仍然是循环","link":"/algorithms/%E5%AF%B91000000007%E5%8F%96%E6%A8%A1%E5%92%8C0x3f3f3f3f/"},{"title":"我的FastIO工具类","text":"前言：Java做算法题的弊端，力扣只需要完成一个函数，其他oj平台要求使用Scanner类在控制台输入输出，其中pat最后一个测试用例是大量数据，因此java在pat中经常超时，这时候可以采用带缓存的reader和buffer而不是System.in/out。 这个工具类，复制即可直接食用，都是静态方法，通过FastIO.xx就可以使用 方法名保持和Scanner/System.out一致 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wjw * @date 2020/2/10 13:44 */import java.io.*;import java.util.StringTokenizer;public class FastIO { public static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in),32768); public static StringTokenizer tokenizer = new StringTokenizer(\"\"); public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); public static double nextDouble() throws IOException{ return Double.parseDouble(next()); } public static float nextFloat() throws IOException{ return Float.parseFloat(next()); } public static int nextInt() throws IOException{ return Integer.parseInt(next()); } public static String next() throws IOException{ while (!tokenizer.hasMoreTokens()) { tokenizer = new StringTokenizer(reader.readLine()); } return tokenizer.nextToken(); } public static String nextLine() throws IOException{ return reader.readLine(); } public static void println(String str){ out.println(str); out.flush(); } public static void printf(String format, Object ... args){ out.printf(format, args); out.flush(); }}","link":"/util/%E6%88%91%E7%9A%84FastIO%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"数据结构与算法不迷路导航","text":"所有的系列都在这了，巨坑慢慢填哈，现在已经破百，打算在12月前刷够300（笔试面试比较有信心？），然后博客补一下之前做的 1. 回溯 回溯模板 131-分割回文串 40-组合总和II 60-第k个排列 784-字母大小写全排列 1219-黄金矿工 1291-顺次数 113-路径总和II 2. 动态规划 63-不同路径II 70-爬楼梯以及进化版 121-买卖股票的最佳时机 357-计算各个位数不同的数字个数 2.1 子数组系列 53-最大子序和 152-乘积最大子数组 3. 树不是有意要拆分那几个没有数字的遍历文章，而是套路和难度我认为应该按以下顺序看 404-左叶子之和 Java实现树的前中后序遍历及二叉树可视化 116/117-填充每个节点的下一个右侧节点指针 Java二叉树的层次遍历 根据两序遍历推出第三序以及构建树 297-二叉树的序列化和反序列化（困难） 515-在每个树行中找最大值 654-最大二叉树 4. 栈20-有效的括号 5. 单调栈 42-接雨水（困难） 84-柱状图中的最大矩形 739-每日温度（中等） 496-下一个更大元素 I（简单） 316-去除重复字母（困难） 901-股票价格跨度（中等） 402-移掉K位数字 456-132模式 581-最短无序连续子数组 6. 排序 记一次快速排序探究 56-合并区间 252-会议室 406-根据身高重建队列 7. 字符串 字符串中的成对括号问题处理技巧 5 最长回文子串 3 最长无重复子串 43-字符串相乘 179-最大数 8. 滑动窗口 1208-尽可能使字符串相等 480-滑动窗口中位数 424-替换后的最长重复字符 9. 链表 链表题技巧 206-反转链表 19-删除链表的倒数第n个节点 21-合并两个有序链表 24-两两交换链表中的节点 61-旋转链表 160-相交链表 10. 二分查找 二分查找模板 11. 双指针 11-盛水最多的容器 15-三数之和 19-删除链表的倒数第n个节点 不知道是什么题 54-螺旋矩阵(思维) 136-137-260-只出现一次的数字(位运算) 31-下一个排列(数学) 48-旋转图像(思维) 357-计算各个位数不同的数字个数(dp) 406-根据身高重建队列(排序) 其他 对1000000007取模和0x3f3f3f3f 我的FastIO工具类 计算平方根-牛顿迭代法","link":"/algorithms/algorithms-list-navigator/"},{"title":"手把手从0实现一颗决策树","text":"这是我2019-09-24在知乎上面写的文章，原文跳转点这里，今天面试java不知道为什么面试官感兴趣被提起，提起于是搬运到博客上，纯python实现，除numpy外无第三方库 前段时间数学建模我和我的小伙伴们划了个水，几个没有建模经验的小伙伴临时抱佛脚最后通了个宵，在此感谢我的队友们。抱佛脚的时候笔者对决策树起了兴趣（可惜没有用上），之前看过一点点理论相关的知识，但是没有自己实现过，这几天空下来决定自己从0撸一颗简单的ID3决策树。 由于我也是个新手，因此本篇文章深度有限，大神请绕道^_^，我将着重于代码的实现和整个流程的说明，通过一个案例（案例取自https://blog.csdn.net/mn_kw/article/details/79913786，本文就是对这篇博客中的介绍进行代码实现），带你一步步看懂数据在决策树中的行为，减少理论部分的晦涩知识。快来动手跟我一起实现一颗决策树吧！ 一.什么是决策树 现想象一个女孩的母亲要给这个女孩介绍男朋友，于是有了下面的对话：女儿：多大年纪了？母亲：26。女儿：长的帅不帅？母亲：挺帅的。女儿：收入高不？母亲：不算很高，中等情况。女儿：是公务员不？母亲：是，在税务局上班呢。女儿：那好，我去见见。这个女孩的决策过程就是典型的分类树决策。（声明：此决策树纯属为了写文章而YY的产物，没有任何根据，也不代表任何女孩的择偶倾向，请各位女同胞莫质问我^_^）例子取自https://blog.csdn.net/mn_kw/article/details/79913786 假设现在有这么一张表，统计了一些人的择偶标准，称为训练样本 我们将要对其构建类似如下的判断分支结构，这就叫决策树。之后再有一组样本，我们就可以根据这棵树来判定嫁不嫁啦！ 看到这里你肯定会有个疑问：为什么先判断高不高？难道真是传说中的一高遮百丑吗？ 当然不是，我们可是有依据的！这个依据就叫做信息增益（Gain），公式如下，就是两个函数相减而已，看不懂也没关系，下面有例子说明。 )H(x)叫香农熵，H(D|x)叫条件熵&lt;br&gt;就两个函数相减而已 其中H(x)和H(Y|X)长下面这样 )p(x)是概率，比如矮占身高的 里面的H 如本例中:一开始嫁的个数为6个，占1/2，那么信息熵H(X)为-1/2log1/2-1/2log1/2 = -log1/2=1现在假如我知道了一个男生的身高信息。身高有三个可能的取值{矮，中，高}矮包括{1,2,3,5,6,11,12}，嫁的个数为1个，不嫁的个数为6个中包括{8,9} ，嫁的个数为2个，不嫁的个数为0个高包括{4,7,10}，嫁的个数为3个，不嫁的个数为0个先回忆一下条件熵的公式如下：我们先求出公式对应的:H(Y|X = 矮) = -1/7log1/7-6/7log6/7=0.592H(Y|X=中) = -1log1-0 = 0H(Y|X=高） = -1log1-0=0p(X = 矮) = 7/12,p(X =中) = 2/12,p(X=高) = 3/12则可以得出条件熵为：7/120.592+2/120+3/12*0 = 0.345那么我们知道信息熵与条件熵相减就是我们的信息增益，为1-0.345=0.655所以我们可以得出我们在知道了身高这个信息之后，信息增益是0.655 结论我们可以知道，本来如果我对一个男生什么都不知道的话，作为他的女朋友决定是否嫁给他的不确定性有1.0这么大。当我们知道男朋友的身高信息后，不确定度减少了0.655.也就是说，身高这个特征对于我们广大女生同学来说，决定嫁不嫁给自己的男朋友是很重要的。至少我们知道了身高特征后，我们原来没有底的心里（1.0）已经明朗一半多了，减少0.655了（大于原来的一半了）。那么这就类似于非诚勿扰节目里面的桥段了，请问女嘉宾，你只能知道男生的一个特征。请问你想知道哪个特征。假如其它特征我也全算了，信息增益是身高这个特征最大。那么我就可以说，孟非哥哥，我想知道男嘉宾的一个特征是身高特征。因为它在这些特征中，对于我挑夫君是最重要的，信息增益是最大的，知道了这个特征，嫁与不嫁的不确定度减少的是最多的。取自https://blog.csdn.net/mn_kw/article/details/79913786 二.代码实现1.咱们先来构建我们的数据，我用的是python3(day1) 表头 1datas_header = ['是否帅', '脾气是否好', '是否高', '是否上进', '结果'] 数据 12345678910111213import numpy as npdatas = np.array([['帅', '不好', '矮', '不上进'], ['不帅', '好', '矮', '上进'], ['帅', '好', '矮', '上进'], ['不帅', '爆好', '高', '上进'], ['帅', '不好', '矮', '上进'], ['帅', '不好', '矮', '上进'], ['帅', '好', '高', '不上进'], ['不帅', '好', '中', '上进'], ['帅', '爆好', '中', '上进'], ['不帅', '不好', '高', '上进'], ['帅', '好', '矮', '不上进'], ['帅', '好', '矮', '不上进']]) 标签 1labels = np.array(['不嫁', '不嫁', '嫁', '嫁', '不嫁', '不嫁', '嫁', '嫁', '嫁', '嫁', '不嫁', '不嫁']) 2.明确代码流程，自顶向下设计，自底向上实现 3.实现香农熵 1234567891011121314151617181920def get_shannon_entropy(labels: np.ndarray) -&gt; float: &quot;&quot;&quot; 计算香农熵 即H(X)=−∑(i=1,n)pi * log2pi :param labels: shape = (n, )，n个标签 :return: float香农熵值 &quot;&quot;&quot; num_labels = len(labels) labels_dic = {} # 考虑到labels不一定是数字，我们用字典来装 shannon_entropy = 0 for label in labels: # 统计各label个数，本例中最后labels_dic格式为{&quot;嫁&quot;:6, &quot;不嫁&quot;:6} if label not in labels_dic.keys(): labels_dic[label] = 0 labels_dic[label] += 1 for i in labels_dic.keys(): prob = labels_dic[i] / num_labels shannon_entropy += - prob * np.log2(prob) return shannon_entropy 4.实现条件熵(day2) 1234567891011121314151617181920212223242526272829def get_conditional_entropy(datas: np.ndarray, labels: np.ndarray) -&gt; float: &quot;&quot;&quot; 接下来的条件熵 即H(Y|X)=∑(i=1,n)piH(Y|X=xi) H就是上面的香农熵呀！ Y就是嫁不嫁呀！ X就是当前的特征呀！ 本例中其中一个特征举例：高中矮，则表现为 H(Y|X) = p矮 * H(嫁|X = 矮) + p中 * H(嫁|X = 中) + p高 * H(嫁|X = 高) :param datas:某个特征下所有人的取值，例如['矮', '矮', '矮', '高', '矮', '矮', '高', '中', '中', '高', '矮', '矮'] :param labels:该特征下嫁或不嫁的结果，例如['不嫁', '不嫁', '嫁', '嫁', '不嫁', '不嫁', '嫁', '嫁', '嫁', '嫁', '不嫁', '不嫁'] :return: &quot;&quot;&quot; num_data = len(datas) conditional_entropy = 0 num_class = {} # 先得知道身高特征分成了几类（高中矮3类）,每类占多少 for class_val in datas: # for循环完后结果为num_class = {&quot;矮&quot;: 7, &quot;中&quot;: 2, &quot;高&quot;: 3} if class_val not in num_class.keys(): num_class[class_val] = 0 num_class[class_val] += 1 for i in num_class.keys(): prob = num_class[i] / num_data index = np.argwhere(datas == i).squeeze() # 以下两句获得datas中'矮'的下标并找出每个'矮'对应的labels值 # print(index.shape) if index.shape != (): # 这里如果不这么处理会出问题，就是index只有一个数的情况,index = 2，type显示ndarray没有问题，shape却显示()而不是(1,) i_labels = labels[index] # 造成这句的结果居然是i_labels = 'no' 而不是['no'],于是在后面遍历的时候变成了'n'和'o'，这不是我们想要的 else: i_labels = list([]) # 通过先限定i_labels的类型，使用append的方式添加，这时候i_labels就会是想要的['no'],后面遍历的时候就是遍历数组中的这一个元素 i_labels.append(labels[index]) conditional_entropy += prob * get_shannon_entropy(i_labels) return conditional_entropy 5.获得最佳信息增益gain值和对应特征 12345678910111213141516171819def get_best_gain(datas: np.ndarray, labels: np.ndarray) -&gt; (float, float): &quot;&quot;&quot; 计算信息增益，并找出最佳的信息增益值，作为当前最佳的划分依据 即g(D,X)=H(D)−H(D|X) H就是香农熵呀！ H(D|X)就是信息熵呀！ best_gain = max(g(D,X)) :param datas: shape(n, m) n条数据，m种特征 :param labels: shape = (n, )，n个标签 :return:返回最佳特征和对应的gain值 &quot;&quot;&quot; best_gain = 0 best_feature = -1 (num_data, num_feature) = datas.shape for feature in range(num_feature): #遍历每个特征，找出到底谁的信息增益值最大 current_data = datas[:, feature] gain = get_shannon_entropy(labels) - get_conditional_entropy(current_data, labels) # 公式 if gain &gt; best_gain: best_gain = gain best_feature = feature return best_feature, best_gain 6.建树(day3) 由于要建树，树型结构就需要建立起来，本来也打算存在数据结构中，但是就在这时候看到了csdn上一篇博客里的树是这样用字典来保存 博客地址https://blog.csdn.net/hongbin_xu/article/details/78516114 我的天！！！惊到我了，学！用字典建树 输入数据变化过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def create_tree(datas_header: list, datas: np.ndarray, labels: np.ndarray) -&gt; dict: &quot;&quot;&quot; get_best_gain()是给一组datas,labels计算一次最佳划分特征 要构建一棵决策树，那必须要在划分完剩下的数据集继续划分(递归过程)，直到以下情况出现： 1.剩下全部结果都是相同的，那么直接作为结果。 如在本例中，假如最佳分组为帅或者不帅，帅对应的labels全部为嫁，则不用继续讨论后面的分组。同理，如果不帅中既有嫁和不嫁，那么需要继续递归 2.遍历完了所有特征，但是还是无法得到唯一标签，则少数服从多数。 假如在本例中，遍历到最后一组特征：是否上进，但上进的组里还是有嫁或者不嫁两种标签，且较多为嫁，那就让她嫁 :param datas_header: :param datas: :param labels: :return: &quot;&quot;&quot; # 结束条件1 if list(labels).count(labels[0]) == len(labels): return labels[0] # 结束条件2 if len(datas) == 0 and len(set(labels)) &gt; 1: result_num = {} for result in labels: if result not in result_num.keys(): result_num[result] = 0 result_num[result] += 1 more = -1 decide = '' for result, num in result_num.items(): if num &gt; more: more = num decide = result return decide cur_best_feature_num, _ = get_best_gain(datas, labels) cur_best_feature_name = datas_header[cur_best_feature_num] # 首先知道该特征下有什么值 本例中class_val = {'帅'， '不帅'} class_val = set([data[cur_best_feature_num] for data in datas]) trees = {cur_best_feature_name: {}} for val in class_val: # 逐一找出每个特征值的数据 本例中表现为含'帅'/'不帅'的数据 new_datas = [datas[i] for i in range(len(datas)) if datas[i, cur_best_feature_num] == val] # 用列表生成式，读作:遍历datas每行，找到每行的'是否帅'特征下值为'帅'的行，返回该行 new_labels = [labels[i] for i in range(len(datas)) if datas[i, cur_best_feature_num] == val] new_datas = np.delete(new_datas, cur_best_feature_num, axis=1) # 删除最佳列，准备进入下一个划分依据，即删掉 new_datas_header = np.delete(datas_header, cur_best_feature_num) # 递归:去掉该行该列再丢进 trees[cur_best_feature_name][val] = create_tree(list(new_datas_header), new_datas, np.array(new_labels)) return trees 7.预测，树建完了，预测时我们就要递归遍历字典(day4) 12345678910111213141516171819def predict_result(trees_model: dict, input_data: np, datas_header: list) -&gt; str: &quot;&quot;&quot; 1.找字典中的第一个划分特征 本例中是'是否高' 2.在datas_header中找到高是第几个特征 本例中是第2个特征 3.在input_data中找到这个特征对应的值 比如要预测的数据中是否高（第二个特征）取值为矮 4.找到字典中的'矮'的值，如果为str(嫁不嫁)，则直接返回结果，如果是字典，则进行下一个节点预测（递归） :param trees_model: :param input_data: :param datas_header: :return: &quot;&quot;&quot; cur_judge = list(trees_model.keys())[0] # '是否高' num_feature = datas_header.index(cur_judge) # 本例中是第2个特征 cur_val = input_data[num_feature] # 比如要预测的数据中是否高（第二个特征）取值为矮 cur_tree = trees_model[cur_judge] # print(type(cur_tree[cur_val])) if type(cur_tree[cur_val]) == np.str_: return cur_tree[cur_val] return predict_result(cur_tree[cur_val], input_data, datas_header) 8.保存和读取模型文件 123456789101112# 保存和读取函数def store_tree(input_tree, filename): import pickle with open(filename, 'wb') as f: pickle.dump(input_tree, f) f.close()def restore_tree(filename): import pickle with open(filename, 'rb') as f: return pickle.load(f) 通过这棵树，我们就知道，帅与否并不是影响你勾搭小姐姐主要的因素，这给了作者足够的自信，好了，我去勾搭小姐姐啦！ 代码已上传github，地址为https://github.com/wjwABCDEFG/wjw-DecisionTree 百度网盘地址为https://pan.baidu.com/s/18O1OpU1hPfHdoAh_qVF1-Q提取码7qdv 零零散散耗时4天，写文章又需要琢磨，感觉说的还不是很清楚，有不懂的可以交流，打算以后有空就实现一些简单的机器学习模型，代码菜鸟，风格不太好，多多包涵，如有错误，欢迎指正。","link":"/deeplearning/%E6%89%8B%E6%8A%8A%E6%89%8B%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%A2%97%E5%86%B3%E7%AD%96%E6%A0%91/"},{"title":"最短作业优先算法(SJF)","text":"就是CPU选择先运行耗时短的任务，比如任务A需要3s，任务B需要5s，那么程序选择先运行A 5个程序ABCDE同时提交给CPU执行（虽然式同时提交，但是有先后，假装A比B快那么一点点的一点点的一点点好了） 作业名 执行时间 A 5 B 5 C 2 D 3 E 4 那么运行顺序为 平均等待时间=(任务开始时间 - 任务提交时间)/n 等待时间 A:9-0 B:14-0 C:0-0 D:2-0 E:5-0 平均等待时间=30/5=6 如果不是同时提交，那么出现非抢占式和抢占式两种情况 非抢占式：同一时间则选择先运行耗时短的任务，不同时间则按照先来先服务(FCFS) 作业名 提交时间 执行时间 A 0 5 B 1 5 C 2 2 D 3 3 E 4 4 0s时：只有A，因此先执行A，因为是非抢占式，所以BCDE提交时即使执行时间可能更短（比如C为2）也只能等待A执行完，A执行完为5s，此时BCDE相当于同时提交，情况和第一种一样，因此顺序是CDEB 等待时间 A:0-0 B:14​-1 C:5-2 D:7-3 E:10-4 平均等待时间=(0+13+3+4+6)/5=5.2 抢占式：新任务提交时，就判断正在运行中剩下的时间和新任务的执行时间，那个短先执行哪个，原任务如果被抢占，则中途暂停 仍然是这个例子 作业名 提交时间 执行时间 A 0 5 B 1 5 C 2 2 D 3 3 E 4 4 1s时：B提交，但是此时A为4，因此继续运行A 2s时：C提交，此时A为3C为2，因此抢占运行C，A被中断还剩3s 4s时：C运行完，所有任务都为提交状态，A和C为3s，因为A先来，所以先运行A 流程如下 等待时间 A:4-2（这个2是第一段的时间） B:14-1 C:2-2 D:7-3 E:10-4 平均等待时间=(2+13+0+4+6)/5=5 有了开始时间和完成时间，至于要算其他的给出公式就能计算 周转时间=作业完成时间—作业提交时间;平均周转时间=(作业1的周转时间+…+作业n的周转时间)/n;带权周转时间=作业周转时间/作业实际运行时间;平均带权周转时间=(作业1的带权周转时间+…+作业n的带权周转时间)/n; 算这些不是有手就行？ sjf算法能让平均等待时间最短，因为先执行了简单任务，当然实际应用中是理想情况，因为不知道任务执行时间是多久。","link":"/Others/%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95(SJF)/"},{"title":"根据两序遍历推出第三序以及构建树","text":"前言：太久了都快忘了，最近做了一下笔试题遇到这题，发现经常考这种题，先把技巧记录下来，有了技巧后简直不要太轻松 1. 树的三种遍历 前序遍历（根左右） 中序遍历（左根右） 后序遍历（左右根） Java实现参考这篇博客，不展开了Java实现树的遍历及二叉树可视化 下面我们来看看如何通过前序和中序推出后序以及构造二叉树 2. 前+中–&gt;后2.1 手写结果不绕弯子，直接给出技巧再做题 看前序遍历：第一个为根节点 看中序遍历：找到步骤1中的根节点，左边的全为左子树，右边的全为右子树 将左子树看成独立的树，重复步骤1和2，直到只有一个元素，不用脑子就可以做出来啦！ 下面进入实战环节（牛客网原题）： 对某二叉树进行先序遍历的结果是ABDEFC,中序遍历的结果是DBFEAC，则后序遍历的结果是（） （参照步骤1）发现根节点是A （参照步骤2）划分出左右子树 （参照步骤1）带着这些左子树看前序遍历，那么前序遍历的顺序是BDEF对吧，将左子树看成是一颗独立的树，于是此时由步骤1得根节点是B （参照步骤2）在子树中继续划分出左右子树 还不明白？那么继续，只有一个字母的就直接填上去了，剩下FE，看前序遍历则是EF，既然已经知道是右子树，那么将右子树看成是一颗独立的树，（参照步骤1）于是此时由步骤1得根节点是E （参照步骤2）划分左右子树，发现只有左子树了，放哪就不必多说了 做多两题，发现掌握了技巧后画出树根本不需要脑子！ 画出树后，再做后序遍历就不难了，我就不说了，答案DFEBCA 下面来看代码实现 2.2 Java实现：构造树 力扣105原题：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 老规矩，直接给模板，这是我个人在力扣评论区找到的风格比较喜欢的一套，下面的中+后–&gt;前也是这个模板 123456789101112131415161718private int pre = 0, in = 0; //记录当前前序，中序的下标位置public TreeNode buildTree(int[] preorder, int[] inorder) { return recursive(preorder, inorder, Integer.MAX_VALUE);}//rootVal是当前节点的值，以当前这个节点作为根节点构造左右子树，没有的话为Integer.MAX_VALUE（比如根节点想象成无限大的某个父节点的左子树）public TreeNode recursive(int[] preorder, int[] inorder, int rootVal) { if (pre &gt;= preorder.length) return null; //结束条件是前序下标大于长度 if (inorder[in] == rootVal) { //递归结束条件是找到中序下标 in++; return null; } int curVal = preorder[pre++]; //下一个根节点和值 TreeNode cur = new TreeNode(curVal); cur.left = recursive(preorder, inorder, curVal); cur.right = recursive(preorder, inorder, rootVal); return cur;} 只需稍微的看一下这两点 一个是pre和in以及他们的++ 一个是recursive的第三个参数代表了分界点的值，也就是当前这个节点作为了它的左右子树的根节点，rootVal就是当前这个节点的值。传的参数思考过程如下： 从整棵树的根节点开始想：cur.left这一句就是前序数组中的节点作为了根节点（回想2.1介绍的东西），cur.right这一句的根节点实际上是一开始传入的节点（就是代码注释中：想象成树的根节点是无限大的某个父节点的左子树）那句，因此是传进来的rootVal。能理解吧… 那么说到这里，如何从中序+后序推出前序的代码自己都能修改了吧：pre和in一开始的位置变成末尾，++变成–，先cur.right再cur.left，改好了可以滑到3.2节去对比代码吧！ 2.3 Java实现：直接获得后序结果现在，我们可以通过前序+中序–&gt;构建树–&gt;后序遍历树–&gt;获得后序遍历结果。诚然，代码的话，可以不构建树而直接获得后序遍历结果，我直接贴完整的代码 123456789101112131415161718192021222324252627282930313233public class one_zero_five_从前序与中序遍历获得后序遍历 { @Test public void test(){ int[] preorder = {3,9,20,15,7}; int[] inorder = {9,3,15,20,7}; totalLen = inorder.length; int[] res = buildPost(preorder, inorder, 0, totalLen - 1, 0); System.out.println(Arrays.toString(res)); } private int post, totalLen; private int[] postorder = null; /** * 直接获得后序结果 * @param preorder 前序数组 * @param inorder 中序数组 * @param start 子树在中序数组中的起始下标 * @param end 子树在中序数组中的结束下标 * @param rootIndex 子树根节点在数组中的下标 * @return 后序数组 */ public int[] buildPost(int[] preorder, int[] inorder, int start, int end, int rootIndex){ if (postorder == null) postorder = new int[totalLen]; //第一次进入才构建，后期可以考虑放进构造函数 if (start &gt; end) return null; int i = start; //i代表前序遍历的根节点在中序中的下标 while (i &lt; end &amp;&amp; inorder[i] != preorder[rootIndex]) i++; postorder[post++] = preorder[rootIndex]; buildPost(preorder, inorder, start, i - 1, rootIndex + 1); //构建左子树，start ~ (i - 1)，rootIndex: buildPost(preorder, inorder, i + 1, end, rootIndex + i - start + 1); //构建右子树，(i + 1) ~ end，rootIndex: return postorder; }} 看起来吓人函数体除了注释一共才8行！！其实这个理解起来更容易， start为0，end为len-1，rootIndex一开始为为前序的开始所以是0，那么preorder[rootIndex]就是根节点 在中序中找到这个根节点，i为下标，那么inorder[i]左边为左子树，右边为右子树 那么左子树的范围是start ~ (i - 1)，根节点在前序下标为：rootIndex +1 右子树的范围是(i + 1) ~ end，前序是根左右，那么右子树的根节点为：当前根节点位置 + 左子树长度 + 1，左子树长度怎么计算呢？从中序（左根右）那里计算可得i - start就是左子树长度，因此根节点下标为rootIndex + (i - start) + 1 3. 中+后–&gt;前3.1 手写结果中序的作用仍然是划分左右子树，后序的作用其实跟前序一样，不过得反过来从后面开始看，最后一个才是根节点 看后序遍历：最后一个为根节点 看中序遍历：找到步骤1中的根节点，左边的全为左子树，右边的全为右子树 将左子树看成独立的树，重复步骤1和2，直到只有一个元素，不用脑子就可以做出来啦！ 看题： 中序遍历: GBEDAFCH 后序遍历：GEDBFHCA 我就直接来了 看后序，根节点是A 看中序，左边GBED右边FCH 看后序，要先看右子树（因为后序是“左右根”，之前说了反过来看那么根完了到右），FHC说明根节点是C 看中序，左边F右边H，左右都只有一个了，完成 看后序，GEDB说明根节点是B 看中序，左边单G，右边ED 看后序，是ED，说明D是根节点 看中序，左边E，完成 3.2 Java实现：构造树根据2.2中的套路模板，只需稍微修改一下顺序即可获得正确答案 12345678910111213141516171819private int in, post;public TreeNode buildTree(int[] inorder, int[] postorder) { in = inorder.length - 1; //从后面开始 post = postorder.length - 1; return recursive(inorder, postorder, Integer.MAX_VALUE);}public TreeNode recursive(int[] inorder, int[] postorder, int rootVal){ if (post &lt; 0) return null; if (inorder[in] == rootVal){ in--; return null; } int curVal = postorder[post--]; TreeNode cur = new TreeNode(curVal); cur.right = recursive(inorder, postorder, curVal); //后序是先右再左 cur.left = recursive(inorder, postorder, rootVal); return cur;} 3.3 Java实现：直接获得前序结果也是跟2.3一样的模板，理解了就好了 123456789101112131415161718192021222324252627282930313233public class one_zero_six_从中序与后序遍历获得前序遍历 { @Test public void test2(){ int[] inorder = {9,3,15,20,7}; int[] postorder = {9,15,7,20,3}; totalLen = inorder.length; int[] res = buildPre(inorder, postorder, 0, totalLen - 1, totalLen - 1); System.out.println(Arrays.toString(res)); } private int pre, in, post, totalLen; private int[] preorder = null; /** * 直接获得前序结果 * @param inorder 中序数组 * @param postorder 后序数组 * @param start 子树在中序数组中的起始下标 * @param end 子树在中序数组中的结束下标 * @param rootIndex 子树根节点在数组中的下标 * @return 前序数组 */ public int[] buildPre(int[] inorder, int[] postorder, int start, int end, int rootIndex) { if (preorder == null) preorder = new int[totalLen]; if (start &gt; end) return null; //结束，随便返回 int i = start; //i为后序数组的某个值在中序数组中的位置 while (i &lt; end &amp;&amp; inorder[i] != postorder[rootIndex]) i++; //以i为分隔符，inorder左边为左子树，右边为右子树 preorder[pre++] = postorder[rootIndex]; buildPre(inorder, postorder, start, i - 1, rootIndex - 1 - end + i); //左子树，根节点下标为rootIndex - (end - i + 1) buildPre(inorder, postorder, i + 1, end, rootIndex - 1); //右子树，根节点下标为rootIndex - 1 return preorder; }} start为0，end为len-1，rootIndex一开始为为后序的最后所以是len-1，那么postorder[rootIndex]就是根节点 在中序中找到这个根节点，i为下标，那么inorder[i]左边为左子树，右边为右子树 那么左子树的范围是start ~ (i - 1)，根节点下标为：当前根节点下标 - 右子树长度 - 1，右子树长度怎么计算呢？从中序那里计算可得end - i就是右子树长度，因此根节点下标为rootIndex - (end - i) - 1 右子树的范围是(i + 1) ~ end，根节点在后序的下标为rootIndex - 1 4. 前+后–&gt;无法确定这种情况树不唯一 5. 附录：搭配上个博客的可视化二叉树工具类一起食用更加，看看你做对了吗 参考/感谢： 构造树的模板提取自力扣官方题解下的朋友十三羽扬 直接获得第三序结果的代码参考了柳神的代码","link":"/algorithms/%E6%A0%B9%E6%8D%AE%E4%B8%A4%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%87%BA%E7%AC%AC%E4%B8%89%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%9E%84%E5%BB%BA%E6%A0%91/"},{"title":"梦幻西游游戏体验","text":"作为一款MMO，这个游戏在社交方面还是做的非常好的 阿米有个小姐姐id叫阿米呀，是在一次抓鬼中认识的。那会是我玩这个游戏的第3天，觉得这游戏挺无聊的，但是作业要求要达到65级，于是就每天挂机做日常，想着反正到65级就可以了，阿米的出现为我的游戏体验增加了乐趣。 “原来组队的人不带我玩了，一个人玩挺无聊的，我打算卸载了，想到跟你还比较熟，卸载之前跟你说一声”，阿米发来这么一条消息。 嗯？？当时我就觉得不行，我离65级还有那么遥远，不能我一个人觉得无聊。“别呀，先别卸载，咱俩可以一起玩啊，陪我到65级一起卸载”，为了挽留这个对游戏失望的小姐姐，我又说了一些“今年毕业啊，我也今年毕业”这类拉近关系的话。阿米不知道的是，我玩这个游戏并不是喜欢玩游戏，只是网易新人项目的其中一项作业要求。 后来的一些日子里，就是跟阿米每天的挂机聊天，等级也很快就上去了（这游戏说是养成，我感觉还是速成）。阿米是个很有意思的人，现实中也是个非常优秀的小姐姐，和她聊了一段时间才知道，她说的毕业是硕士毕业，还是出国留学的海归，本科就是211。好家伙，这是继网易新人群的名校大佬，讨论作业的上交硕士之后第三次震惊。这网易游戏不仅研发都是大佬，连玩家都是硕士起步了吗？ 3月结束要交游戏体验报告了，阿米的一句话让整篇报告活了起来，事情是这样的，梦幻西游的屏蔽词非常严格，会被“爱生活爱梦幻西游代替”。阿米跟我聊了一些关于工作实习的事情，但由于过多屏蔽词被禁言了， 为了安慰阿米，我说了一句“研发辣鸡，是研发的问题”，没想到阿米也跟了句 我打上马赛克，这游戏体验报告我愿称之为绝活！ 当然，说到阿米的这句“靠你们这一代新生..”，我想大概阿米也多多少少能猜出来我的工作了吧，毕竟这正常人守着个无聊的游戏非要到65级，加上阿米过人的聪慧，猜个八九不离十也很正常。 星辰星辰兄是我在游戏里认识的第一个好友，是个资深老玩家，同时是个肝帝 星辰兄是个神奇的人物，我和他是送结之交，每天互送同心结。据他所说，他是上班时间偷偷玩的游戏，跟我吐槽吐槽老板和工作什么的… 我有一晚凌晨睡不着登录游戏，他居然还在线，大哥可能喝多了，跟我掏心掏肺说了很多，最后还说要找我喝酒，可是他连我人在哪都不知道… 后来还邀请我当他们帮派的护法，感觉这个游戏里的玩家颇有一种江湖义气。当然最后我没答应，因为那会已经快65级了，总不能当了护法就把帮派给抛弃了吧。 魔王寨魔王寨是个神奇的门派，里面都是人才，门派频道很热闹，从不聊游戏，聊的是人生、情感、未来、婚姻、pk唱歌甚至开车…每当我看门派频道都仿佛觉得自己玩的不是游戏，是人情世故。 总之不推荐纯洁的小姐姐玩这个门派… 神秘符号这个游戏里有一个非常神奇的现象，很多人名字后面会加一个特殊符号，似乎成为了这个游戏默认的传统。后来我通过好友了解到带这个符号的玩家说明有固定队伍，有组织有纪律，仿佛一颗心有了自己的归属。 其他的关于游戏攻略比如抓鬼如何搭配双倍收益最高，前尘旧梦牛头的巧妙运用等等就不说了，全靠老玩家给的攻略。作为一款MMO，虽然挂机和回合制的机制挺无聊，但是社交方面还是做的非常好的。","link":"/life/mhxy-experience/"},{"title":"简单工厂模式","text":"1. 介绍和应用场景工厂模式：创建对象时不会对客户端暴露创建逻辑（new），而是通过使用一个共同的接口来指向新创建的对象。 生活中的例子：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现 代码例子：如果在程序中需要创建很多个同一系列的类，比如：加法类减法类乘法类除法类都完成了计算(getResult)方法，或者圆类正方形类三角形类都完成了计算面积(getArea)方法，那么就是同一个系列的类。这些类都实现了相同的方法，这时候就可以考虑使用简单工厂模式了。 2. 步骤 接口/父类 因为都属于一系列的类，所以可以抽象出接口或者一个父类，是不是抽象类都可以，关键是明白这是一系列类的上层 1234567891011121314151617181920212223242526272829303132/*** * 这个类是所有运算类的父类 拥有运算的基本属性 */public class Operation { private double numberA; private double numberB; public double getNumberA() { return numberA; } public void setNumberA(double numberA) { this.numberA = numberA; } public double getNumberB() { return numberB; } public void setNumberB(double numberB) { this.numberB = numberB; } /** * @return 计算的结果 * @throws Exception 运算时的异常 */ public double GetResult() throws Exception { double result = 0; return result; }} 一堆同一系列的类，都继承/实现了上面的父类/接口 123456789/** * 加法类 */public class OperationAdd extends Operation { @Override public double GetResult() { return getNumberA() + getNumberB(); }} 123456789/** * 减法类 */public class OperationSub extends Operation { @Override public double GetResult() { return getNumberA()-getNumberB(); }} 123456789/** * 乘法类 */public class OperationMul extends Operation { @Override public double GetResult() { return getNumberA()*getNumberB(); }} 123456789101112/*** * 除法类 */public class OperationDiv extends Operation { @Override public double GetResult() throws Exception { if (getNumberB() == 0) { throw new Exception(\"除数不能为 0 !\"); } return getNumberA() / getNumberB(); }} 此时结构（idea生成的图是有点复杂，看一条线就够了） 工厂类，到这里就知道为什么要抽象出接口/父类了，因为我们并不知道用户想创建加法还是减法，但是返回值一定是一个统一的Operation类。就像买车的例子一样，虽然不知道客户买什么车，但来了车厂，买的一定是车而不是飞机。 123456789101112131415161718192021222324/** * 简单工厂类 含有一个静态方法 * 用于根据运算符返回具体的运算实例 */public class OperationFactory { public static Operation createOperate(String operate) { Operation operation = null; switch (operate) { case \"+\": operation = new OperationAdd(); break; case \"-\": operation = new OperationSub(); break; case \"*\": operation = new OperationMul(); break; case \"/\": operation = new OperationDiv(); break; } return operation; }} 调用 12345678910public class Main { public static void main(String[] args) throws Exception { Operation operation = OperationFactory.createOperate(\"+\"); operation.setNumberA(1); operation.setNumberB(2);// 这里其实是由Operation具体的子类实现的具体功能 double result = operation.GetResult(); System.out.println(result); }} 最终的结构为（我p调了多余的线） 3. 优化我们自己写的switch函数，所以当然知道有哪些情况。但是假如我们这个程序写的很大了，甚至写成了框架供别人使用。 从用户的角度来说：仔细看main函数，我们在写的时候传了”+”这个符号，可是用户怎么知道switch里面有+呢（要么用户查看手册文档，要么用户查看源码），这就很麻烦，如果可以用一个枚举供用户选择就太好了 1234567//供用户选择的枚举变量public enum OpType { ADD, SUB, MUL, DIV} 工厂类要修改的地方 效果 另外，就是学习spring的时候提到过BeanFactory有一种getBean方式（点击空降），也是采用了工厂模式，不过spring情况比较特殊，它不知道用户会创建什么类，也就没办法switch，因此采用的是反射的方式，那么写法就是这个样子 12345678910111213public class OperationFactory { public static &lt;T&gt; T createOperate(Class&lt;? extends T&gt; clazz) { T obj = null; try { obj = (T) Class.forName(clazz.getName()).newInstance(); } catch (Exception e) { e.printStackTrace(); } return obj; }} main方法的修改(当然如果还想采用枚举类优化的话，枚举类中就要存类名了。) 12345678910public class Main { public static void main(String[] args) throws Exception { Operation operation = OperationFactory.createOperate(OperationAdd.class); //就改了这里 operation.setNumberA(1); operation.setNumberB(2);// 这里其实是由Operation具体的子类实现的具体功能 double result = operation.GetResult(); System.out.println(result); }} 使用反射的好处是不需要写很多if，switch，但是反射会降低效率，只是告诉大家spring采用过这种方式，知道一下即可。 参考链接 https://blog.csdn.net/qq_41113081/article/details/88170881 https://www.runoob.com/design-pattern/factory-pattern.html","link":"/designpattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"结束秋招，一点感想","text":"近段时间事件[DONE] 同盾offer 神州信息offer 网易offer 毕设选题 [TODO] springcloud和知识 网易知识准备 毕设 秋招感言秋招结束了，截止目前收到了浙江大华，同盾科技，网易等offer。虽然比不上班上的大佬们（我愿称软件卓越1171为网易人才孵化基地），但是也远远超过了我的预期。最后选的是网易，广州，大厂，可以说是非常满意的offer。 工作岗位是引擎技术支持，我问过很多人甚至是网易的内部人员，知道他是一个非纯技术的岗位，更多的是需求沟通，偶尔会有开发工作，我愿意尝试，主要基于以下几点。 虽然不是纯技术岗，但任然属于技术类岗位：leader面的时候我曾问过leader对岗位的看法，他给出的答案是“可能不会太深入，但是技术肯定是不会说落后同龄人”，说实话我根本不知道这个岗位前景如何，我的未来会往何处发展，但是这句话给了我足够的信心 java是卷王子：java尤其是web方向，可以说是很卷了，现在本科应届不会点分布式微服务都很难找工作了。网易这边应该是python居多，我有改变的想法并且愿意拥抱变化。javaweb我已经写的有点厌倦，这次毕设题目是FreeWork招聘平台，我会用上所学的最深入的知识实现，并打算进行长久的维护，以后对于java可能就是兴趣使然，偶尔学习新的知识就往项目里加 我适合沟通：就我而言，比较沙雕，为人乐观开朗。我认真想了想，大多数技术人员肯定是喜欢钻研技术的，我也不例外。但是我也知道技术本身是没有价值的，多看看，多认识点人，多与人打交道，让技术成为自己的附属工具也是不错的选择 福利确实好：诚然，网易作为一家大厂，虽然给我开的很低，但也是我目前收到最高的了… 给学弟学妹们的一点秋招建议 秋招和学习是两回事。你学的再好，说不定运气不好笔试某一道算法题你就是做不出来。技术可能差那么一点，但是运气有点好，你就进去了。 不要太过于钻研业务代码和框架，越是大厂越注重基础，整个秋招，问的频率如下：数据结构和算法&gt;mysql&gt;网络&gt;jvm&gt;redis&gt;java语法&gt;操作系统。算法、mysql、jvm必考，redis简历写了必问，大厂：网络和操作系统问的多，操作系统可能只问一题但是每一面都会问 我说说每一点如何准备 算法：牛客和剑指offer。就面试来说，力扣你可以不刷，但是牛客和剑指offer你必刷，不会都要默出来那种。笔试的话先看labuladong，再做力扣，力扣的话有1000多道偶尔刷刷就可以了 面经：面经必然是要看的，三太子敖丙，马士兵。尤其是敖丙的文章，mysql，jvm，redis什么都有，遇到不懂的就百度查，太细的东西以后学，再次强调，先秋招再学习 简历：wonderCV，项目不要太多，两三个就够了，实习可以加分，甚至有点关键，不相关的东西少写（学生会？）反正不能超过技术部分 千万不要害怕觉得自己技术还不够：我看到这个时候还有人在准备简历上的项目的，业务代码够了真的够了，都这时候了别搞spring了，至少在我整个秋招中没有被问过一点点spring相关的（ioc和aop之类），而且这个本来就是很抽象的东西，说不出个所以然来，大家的回答都类似，所以现在面试官也不问了 网络：我是直接拿课堂上的老师的ppt课件学习的 我不是叫大家不要学习只背面经，也不是教大家投机取巧。学习还是要学习的，只是如果连面经上这些基础的概念都没有搞清楚，学也容易走偏。特殊时期先背背面经，就当作复习基础知识了还是有必要的，校招先上岸再继续深入学习也不迟。最后，祝大家都能拿到自己心仪的offer","link":"/life/%E7%BB%93%E6%9D%9F%E7%A7%8B%E6%8B%9B%EF%BC%8C%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/"},{"title":"计算平方根-牛顿迭代法","text":"这是2019/09/06的一篇笔记，现在补上。这是《算法》第四版中提到的，如何实现sqrt(x)，当时和文德在实验室里面一起研究了一下。今天深信服笔试又遇到了简单版的题目。 整数型放在以前，只能求整数的平方根： 12345public int sqrt(int n){ for(int i = 0; i * i &lt; n; i++){ if(i * i == n) return i; //或者想要记录i * i &lt;= n }} 至于深信服也是简化到int，笔试嘛…我直接 return (int)Math.sqrt(n); 测试用例当然是100%，能不能拿到分我就不知道了，笔试嘛谁管这个，他也没说不能用，时间重要哈 小数型-牛顿迭代法再来说一下正经的sqrt实现，也就是如果是小数，你就不知道每次迭代加多少了，0.01？还是0.001？都不够精确。书中提到了牛顿迭代法： 假设要求√2的值，那么构造f(x) = x² - 2， 当y=0时，与x轴的交点就是√2(红点) 随机取一点p，求得f(p)，斜率为2p 点斜式构造(y – y0) = k(x – x0)得 y – f(p) = 2p(x - p) 令y = 0，求得直线与y轴交点处x的值x = p – f(p)/2p 这一点会比(4, 0)更接近红点，于是取p = 这一点并重复上述步骤，慢慢逼近红点处x的值 将f(p)化开来：x = p – (p² - 2)/2p 一般化，若p为x上任意一点，x则为下一个靠近点 即next_x = x – (x² - 2) / 2x，化简得next_x = (x + 2/x) / 2 在代码中则直接都表示为x，即x = (x + 2/x) / 2 再一般化，求根号c的值：x = (x + c/x) / 2 逼近个7 8次就已经很接近√2了 Java实现逼近个7 8次这个说法太宽泛了，可以设置一个能接受的误差程度，比如err = 1e-15 123456789public double sqrt(double c){ if(c &lt; 0) return Double.NaN; //小于0是没有平方根的 double err = 1e-15; //因为是逼近，√2是无理数，需要结束条件，也就是能接受的误差程度,否则永远循环 double res = c; //一开始取p = c，因为√2一定&lt;2 while(Math.abs(res - c / res) &gt; err * res){ //结束条件: abs(res² - c) &lt;= err res = (res + c / res) / 2.0; //前面推导的公式 } return res;} ps：这是什么？当时看这个的时候我忽然发现，这不就类似bp神经网络的梯度下降嘛！！！！神经网络的那些听起来高大上的反向传播，梯度下降。不就正是和这个一样求导逼近的思想吗，还不如从这个牛顿迭代法开始讲解呢，更加直观。","link":"/algorithms/%E8%AE%A1%E7%AE%97%E5%B9%B3%E6%96%B9%E6%A0%B9-%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"},{"title":"线程和线程池","text":"1. 线程和进程的区别进程：资源分配的基本单位，是程序（硬盘上的QQ.exe）的一个实例，比如双击QQ.exe，程序启动，进入内存 线程：程序执行的基本单位，是一个任务，比如软件管家可以同时清理垃圾和扫描病毒 一个进程可以有多个线程 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，创建/切换线程的开销比进程小 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行(管道，信号，消息队列，共享内存，套接字等通信机制)。不过如何处理好同步与互斥是编写多线程程序的难点。 2. 线程间通信同一进程下的线程虽然能共享全局变量、静态变量等数据是没错，但是由于JMM的限制，一个线程改变全局变量的值，其他线程并不能感知到，因为JMM中有规定，线程不能直接操作主存中的值，只能拷贝到自己的工作内存再进行操作。也就是说大家都知道有个private int a = 5，但是线程一将其改为6后线程二不能得知。这个问题我们在volatile一文中探究过。是的，volatile就是线程间通信的其中一种方式。 volatile 使用Object类的wait() 和 notify() / notifyAll() 方法 JUC下的一些包（CountDownLatch/ReentrantLock/LockSupport）的锁机制 3. 线程的状态网上说的很乱，到处乱传，还分什么runnable和running什么的，很多都是错的！本着不造谣不信谣不传谣的原则，我们来看一下源码就知道了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt; * &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt; * &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt; * &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt; * &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt; * &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt; * &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt; * &lt;/ul&gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED;} 6种！！没有什么Running状态！！！记好了！！ wait()和sleep()的区别它们都可以让线程阻塞。不同的是： wait方法必须在synchronized保护的代码中使用，而 sleep 方法并没有这个要求 在同步代码中执行 sleep 方法时，并不会释放monitor锁，但执行wait方法时会主动释放monitor锁 sleep方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的wait方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复 wait/notify 是 Object 类的方法，而 sleep 是Thread类的方法 4. start方法到底是什么为什么要调用start而不是run 1234567891011121314151617181920212223public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { start0(); //关键就是这个方法 started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } }}private native void start0(); //是个本地方法，系统调用开了一个线程 4. 线程池 降低资源消耗：重复利用已创建的线程，降低线程创建和销毁造成的消耗。 提高响应速度：当任务到达时，任务可以不需要要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 4.1 线程池的参数1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：核心线程数线。线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize maximumPoolSize：最大线程数。一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定 keepAliveTime：一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定 TimeUnit：时间单位 workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中，有四种任务队列 ①ArrayBlockingQueue 基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。 ②LinkedBlockingQueue 基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。 ③SynchronousQueue 一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。说白了就是个假队列 ④PriorityBlockingQueue 具有优先级的无界阻塞队列，优先级通过参数Comparator实现 ThreadFactory：线程工厂，创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等 RejectedExecutionHandler：拒绝策略 AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。 CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。（说白了，谁管理任务的，谁就负责帮忙） DiscardPolicy：不处理新任务，直接丢弃掉。 DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。 4.2 常见线程池newFixedThreadPool12345678// core和max是一样的// blockQueue是无界阻塞队列// 嗯， 不好不好！！！public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());} newSingleThreadExecutor123456789// core和max无非都是1而已// blockQueue是无界阻塞队列// 嗯， 不好不好！！！public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));} newCachedThreadPool12345678// core 0// max有点狠，不怕暴栈？// 队列还是SynchronousQueue，还真怕public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());} 还有些别的比如newScheduledThreadPool（带定时器的线程池），就不介绍了 可以看到这些都太极端了，要么core等于max，要么直接为0，队列也是无界，所以阿里巴巴的规范会提示自定义线程池 4.3 线程池的线程数量怎么确定 一般来说，如果是CPU密集型应用，则线程池大小设置为N+1。 一般来说，如果是IO密集型应用，则线程池大小设置为2N+1。 在IO优化中，线程等待时间所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。这样的估算公式可能更适合：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目 参考 线程间通信：https://blog.csdn.net/jisuanji12306/article/details/86363390 线程的状态：https://blog.csdn.net/pange1991/article/details/53860651","link":"/Java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"title":"记一次快速排序探究","text":"快速排序三种实现方式大家都知道快速排序一次后左边比标兵小，右边比标兵大。但是要注意市面上现在主要有两种快速排序：一种是标兵不动版（只在每趟最后做一次交换），一种是标兵移动版。两种效率都一样，原因在于最初的论文和《算法》书中的不一样。 一般做选择题来说都采用标兵移动版，且默认标兵选每部分最左边的第一个。 标兵移动版：从右往左找到第一个比标兵小的值并交换，从左往右找到第一个比标兵大的值并交换。 标兵不动版：将[1 : n]分为左边小[1 : mid]，右边大[mid + 1 : n]，这趟后再将标兵0和mid交换。 两种都能达到最终目的：排序一次后左边比标兵小，右边比标兵大 标兵移动版（推荐）一般选择题都默认这种最初版本，我推荐这种做法。做了优化，无需每次都换来换去，只需要换该换的元素，最后换掉标兵即可。例如：标兵从0换到了5，又从5换到了3，又从3换到了4，那么先用一个temp暂存标兵的值，直接n[0]=n[5], n[5]=n[3],n[3]=n[4],最后n[4]=temp即可 1234567891011121314151617181920public void quickSort(int[] nums, int l, int r){ if (nums == null || nums.length &lt;= 1 || l &gt;= r) return; //递归结束条件 int left = l, right = r; //要递归的，别破坏了参数 int temp = nums[left]; //改进，标兵存起来 while (left &lt; right) { while (temp &lt;= nums[right] &amp;&amp; left &lt; right) right--; //从右往左找到第一个小于哨兵的值 if (left &lt; right) { nums[left] = nums[right]; left++; } while (temp &gt;= nums[left] &amp;&amp; left &lt; right) left++; //从左往右找第一个大于哨兵的值 if (left &lt; right) { nums[right] = nums[left]; right--; } } nums[left] = temp; //最后才让哨兵去该去的地方，此时写left和right都是一样的 quickSort(nums, l, left); //再强调一遍，此时left和right是一样的 quickSort(nums, left + 1, r);} 标兵不动版参考柳神代码，改成了左边为标兵 123456789101112131415161718public int[] quickSort(int[] nums, int l, int r) { int mid = r; for (int i = r; i &gt;= l; i--) { if (nums[i] &gt; nums[l]) { nums[i] = swap(nums[mid], nums[mid] = nums[i]); //交换i和mid mid--; } } nums[l] = swap(nums[mid], nums[mid] = nums[l]); //交换mid和标兵 //递归左右 if (mid &gt; l + 1) quickSort(nums, l, mid - 1); if (mid &lt; r - 1) quickSort(nums, mid + 1, r); return nums;}public static int swap(int a, int b){ return a;} BFS版本，可以获取第n次的排序结果相比于DFS更简单的实现，BFS更加符合手写顺序 在标兵移动版的基础上改进，不用递归（dfs），而是使用队列（bfs） 1234567891011121314151617181920212223242526272829303132public void quickSort(int[] nums){ Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); //存左右下标 int[] idx = {0, nums.length - 1}; queue.offer(idx); while (!queue.isEmpty()){ idx = queue.poll(); if (idx[0] &gt; idx[1]) continue; //开始一轮交换（注意不是一趟） int left = idx[0], right = idx[1], temp = nums[left]; while (left &lt; right){ //从右往左 while (left &lt; right &amp;&amp; temp &lt;= nums[right]) right--; if (left &lt; right){ nums[left] = nums[right]; left++; } //从左往右 while (left &lt; right &amp;&amp; temp &gt;= nums[left]) left++; if (left &lt; right){ nums[right] = nums[left]; right--; } } //交换标兵，完成后代表一轮结束 nums[left] = temp; //左右入队 int[] idxL = {idx[0], left - 1}; queue.offer(idxL); int[] idxR = {left + 1, idx[1]}; queue.offer(idxR); }} 我想在博客里高冷一点，细节不多说了，这几种自己调调看吧，断点打在哨兵交换前就可以很清楚的看出3种方法的区别了 2020.10.29场中信信用卡附加题求第n趟快排结果 完整代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class zhongxin_004_快速排序第n趟结果 { @Test public void test(){ int[] array = {42,35,63,96,56,11,17,42,88}; int[] res = nthResultOfQuickSort(array, 4); System.out.println(Arrays.toString(res)); } private int sum = 1; public int[] nthResultOfQuickSort (int[] array, int n) { // write code here //计算次数 for (int i = 1; i &lt; n; i++) { sum += 2 * i; } quickSort(array); return array; } public void quickSort(int[] nums){ Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); //存左右下标 int[] idx = {0, nums.length - 1}; queue.offer(idx); while (!queue.isEmpty()){ idx = queue.poll(); if (idx[0] &gt; idx[1]) continue; //开始一轮交换（注意不是一趟） int left = idx[0], right = idx[1], temp = nums[left]; while (left &lt; right){ //从右往左 while (left &lt; right &amp;&amp; temp &lt;= nums[right]) right--; if (left &lt; right){ nums[left] = nums[right]; left++; } //从左往右 while (left &lt; right &amp;&amp; temp &gt;= nums[left]) left++; if (left &lt; right){ nums[right] = nums[left]; right--; } } //交换标兵，完成后代表一轮结束 nums[left] = temp; //交换结束，判断是否完成了第n趟 if (--sum == 0) return; //左右入队 int[] idxL = {idx[0], left - 1}; queue.offer(idxL); int[] idxR = {left + 1, idx[1]}; queue.offer(idxR); } }} 其他排序的题目点击这里","link":"/algorithms/quicksort/"},{"title":"邮件工具类","text":"邮件工具类，使用java发送邮件，常用于邮箱激活场景，用于发送的账号需要进行以下配置： 以QQ邮箱为例，需要在设置-&gt;账户下打开POP3和IMAP服务（也可以直接全开），这样才能第三方登录邮箱（Java中登录也算第三方） 开启的时候会获取一个授权码（没记下来就再次关闭打开，每次都不一样的，但是每个都有效） 直接复制即可食用，就只有一个静态方法调用即可，参数已注明在注释中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.util.Properties;/** * 发邮件工具类 */public final class MailUtils { private static final String USER = \"975504808@qq.com\"; // 发件人邮箱地址 private static final String PASSWORD = \"刚刚说的授权码\"; // 如果是qq邮箱可以使户端授权码，或者登录密码 /** * * @param to 收件人邮箱 * @param text 邮件正文 * @param title 标题 */ /* 发送验证信息的邮件 */ public static boolean sendMail(String to, String text, String title){ try { final Properties props = new Properties(); props.put(\"mail.smtp.auth\", \"true\"); props.put(\"mail.smtp.host\", \"smtp.qq.com\"); // 发件人的账号 props.put(\"mail.user\", USER); //发件人的密码 props.put(\"mail.password\", PASSWORD); // 构建授权信息，用于进行SMTP进行身份验证 Authenticator authenticator = new Authenticator() { @Override protected PasswordAuthentication getPasswordAuthentication() { // 用户名、密码 String userName = props.getProperty(\"mail.user\"); String password = props.getProperty(\"mail.password\"); return new PasswordAuthentication(userName, password); } }; // 使用环境属性和授权信息，创建邮件会话 Session mailSession = Session.getInstance(props, authenticator); // 创建邮件消息 MimeMessage message = new MimeMessage(mailSession); // 设置发件人 String username = props.getProperty(\"mail.user\"); InternetAddress form = new InternetAddress(username); message.setFrom(form); // 设置收件人 InternetAddress toAddress = new InternetAddress(to); message.setRecipient(Message.RecipientType.TO, toAddress); // 设置邮件标题 message.setSubject(title); // 设置邮件的内容体 message.setContent(text, \"text/html;charset=UTF-8\"); // 发送邮件 Transport.send(message); return true; }catch (Exception e){ e.printStackTrace(); } return false; }} 后序的工具类我想做成文件下载而不是贴代码…看下什么时候有空再说（拖延症晚期）","link":"/util/%E9%82%AE%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"链表题技巧","text":"链表题一般都是逻辑问题，空指针处理，很少会有难思考的智力型题目。一般都是一层while循环加上一些指针操作，掌握以下几个技巧，会如鱼得水 123456//朴实无华的简陋版框架while(node != null){ //指针操作逻辑 node = node.next;}//指针操作逻辑 技巧1. 在前一个节点停下比如a-&gt;b-&gt;c，我现在操作到了b，假设操作逻辑要求删除当前节点b，那么也就是a.next = c，发现根本没有指针能获得节点a，因此我们可以在前一个节点停下，所以根据逻辑的需要，先思考是否需要用到前一个节点 123456while(node.next != b){ //在前一个节点停下 //指针操作逻辑 node = node.next;}//此时node在anode.next = node.next.next 2. 虚拟头部还是a-&gt;b-&gt;c删除某个节点，还是刚刚那套逻辑，如果我要删的是a，怎么办？你可能会说直接head = a就被“删除”了，不错，但是这样的话得单独判断要删的节点是不是头节点，代码看起来就很啰嗦，所以链表题通常可以使用一个虚拟头节点。什么时候要加呢？也是思考是否需要用到前一个节点，如果需要，那第一个节点必然也需要一个前置节点 12ListNode root = new ListNode();root.next = head; 用了虚拟头部后，头节点也可以和其他节点一起操作了 记得return root.next而不是head 3. xx.next，判断xx != null链表题容易空指针，为什么会空指针，一个方法教你永远不空指针：只要代码里面有node.next，那么就判断node != null，如果有node.next.next，那就判断node != null &amp;&amp; node.next != null 归根到底，空指针异常是由于null.next造成的 4. 双指针，不行就三指针研究表明，指针越多，链表题越容易做，双指针不行就三指针，再不行就四指针，n指针秒一切链表题! 像什么前后指针，快慢指针，都是链表题常用的操作 模板综上所述，模板如下： 123456789101112public ListNode LinkedList(ListNode head) { //虚拟头部和n指针初始位置 ListNode root = new ListNode(0); root.next = head; while (pre != null &amp;&amp; pre.next != null){ //指针操作逻辑 pre = pre.next; } return root.next;} 看一题 力扣19 https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 不解释，只是看代码结构 12345678910111213141516171819public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null) return null; //虚拟头部 ListNode root = new ListNode(0); root.next = head; //n指针位置准备 ListNode pre = root, post = root; while (n-- != 0) { pre = pre.next; } while (pre != null &amp;&amp; pre.next != null){ //while在前一个节点停下 pre = pre.next; post = post.next; } if (post != null &amp;&amp; post.next != null) post.next = post.next.next; //判空 return root.next;} 至于本题具体的思路和其他链表类型的题目点击这里","link":"/algorithms/linked-list-template/"},{"title":"计算机网络基础","text":"网络的知识太多了，我决定慢慢写，零零散散写，有很多对软件学生来说不太重要的知识点，我还是记下来了，但有标注重要😀/一般般🤪/不重要😭 1. TCP/IP 5层模型😀 物理层：负责转换比特流(101001010)和高低电平。中继器、集线器、RJ45接口 数据链路层：负责网络间数据传送。路由器、以太网、MAC、网桥、交换机、VLAN 网络层：主机对主机。IP、ARP、RARP、ICMP、IGMP、RIP等协议 传输层：端口对端口(说白了就是程序对程序)。TCP、UDP、SSL等协议 应用层：应用和展示。HTTP、SSH、FTP、DNS、DHCP、RPC 2. 物理层😭物理层有个东西要知道：信道复用技术，快速划过知道有哪几种复用技术就行 频分复用FDM😭 时分复用TDM😭 统计时分复用STDM：数据到达的时间是不固定的 波分复用WDM😭不介绍了 码分复用CDM🤪这里可能会有笔试题： S站的码片序列是 00011011（也有些地方0用-1表示） 发送比特 1 时，就发送序列 00011011 发送比特 0 时，就发送反码 11100100 如果多个站，每个站的码片序列必须正交（也就是对应相乘再相加等于0）比如 S站(–1 –1 –1 +1 +1 –1 +1 +1) T站(–1 –1 +1 –1 +1 +1 +1 –1) 3. 数据链路层🤪下图红线过程就是数据链路层的工作 特点🤪这层解决了三个基本问题 封装成帧 透明传输 差错控制 封装成帧😭也就是用开始和结束符分段标记了数据 透明传输😭帧的数据部分如果恰好也有开始/结束符，那么也要求能接收并且正确传，而不是规定数据不能含开始/结束符，这就叫透明传输。 实现方式有字节填充和零比特填充两种 字节填充 “SOH”或“EOT”的前面插入一个转义字符“ESC”(十六进制编码是 1B) 如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符 接收端必须将转义字符删除再将数据移交给上层 零比特填充 将数据字段中出现连续6个1的情况破坏 发送端：只要发现有5 个连续 1，立即填入一个 0 接收端：只要发现 5 个连续1，对之后一位进行检查，若为0，则删除；若为1，则表示帧开始或帧结束。 差错控制🤪由于物理和环境原因，传输数据可能出现差错，比如由1变成0，所以接收端需要循环冗余检验CRC //TODO 注意：循环冗余检验CRC差错检测技术只能做到无差错接受，而不是可靠传输 MAC子层😀 IEEE802委员会将局域网的数据链路层拆成两个子层 逻辑链路控制 LLC (Logical Link Control)子层 媒体接入控制 MAC (Medium Access Control)子层 LLC子层的作用已经消失 MAC地址又称为硬件地址或物理地址。 固化在计算机的网卡的ROM中,实际上是适配器（网卡）的标识符 MAC地址6个字节,48位。前三个字节(即高位 24 位)是组织唯一标识符，有注册机构RA向生产网卡的厂家分配。后三个字节(即低位 24 位)是扩展标识符，一个地址块可以生成2^24个不同的地址 交换机😀交换机刚接入以太网时，交换表是空白的，交换机通过自学习算法处理收到的数据帧，从而逐步建立起交换表：交换机每收到一个数据帧，就将其源地址写到交换表的地址项，将其进入的接口写到交换表的接口项 帧转发过程 转发帧。查找交换表 如没有，则向所有其他接口（进入的接口除外）转发。 如有，则转发给对应接口。 若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧 VLAN😀虚拟局域网 VLAN（Virtual LAN） 这图什么意思呢？是说原来的局域网分配的不合理，可以通过VLAN重新分配局域网。 举个例子：公司原来是每层楼一个部门（财务部，开发部），每层各自为一个局域网，有一天领导改战略了，每层楼组成一个子公司，财务人员和开发人员都分区各个子公司，但是电脑呢还是想开发人员和开发人员共用一个局域网，那么就可以添加交换机4，重组VLAN，如上图，VLAN1为一个局域网，VLAN2为一个局域网。 交换机的接口分为两种类别： 接入接口（access接口）：用于连接主机设备，只能转发某一特定VLAN的数据。即上图的交换机1-3的1-4号接口 干道接口（trunk接口）：通常用于交换机互连，它能转发所有VLAN的数据。即上图的交换机1-3的5号接口，交换机4的1-3号接口 4. 网络层😀网络层负责的是主机到主机之间的通信以及IP数据包的路径选择 链路层是两个节点之间，网络层是多个节点可能构成不同的通路，负责选择路径 网络层提供无连接的，尽最大努力交付的，不可靠的传输服务 这一层最主要的是IP(Internet Protocol)协议，与之配套的 地址解析协议 ARP(Address Resolution Protocol)逆地址解析协议 RARP(Reverse Address Resolution Protocol)网际控制报文协议 ICMP(Internet Control Message Protocol)网际组管理协议 IGMP (Internet Group Management Protocol) IP地址和编址方法😀全世界范围是唯一的32位的标识符，现在由“因特网名字与号码指派公司”ICANN进行分配。 两个特点 ICANN只分配网络号，主机号可以自行编址。 路由器路由表仅根据目的主机所连接的网络号来转发分组，而不考虑目的主机号（下面讲arp的时候会用到，记住它） 编址方法经历了3个阶段：分类的IP地址、子网的划分、构造超网。三个阶段是因为ip地址不够用了，原来的方法要么太多要么太少太浪费了！ 分类的IP地址😀网络号 + 主机号 net-id + host-id 注：判断是否是同一个网络，就看net-id是否一样 分成了这几类 常表示成点分十进制记法，也就是每8个转换成十进制，我们常见的192.168.1.1就是这么来的 有一些ip比较特殊（网络号全0,主机号全0），所以实际上可用的网络号和主机号为 说明： A类： 网络位全0为00000000表示本网络，全1为01111111用于软件环回测试(也就是127开头的比如127.0.0.1)，因此要-2 所以第一个可用的网络号为00000001，最后一个为01111110 主机数2^24 - 2，全0和全1的主机号有特殊的作用 B类： 网络位全100000000 00000000不指派，因此要-1（B、C类不需要软件环回测试） 所以第一个可用的网络号为100000000 00000001即128.1.0.0，最后一个为10111111 11111111即191.255.0.0 主机数2^24 - 2，全0和全1的主机号有特殊的作用 C类： 网络位全110000000 00000000 00000000不指派，因此要-1 所以第一个可用的网络号为110000000 00000000 00000001即192.0.1.0，最后一个为11011111 11111111 11111111即223.255.255.0 主机数2^8 - 2，全0和全1的主机号有特殊的作用 特殊作用究竟是指什么呢？这里有一张表 划分子网和子网掩码😀分类的IP地址有不合理的地方，比如我编址的时候有300台机子，C类网络不够，B类又太浪费。 引入了子网掩码的概念：子网掩码说白了就是11100000…000这样的标志位，和ip地址一样也是32位，1代表网络位，0代表主机位。如何得到网络号呢？用ip和子网掩码相与，由于&amp;运算的性质，会使得网络号留下，主机号全变为0，。 比如192.168.10.1,子网掩码是255.255.255.0，那么二进制来看，192.168.10都能&amp;1被保留下来，而最后的.1&amp;0，得到0，那么就得到了网络号192.168.10.0 这样一来，可以任意的划分网络位了，7位，10位，12位…… 因特网规定：所有的网络都必须使用子网掩码，在路由器的路由表中也必须有子网掩码字段 如果一个网络不划分子网，则该网络使用默认的子网掩码 注：划分子网属于单位内部的事情，对外仍然表现为一个网络 ABC3个企业都是300人，申请了3个B类子网，现在可以成立一个联盟，申请一个B类网络，划分给3个企业 无分类编址CIDR😀划分子网在一定程度上缓解了因特网在发展中遇到的困难。然而因特网仍然面临三个必须尽早解决的问题：B类地址在1992年已分配了近一半，眼看就要全部分配完毕！因特网主干网上的路由表中的项目数急剧增长。整个 IPv4 的地址空间最终将全部耗尽 CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，将IP地址分为两部分：前面部分是网络前缀，用于指明网络，后面部分指明主机。即网络前缀 + host-id 斜线记法：如128.14.35.7/20表示前面20位是网络前缀，后面的12位是主机号 假设一个企业有800台主机，2^9&lt;800&lt;2^10，32-10=22，现在可以申请一个网络前缀为22的地址块了 最长前缀匹配：如果路由表两条路由都可以匹配，优先选哦前缀最大的，也就是22和25要选25 如果 构造超网（路由聚合）😀构成超网，也称为路由聚合，目的在于减少路由表的路由条目 化成二进制一看就明白了，不解释 编址题😀先编网络，根据题目对应的编址方法（分类/子网/超网）合理的划分对应的网络，怎么才算合理？要看主机数量，比如下面这题，如果题目制定采用分类的IP地址进行编址，发现同一网络主机数量最多为4台，加上路由器的接口也才5个主机号，那么肯定采用C类 如果题目允许自由发挥，那么我随便编，比如222.1.x（当然每个点8位最大也是225你不能555.555.1.0），那么LAN1为222.1.1.0，LAN2为222.1.2.0以此类推 路由器之间：每个接口要属于不同的网络，所以才有图中的222.1.4.0，222.1.5.0，222.1.6.0 看一看就会了，采用其他编址方式大体也是一样的，主要是以路由器为划分的网络号不同 分组转发和路由表🤪路由表🤪讲清楚了IP地址，下面我们来看网络中的IP数据包是如何转发的 IP数据报（也称为网络层的分组）是由路由器转发的，路由器转发分组的依据是路由表，路由表最主要的两个信息：目的网络地址，下一跳地址[或转发接口] 目的网络地址：要到达的目的主机的网络号 下一跳地址（遥远网络）：路由器为了能将分组送达目的网络，下一步应将分组交付给哪个IP地址的接口 转发接口（相邻网络）：路由器将分组从自己的哪个接口转发 路由表可以通过以下命令查看 1route -n 要找的ip与子网掩码相与，能匹配的就是下一跳。一般子网掩码为0.0.0.0都是在最后一条，接口enp6s0代表的是路由器，前面的是局域网，当然图中没有局域网，局域网匹配到的话直接走交换机的接口 抽象一点的图可以帮助理解： 路由表中的每一条记录称为一条路由，路由的类型主要有三种： 网络路由：如果记录的是主机号，路由表过于庞大，所以记录的是一个网络 特定主机路由：有时就像指定路由到某一个主机，或者网络管理人员为了更方便地控制网络和测试网络，可以是一个特定的目的主机的IP地址 默认路由：0.0.0.0，能与所有网络匹配，其实就是现在的路由表中没有，得从因特网找地址 下面是一张带特定主机路由的路由表，自己试试写下一跳看掌握没有 分组转发算法😀 从数据报的首部提取目的地址D, 和子网掩码相与提取出目的网络地址为N N为本网络则直接通过arp协议转发到目的主机(arp协议下面会讲)，否则执行3 若网络 N 与此路由器直接相连，则把数据报直接交付目的网络，随后经arp协议交给目的主机，否则间接交付，执行4 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行5 对路由表中的每一行的子网掩码和 D 逐位相“与”看是否有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器，否则执行6 走默认路由0.0.0.0，从internet上找 找不到，分组转发出错 ARP协议😀地址解析协议ARP：就是将同一个局域网内IP地址转换为MAC地址 还记得数据链路层说的“主机A/路由器发送帧给主机D时查找和建立交换表的过程吗”（不记得的可以点击目录中的“交换机”那节），主机A怎么知道要发送给主机D呢？通过IP地址？ip地址是个虚拟的东西，必须要映射成物理地址（MAC地址才可以知道是哪台主机） 或者看前面说的ip分组转发，转发到目的网络了，如何给目的主机呢？ip是不行的，必须要物理地址 arp协议相当于网络层和数据链路层中间的一个东西 每一个主机、路由器都设有一个 ARP高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表 可以通过arp -a命令来看arp映射表 太少了效果不是很好，其实就是ip和mac 1. 当主机A（或路由器）欲向本局域网上的某个主机B（或路由器）发送IP数据报时，就先在自己的 ARP 高速缓存中查看有无主机B的IP地址 2. 如有，则将其对应的硬件地址写入MAC帧，然后通过局域网将该MAC帧发往主机B 3. 如果没有，则进行ARP广播，得到主机B的硬件地址，写入MAC帧，再发送 如何验证呢？ 还是通过抓包 1tcpdump -nn -i enp6s0 -p 80 or arp 另一个窗口 1arp -d 本机ip &amp;&amp; curl www.baidu.com 如果没有建立过映射，那么在三次握手之前会发arp包 5. 传输层😀提供端到端的逻辑通信，也就是端口或者说进程之间 Socket😭我们说网络编程学过socket，它到底是什么？他是网络中进程通信的一种方式。起源于Unix/Linux基本哲学之一就是“一切皆文件”，理解为一种特殊的文件，用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来完成网络间的进程通信。Socket不是什么模型啊层啊，只是一个接口，接口无非就是类似协议/标准/规范嘛，TCP/UDP连接就可以用它来实现建立 我们能看到吗？能！文件嘛怎么不能看到呢！我们首先要抛开java的socket封装，咱们用ubuntu看看这个socket“文件” 和百度进行socket连接 exec 8&lt;&gt; /dev/tcp/www.baidu.com/80 使用的是tcp方式（别问为什么tcp这个目录就可以建立tcp连接，还是那句话，一切皆文件） 8是什么？8就是这个socket文件 &lt;&gt;是输入输出流 翻译过来就是：用一个称为8的文件代表了这个socket连接 建立了tcp连接后可以发送http请求根目录 echo -e &quot;GET / HTTP/1.0\\n&quot; 1&gt;&amp; 8 echo是输出， -e是解析\\n转移字符串，1是输入流，&gt;是重定向，也就是本来echo是输出在控制台上的，用了&gt;就被输入到了这个叫8的文件中去 既然发送了请求，打开看一下这个8响应了什么？ cat 0&lt;&amp; 8 这不就是我们熟悉的http响应头和html嘛，这不就是所谓的tcp后发送了http嘛 从目录中看看这个8，也就是这个socket文件 $$代表当前进程的意思，/proc里面一个进程就是一个文件夹，别问我为什么文件夹可以代表进程，问就是linux一切皆文件 总之，我想说的就是socket是确实存在的，让你能真实的感受到这个socket像一个管道一样能输入输出进行进程间的通信，在linux下表现为一个文件，其他系统有其他系统的表现方式 套接字究竟是什么😭我们常把socket翻译成套接字，套接字是什么？为什么要这么翻译？所谓套接字，就是 src: port -&gt; dest: port 你想，网络中主机和端口千千万，将某两个对应起来，这不就“套接”上了嘛，所以叫套接字 我们通过netstat命令可以查看，这个命令使用来查看网络状态的 1netstat -natp 参数t代表只看tcp的，n代表不解析名称（否则local那里显示的是wjw）p代表显示pid（就是最后一列），a自然是代表全部 参考：简书yongfutian 链接：https://www.jianshu.com/p/066d99da7cbd 三大要素🤪与其说是socket三个参数，不如说是网络进程通信的三大要素 （ip地址，协议，端口） 协议就是tcp和udp，当然实际上参数为以下两个 SOCK_STREAM：表示面向连接的数据传输方式，也就是建立tcp连接 SOCK_DGRAM：表示无连接的数据传输方式，即udp 端口，服务端需要监听一个端口（不能冲突），客户端的端口是随机的（0～65535） 这里有一道面试题：两个服务端ipA:80，ipB:80，问客户端ipC最多可以建立多少个tcp/udp连接？或者说socket连接 要想弄明白这个问题，首先是看服务端，两个不一样的ip，肯定没有关系，比如ipA是阿里的服务器，ipB是腾讯的服务器，都能用80端口对吧，不影响，这个好理解。问题在于客户端呢？我们说不考虑任何系统和其他应用进程的情况下，最多是65536个，那么ipC:3000访问ipA:80后还可以访问ipB:80吗？ 答案是可以，我们说socket是采用套接字，也就是src: port -&gt; dest: port，那么ipC:3000 -&gt; ipA:80和ipC:3000 -&gt; ipB:80自然不是一个东西(其实就是上面netstat那张图的最后一列PID) 题目2：客户端多个连接，服务端消耗多少个端口号？这个问题比较简单，答案就是监听的那一个，不管多少个连接进来，linux表现为fork那个文件8，java表现为开启一个线程完成请求。但是端口代表进程，一直就一个 能不能多个socket对应一个进程呢？能！这个就叫做多路复用比如epoll，这里就不展开了，埋个坑以后有机会填 UDP😀用户数据报协议 UDP (User Datagram Protocol) 特点😀 面向数据报（无连接） 最大努力交付（不可靠） 一次发送一个报文（不分段） 支持一对一、一对多、多对一和多对多的交互通信 开销小 首部格式😀 伪首部仅仅是为了计算检验和 计算检验和😭 停止等待协议ARQ//TODO TCP😀传输控制协议 TCP (Transmission Control Protocol) 特点😀 面向连接 字节流，可拆分 可靠交付 一对一 确认、超时重传、流量控制、拥塞控制 首部格式😀 三次握手😀 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1(这是值而不是标志位)，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK标志位是否为1，如果正确则将标志位ACK置为1，并将该数据包发送给Server，Server检查ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 四次挥手😀 第一次挥手，客户端设置seq和 ACK ,向服务器发送一个 FIN(终结)报文段。此时，客户端进入FIN_WAIT_1状态，表示客户端没有数据要发送给服务端了。 第二次挥手，服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态 第三次挥手，服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入LAST_ACK状态。 第四次挥手，客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。 为什么第二次挥手的时候服务端不发FIN直接关闭？ 因为服务端还有数据未发送，发送完再主动关闭 一张充满水印的图道清了一切… 6. 应用层😀HTTP😀常见的HTTP请求动词😀 GET: 从服务器获取资源POST: 在服务器新建资源PUT: 在服务器更新资源DELETE: 在服务器删除资源HEAD: 获取资源的元数据OPTIONAL: 查询对指定的资源支持的方法 HTTP状态码表😀 状态码 状态码英文名称 中文描述 1** 信息，服务器收到请求，需要请求者继续执行操作 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 2** 成功，操作被成功接收并处理 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 3** 重定向，需要进一步的操作以完成请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 4** 客户端错误，请求包含语法错误或无法完成请求 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 5** 服务器错误，服务器在处理请求的过程中发生了错误 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 HTTP和HTTPS的区别🤪HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）是身披SSL外壳的HTTP，与HTTP明文协议对比，HTTPS具备两大网络安全功能：加密以及身份验证。 加密：HTTPS传输协议可对客户端与服务器之间的传输数据进行加密，防止第三方的窃取、篡改、窥视等中间人攻击（中间人攻击可以看大佬的讲解https://www.zhihu.com/question/304030251）。 身份验证：客户端用户可通过HTTPS背后的SSL证书对服务器进行身份验证，辨别真假网站，避免掉入钓鱼网站的陷阱。 //TODO 输入网址敲下回车后发生了什么😀第一步：浏览器查找域名的IP地址（DNS协议） 查找浏览器缓存：因为浏览器一般会缓存DNS记录一段时间，如果有缓存则返回IP 查找系统缓存：浏览器会进行系统调用，查找本机的hosts文件，如果找到则返回IP 查找路由器缓存：借助网络，路由器一般都有自己的DNS缓存，会去查找ISP 服务商缓存DNS的服务器，如果查找到则返回IP 递归查询：所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文 迭代查询：其他根域名服务器告诉本地域名服务器下一级的服务器ip，本地域名服务器向这个服务器ip查找，再得到下一级，本地域名服务器再查找，直到找到想查找的域名对应的ip，本地服务器再发送给主机 第二步：浏览器与目标服务器建立TCP连接（TCP协议） 三次握手，参考上面第5小结TCP三次握手 第三步：浏览器发送HTTP请求（HTTP协议） 就是我们熟悉的http请求，这里包括了请求头，get的话可能会有查询字符串，post的话可能还有请求体： 第四步：可能会有重定向 部分网站会显示300开头的重定向，这是因为有些网站展示页需要做SEO优化。为了提高SEO排名，通常将www.wjw.today和wjw.today绑定为一个网站，统一经过一个服务器，再做负载均衡到不同主机服务器。 如果有重定向，那么获取到重定向的访问地址后，会再发送一次http请求 第四步：服务器处理和响应 也就是我们常说的后台，接收到请求后做处理，通常是操作数据库啦等等等等，然后返回一个响应，可能是整页HTML，也可能是现在流行的json，并返回一个200 OK状态码 第五步：释放TCP连接 四次挥手，参考上面第5小结TCP四次挥手 第六步：浏览器渲染 浏览器根据Content-type对返回的数据进行渲染，html就是text/html，json是application/json，这里通常都是异步的，浏览器不需要完全接收到响应数据包就已经开始渲染了，接收到数据后再进行相应的渲染。接下来是一些样式/图片/js文件，浏览器通过这些文件的url发送对应的请求，和之前的html页面一样的过程，只是有时这些文件不在自己的服务器，而是缓存或者cdn托管 参考 https://blog.csdn.net/jiao_0509/article/details/82491299","link":"/cs/network/"},{"title":"阿里短信","text":"注册的时候或者什么时候，可以使用短信验证码，记录一下阿里短信的使用 1. 登录阿里云后先给自己的账户充值阔气的大手一挥，充他个2块钱 2. 设置一些必要的东西查看阿里云官方的使用文档，跟着步骤来即可，虽然看起来很复杂 主要需要的东西包括 AccessKey ID AccessKey SECRET 签名 模版CODE AccessKey SECRET只有在创建的第一次可以看到，记得记录下来，错过了就要再创建一个，提醒一下，虽然创建只需要点一下鼠标。 3. Java SDK使用官网的文档也写得很详细了 maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt;&lt;/dependency&gt; 代码就直接从官网生成的模板拉下来就可以运行了 由于真正使用的时候电话号码是用户填写的，验证码是随机生成的，签名和模板不一定都只使用一套，总之，不能写死。写一个Util工具类，用参数的方式传进去，只需要替换成自己的accessKeyId和accessKeySecret就可以使用了 12345678910111213141516171819202122232425262728293031323334public class SmsUtils //产品名称:云通信短信API产品,开发者无需替换 static final String product = \"Dysmsapi\"; //产品域名,开发者无需替换 static final String domain = \"dysmsapi.aliyuncs.com\"; static final Logger logger = LoggerFactory.getLogger(SmsUtils.class); public CommonResponse sendSms(String phone, String code, String signName, String template) throws ClientException { DefaultProfile profile = DefaultProfile.getProfile(\"cn-hangzhou\", \"替换成你的accessKeyId\", \"替换成你的accessKeySecret\"); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(\"dysmsapi.aliyuncs.com\"); request.setSysVersion(\"2017-05-25\"); request.setSysAction(\"SendSms\"); request.putQueryParameter(\"RegionId\", \"cn-hangzhou\"); request.putQueryParameter(\"PhoneNumbers\", phone); request.putQueryParameter(\"SignName\", signName); request.putQueryParameter(\"TemplateCode\", template); request.putQueryParameter(\"TemplateParam\", \"{\\\"code\\\":\\\"\" + code + \"\\\"}\"); request.putQueryParameter(\"OutId\", \"suibian123\"); CommonResponse response = client.getCommonResponse(request); logger.info(\"发送短信状态：{}\", response.getHttpStatus()); logger.info(\"发送短信消息：{}\", response.getData()); return response; }} 当然，accessKeyId和accessKeySecret也可以不写死，通过properties或yml文件来读取，那就最好了，不展开了 最后上效果图","link":"/Others/ali-mail/"},{"title":"锁和同步","text":"引言本文将介绍synchronized，cas等概念 1. Synchronized1.1 锁对象是谁加在代码块上 1234Object o = new Object();synchronized(o){ //对象o就是这把锁} 加在方法上 1234public synchronized void fun(){ //本类的对象就是这把锁 //等同于synchronized(this)} 加在静态方法上 1234public static synchronized void fun(){ //本类的Class类对象 //等同于synchronized(这个类.class)} 只要锁是同一把即可实现同步 踩坑！！！要注意有些时候锁住的并不是同一把锁 你以为你锁住了它，其实并不然 比如前面的加在代码块上那段，如果这样写： 1234567891011121314151617181920212223242526272829/** * @author wjw * @date 2020/11/21 14:56 */public class Synchronized锁对象踩坑说明 { public static void main(String[] args) { TestSynchronized test = new TestSynchronized(); for (int i = 0; i &lt; 1000; i++) { new Thread(()-&gt;{ test.fun(); }).start(); } }}class TestSynchronized{ private int num = 0; public void fun() { Object o = new Object(); //注意这里是在方法里面 synchronized(o){ for (int i = 0; i &lt; 1000; i++) { System.out.println(Thread.currentThread().getName() + \" : \" + num++); } } }} 在多线程下每调用一次fun，锁对象o其实都new了，不是同一个，所以是起不到同步作用的，可以跑跑看，这里设置的线程数和量都比较大，不然不明显 一个是最终的结果其实是不对的 还有一个是过程可以看到其实线程之间很多时候是穿插执行的 所以正确的写法应当将锁对象o放在类中，通常将锁对象用final修饰(加不加都行，只是说一般都会加)，或者在main里面传过去，不管怎样，只要保证同一把锁就行 12345678910111213class TestSynchronized{ private final Object o = new Object(); //将锁对象放在类上 private int num = 0; public void fun() { synchronized(o){ for (int i = 0; i &lt; 1000; i++) { System.out.println(Thread.currentThread().getName() + \" : \" + num++); } } }} 结果如下图，可以看到结果是对的，且线程之间都是间隔的，这才是真正做到了同步 再比如同时有一个synchronized静态方法，和synchronized方法，也是不同的锁，并没有锁住整个类这个说法，只是将这个类的class对象作为了锁对象！！！ 参考 https://www.cnblogs.com/codebj/p/10994748.html 1.2 锁升级过程旧版本java的synchronized是直接到重量级锁的，1.6以后是一个锁升级的过程： 没有锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁 偏向锁：严格来说不是锁，只有一个线程的时候，synchronized将线程标识贴在对象的markword上（markword在附录：Java对象组成中介绍了），就代表该线程持有了锁，有偏向锁的概念是因为很多时候我们用Vector，HashTable，StringBuffer的时候其实只有一个线程，如果直接锁竞争会浪费资源 轻量级锁：两个及以上线程开始锁竞争，升级成轻量级锁。说到底就是一个while循环，会消耗cpu资源，但是如果线程的任务不重，其过程是很快的 重量级锁：自旋一定次数后升级为重量级锁，进入等待队列，交由os调度，每次调度会有用户态到内核态的切换 在JDK1.6中自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整 JDK1.7后，去掉此参数，由jvm控制，在新的HotSpot VM里，使用动态调整的次数，所以叫做adaptive spinning（自适应自旋） https://www.zhihu.com/question/31187779 1.3 轻量级锁一定比重量级锁效率高吗当然这么问了答案肯定是不一定，我们分别分析他们的开销 轻量级锁主要的开销在while会消耗cpu的资源，重量级锁主要的开销在用户态和内核态的切换 也就是说取决于任务，如果任务简单，锁竞争的线程少的情况下while循环等待的时间是很少的，如果任务时间很久或者等待的线程太多，进入任务队列采用重量级锁反而更高效，synchronized的锁升级也正是基于这个考虑来实现的 2. CASCompareAndSwap，比较并交换，也叫自旋锁，是乐观锁的一种实现 相比于synchronized关键字， JUC（java.util.concurrent）包下所有类都是基于CAS的 2.1 说明比如线程1要将变量a的值+1，那么线程1进行如下操作 读取a原值 –&gt; +1 –&gt; 写回前判断此时a是否还是原值 –&gt;是则写回 –&gt;否则循环重来 2.2 以AtomicInteger为例AtomicInteger就是JUC下的一个类，相比于num++，它的incrementAndGet()方法可以保证原子性，于是就不用synchronized进行同步了 123public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1;} 跟进 1234567891011public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;}//再跟进就看到是native方法了public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 2.3 ABA问题就是说线程1将a的值从8变为9，写回之前线程2将8变为100，线程3又将100变回8。此时线程1不是要写回前判断嘛，判断结果还是8，他以为没有变，其实中间经历了一个变化又变回的过程。 ABA问题结果其实是正确的，主要取决于你的业务在不在乎。就像是跟女朋友分手了，然后女朋友跟别的男生好，中间经历了别的男人，现在她想和好，此时女朋友还是那个女朋友，但好像又不是那个女朋友，取决于你在不在乎罢了。 解决方式就是加版本号， //TODO 具体是怎么加的 2.3 CAS修改值的原子性也就是判断完还是原来的值以后，要写回，这一步要保证是原子性。比如两个线程都是将0进行++，如果这里没有保证原子性，也就是没有任何同步手段，可能两个线程判断完原值0然后++，结果为1而不是2。那这一步是如何保证原子性的呢 我们下载open jdk的源码，可以找到刚刚那个native的名字相同的对应cpp文件unsafe.cpp，找到对应方法Unsafe_CompareAndSwapInt() 继续跟进Atomic::cmpchg() 有个__asm__汇编指令，LOCK_IF_MP，继续跟进会发现最终实现为lock cmpxchg指令。 在硬件层面，lock指令能锁定信号北桥，也就是锁总线，几乎所有cpu都支持lock指令 ps:MP是multi processor的意思，就是说多核的时候才lock，否则只执行cmpxchg，当然现在的cpu都是多核 附录Java对象组成markword：存储对象的HashCode,分代年龄和锁标志位信息 klass pointer：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个 类的实例 instance data：实例数据 padding：因为一定要是8kb的倍数，所以会扩展一些没有意义的内容 我们可以通过jol工具查看 12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt; 12Object o = new Object();System.out.println(ClassLayout.parseInstance(o).toPrintable()); 结果如下 当我们加上synchronized 123synchronized (o){ System.out.println(ClassLayout.parseInstance(o).toPrintable());} 其实就是锁信息，这个对象被作为锁使用，也就是所说的偏向锁的原理 缓存行Cache Line计算机cpu和主存之间读取数据速度差距太大，所以采用了三级缓存（三层是工业实践的结果），读取进缓存的时候是每次读取“一块”，这个块实际上就是一个缓存行，现在是64字节（工业实践的结果） 缓存一致性，有了缓存行的概念之后，要明白一个问题，就是如下图，当两个数据在同一个缓存行的时候，如果cpu1（或者某个核或者某个线程）修改了x，会通知其他cpu/核/线程，来回通知是会降低效率的 其实这不是很概念很虚的东西，我们可以通过两个有趣的程序来对比感受到缓存行是真实存在的 123456789101112131415161718192021222324252627282930313233343536373839public class 缓存行示例1_同一行 { public static long COUNT = 1_0000_0000L; private static class T{ public volatile long x = 0L; } public static T[] arr = new T[2]; static { arr[0] = new T(); arr[1] = new T(); } public static void main(String[] args) throws InterruptedException { CountDownLatch latch = new CountDownLatch(2); Thread t1 = new Thread(()-&gt;{ for (int i = 0; i &lt; COUNT; i++) { arr[0].x = i; } latch.countDown(); }); Thread t2 = new Thread(()-&gt;{ for (int i = 0; i &lt; COUNT; i++) { arr[1].x = i; } latch.countDown(); }); final long start = System.nanoTime(); t1.start(); t2.start(); latch.await(); System.out.println((System.nanoTime() - start) / 100_0000); }} 这段程序非常非常简单，抛开计时等不重要的代码，说到底不过是两个线程对一个T[]数组操作，T其实只有个long成员，也就是说，线程1改变T[0]的值，线程2改变T[1]的值。 结果如下 要明白，数组是申请了连续的内存，一个long占4个字节，那么这个arr包含两个long也就是连续的16个字节。 那么根据前面说的，将内存中的数据读取一个缓存行64字节进入cache，也就是说arr[0]和arr[1]都在同一个缓存行中，线程1线程2都将它们保存进自己的cache。线程1/线程2分别修改arr[0]/arr[1]的时候，需要通知对方，情况也就完全和前面那张示例图一样了。 第二个程序只需要将class T的声明改成如下，其他完全一样 12345private static class T{ public long p1, p2, p3, p4, p5, p6, p7; //前面7个 public volatile long x = 0L; public long p9, p10, p11, p12, p13, p14, p15; //后面7个} 这样一来，x前面有7个long，后面有7个long，算上x，8*8=64个字节，也就是说arr[0]中的x和arr[1]的任何一个元素都不会在同一个缓存行 此时修改的时候不需要通知对方，因为对方的缓存行中没有保存自己修改的数据 执行结果如下： 可以看到确实快了不少 你可能会问，真的有人这样写代码吗？ 你好，有的。有个单机版最快MQ叫disruptor，里面的RingBuffer类的父类就有如下代码 讲个题外：MESI只是因特尔的缓存一致性协议，不要一讲到缓存一致性协议就是MESI 主存和内存不是同一个东西计组一些基础概念，学的时候就很疑惑，比如主存是不是我们说的内存条啊什么的，学很久了怕自己忘记，先记下来 内存是个很宽泛的概念，不同的书定义也不同，但是一般认为内存是包括cache和主存的 知乎上看见一张不错的图： 参考 知乎：乔乔-缩头者的回答https://www.zhihu.com/question/28445273","link":"/Java%E5%9F%BA%E7%A1%80/%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5/"},{"title":"Unity3D学习笔记","text":"本笔记是学习自夏村散人韩老师的unity教程https://www.bilibili.com/video/BV1B7411L74W，自己的一些记录和整理 一、基础1.1 unity编辑器右边栏是组件栏，物品、地形、相机等全都是对象GameObject，每个GameObject有自己的组件component，基本上所有物体都包含transform组件用于缩放和旋转。地形，相机等特殊物体可能有自己特殊的组件。 1.2 地形系统创建地形 笔刷（依次是抬高降低、空洞、纹理、平台高度、平滑） 纹理 1.3 标准资源包18年后的版本需要自己下载，可以在官网下载 [https://assetstore.unity.com/top-assets/top-download?q=Standard%20Assets&amp;orderBy=1](https://assetstore.unity.com/top-assets/top-download?q=Standard Assets&amp;orderBy=1) 也可以直接在编辑器windows-&gt;assets store 报错可以参考这个教程 https://blog.csdn.net/zhang2333333333/article/details/105000621 1.4 脚本脚本也作为一种component，可以添加c#脚本，其中自带的start和update函数就是生命周期，会自动调用，其中start在GameObject初始化时调用一次，update每帧调用一次。public成员可以在脚本完成后通过unity编辑器拖拽给物体作为参数传入。 下面介绍一些脚本相关的类（组件）： Transform：可以对应一个unity中的GameObject 具体的类和方法可以看帮助 点击后打开api页面可以搜索 其中，manual是以教程的形式，api只是单纯的用法和参数介绍 如果没有代码提示，是由于默认编辑器没有设置的原因，参考 https://blog.csdn.net/LiYAnErr/article/details/105137157 以下是一个镜头跟随脚本demo 1.5 发布 若要选择窗口等模式，如下： 1.5.1制作游戏欢迎页面1.unity中一个页面scene其实就是一个关卡，因此欢迎页可以视为一个关卡，该关卡啥都没有，只有一个脚本，按下某个键就开始游戏 scene名字随便起，比如叫welcome 2.脚本 脚本名字不能随便起，叫GameManager（也不是不能随便起，只不过叫这个的话可以拥有一个特殊的图标） 3.将脚本应用到物体上，理论上可以应用给场景默认自带的光照或者相机都可以，但是标准的应该是在该场景新建一个空的GameObject，并将脚本拖拽给他 4.调整发布场景编号 1.5.2 非全屏 二、动画2.1 场景动画unity支持外部动画模型导入（比如maya和3dmax），成为模型动画。当然也可以在unity中制作简单的动画，称为场景动画 2.1.1 录制 选择动画片段保存位置 点击录制按钮 2.1.2 多段动画的状态机转换可以添加多个动画片段 添加多个动画片段后，默认只会播放第一个 如果需要组织多个动画片段，就需要animator controller 调整状态机使其能够转换到另一个动画片段 效果就是动画连着播放，然后在最后一个动画循环 除了鼠标操作状态机，也可以通过脚本进行特定条件下状态机的转换，如下创建一个转换条件c 有Float, int, bool, trigger类型，最后一个是触发器，也就是脉冲，触发完一次会自动回到初始状态等待下一次脉冲 然后添加一个脚本，指定触发条件 将脚本拖拽给cube，即可自动创建出animator controller这个组件 效果：停在第二个动画反复循环，按下空格（并当当前动画放完之后）才进入第三个动画 若需要按下空格时强制跳转到第三个动画，如下取消勾选 2.1.3 eventevent事件，用于在某个特定时间点执行某个脚本中的函数 首先添加一个函数，这里是销毁，我们的目的是在最后一个动画结束后销毁 然后在最后一段动画（缩放的某个地方添加一个event），填入函数名 2.2 骨骼动画2.2.1 space robot kyle资源包和配置unity官方提供的一个资源包，可以在商店搜索下载 将rig调整为类人骨架humannoid，记得点击apply 这个骨架有个好处是可以容易的实现动画重定向（为一个骨架设计的动画可以移植到另一个骨架上），点击apply后configure按钮亮起，点击可以看到如下界面 这只是一个模型，拉取到场景中没有动画效果，我们可以从标准资源包如下位置拉取一个预实现看看效果 2.2.2 骨骼动画交互效果说明对比我们可以发现预实现的人物有animation controller 我们可以为自己的机器人模型也添加同样的controller 人物随之可以摆动，但没有键盘交互效果 不难发现，预实现的人物对象中还有一些脚本 第一个脚本有[RequireComponent(typeof (ThirdPersonCharacter))]，也就是包含了第二个脚本 所以我们只需要把第一个脚本拖拽给自己的模型 我们通过右边的capsule将框架调整到如上图所示大约包裹身体，此时运行如下图所示 这是由于地面检测原因，将其调大即可 2.3 曲线曲线是用函数的形式让时间和某个变量关联起来，即value = func(time)，func可以是二次函数或者别的函数，value的值便会发生变化，可以用这个值影响动画 比如：机器人在跑步的时候如果想让他吹一个泡泡，泡泡随时间变大变小 新建一个场景，添加机器人，新建一个animation controller，新建一个空状态，为状态添加一个人物跑步动作 并拖拽给机器人，机器人可以跑步 为了更好的演示，将机器人取消连接根节点（应该就是不转换为世界坐标），便可以原地跑步 接下来添加曲线，在controller的parameters中添加参数，参数名很重要，然后点击motion，unity会自动定位这个run动作的位置，点击它 点击edit便可以编辑属性值 找到曲线，添加， 曲线的名字必须跟parameters中某个变量的名字一样，点击曲线并选择一种曲线 选完后一定要点击一下下面的apply 下面来创建泡泡，新建一个GameObject命名为泡泡，并作为头部的子物体 点击transform中的reset，球体便会将本地坐标变为头部位置（和头部重合） 再将泡泡细微调整以下 新建脚本，设置机器人的动作（其实是设置机器人里面泡泡的动作） 这里的bubble当然也可以直接设置为public，然后再unity中直接将泡泡拖拽赋值。因为这个脚本最终会拖拽给机器人，泡泡是机器人的子物体，所以可以设置为private然后通过transform的Find函数获取子物体。 完事，运行，可以看到机器人跑步的过程中泡泡变大变小 2.4 动画层动画层就是多个动画叠加，能同时展现，比如边走路边开枪 2.4.1 动画层的添加新建场景，添加机器人，新建animition controller，添加新状态，添加走路动作 默认有个动画层，现在新建一个层比如叫ArmUp 抬手 新建状态Jump，添加motion JumpUp 运行发现并没有叠加动画，因为第二个动画没有添加权重 需要注意的是，blending采用的是override模式，所以ArmUp权重越大，手抬得越高，但是BaseLayer中的walk速度变慢了！！！ 而如果采用addtive，则是叠加，整个人都被抬起来，效果就会变得走起路来一震一震的 2.4.2 遮罩mask如上所说，如果要某一部分不受影响怎么做呢？手臂抬起来，但是同时也要正常走路，就需要mask遮罩 新建avatar mask，并打开 如下图所示将下半身的活动屏蔽 为该层的动作选择一层遮罩 这时候运行，就可以看到手抬到了最高（权重为1），walk也正常走路 2.4.3同步SyncSync按钮的意思是当前层不使用自己的动画状态机，而是用别的层已有的动画状态机。举个例子：走路，如果人物被击中那么走路的姿势就不太一样了，而其他的逻辑一样（如果其他逻辑比较复杂），那么就可以在其他层使用Sync，方便逻辑的复用 2.4.2 脚本方式叠加层很多时候需要通过脚本的方式完成更加复杂的动画层逻辑，比如和鼠标交互 下面示例是按下鼠标左键，增加armUp的权重，最后增加到1 新建脚本 将脚本拖拽给机器人，并将一开始的ArmUp层权重设置为0，运行就可以看见效果了 一开始手放下，鼠标长按慢慢抬起，松开又慢慢放下 2.5 逆向运动学：注释动画前面的场景动画和骨骼动画都属于前向运动学，也就是说每一个骨骼节点的动画效果其实是一层一层推出来的，比如抬起股关节，再抬起膝关节那么就表现为抬腿动作。 但有些情况下需要逆向推导，比如已知前面有个苹果，手指要碰到，那么肘关节和肩关节怎么转才显得比较自然呢？又或者已知一个方位（比如看像鼠标移动的位置），那么逆推头和腰的转向。这种，依靠终端节点（指关节）逆向推演其他节点如何配置的过程就叫做逆向运动学（IK，全称inverse kinematics） 下面的示例就展示机器人的注视点跟随鼠标移动 新建场景、animator controller，添加状态和motion为idle（一种悠闲自然站立，身体轻轻摇动的动作）并拖拽给机器人，新建脚本 123456789101112void OnAnimatorIK(){ Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); // 以MainCamera为起点，mousePosition为方向 Plane plane = new Plane(Vector3.up, transform.position); // 以机器人的中心为平面上一点，(0,1,0)为法线做一个水平面 float enter = 0.0f; // 距离 if (plane.Raycast(ray, out enter)) // 平面的方法：计算交点，并将交点和ray原点的距离赋值给enter变量 { Vector3 target = ray.GetPoint(enter); // 射线的方法：从原点走enter的距离的点 anim.SetLookAtPosition(target); // 和相机LookAt不同，是anim中的方法 anim.SetLookAtWeight(0.3f); }} 在动画层勾选IK Pass，表示允许使用IK方式确定角色姿态 效果：机器人目光跟随鼠标，实际上是相机和鼠标形成的射线和机器人水平面的交点 SetLookAtWeight这个函数可以有多个参数，使得身体，头，眼睛都运动起来 anim.SetLookAtWeight(0.5f, 0.3f, 0.6f, 0.2f); 2.6 逆向运动学：末端节点动画前面提到，除了注视动画，还有逆向计算手触碰物体时手肘等节点的动画，当然脚也一样。这就是另一种：末端节点动画。 脚本如下 12345678910111213141516171819202122232425262728293031323334353637383940using System.Collections;using System.Collections.Generic;using UnityEngine;[RequireComponent(typeof(Animator))]public class IK2 : MonoBehaviour{ private Animator animator; public Transform target; // 手或者其他末端节点需要触碰到的位置 public Transform hint; // 参考位置：表示手不够长时，需要肘部也改变，肘部节点触碰到的位置 public bool isHand = true; // 我们做一个手和脚的，这个变量判断是手还是脚 // Start is called before the first frame update void Start() { animator = GetComponent&lt;Animator&gt;(); } private void OnAnimatorIK(int layerIndex) { AvatarIKGoal g = isHand ? AvatarIKGoal.RightHand : AvatarIKGoal.RightFoot; // 末端节点 AvatarIKHint h = isHand ? AvatarIKHint.RightElbow : AvatarIKHint.RightKnee; // 参考节点 // 末端节点信息：其中的权重表示：是完全触碰目标点还是更多的照顾姿态的自然度 animator.SetIKPositionWeight(g, 1f); //全部交给ik控制则1，否则在0-1之间 animator.SetIKPosition(g, target.position); animator.SetIKRotationWeight(g, 1f); animator.SetIKRotation(g, target.rotation); // 参考节点信息 animator.SetIKHintPositionWeight(h, 1f); animator.SetIKHintPosition(h, hint.position); ; } // Update is called once per frame void Update() { }} 新建一个target小球 为其制作小球掉落再弹起的动画 新建空GameObject作为辅助结点的位置（手臂，膝盖的位置）并放入机器人内部 运行 (脚朝内是小球的方向问题，将小球绕y轴转180即可) 点击isHand切换成手也类似 可以看出hint节点的位置就是中间节点（手肘，膝盖）触碰的位置 2.7 子状态我们已知animator controller可以新建一个状态，unity支持新建子状态，一个状态包含多个子状态，也就是将这几个子状态封装成一个整体。比如有一个状态是 idel-&gt;walk-&gt;run-&gt;idel，也就是将这几个动作封装成一个状态。 2.7.1 创建子状态新建场景，放置机器人，新建animation controller，新建状态，新建子状态 让idle拥有motion为humannoid idle，make transtion使得idle指向子状态，双击子状态 发现又是一个类似的controller界面 创建walk,run,jump动作并连线，最后指向base layer的idle动作 这样就完成了类似一个函数栈的效果，返回base layer就可以看到下面的效果 将这个controller拖拽给机器人，并使得原地运动，运行 就可以看到一连执行了一串动画，你可能说不用子状态也行，直接全部写外面，当然可以，又不是编程新手了，封不封装都可以的，如果觉得某几个动作都是固定连续发生，可以视为一个动作，就封装吧 2.7.2 带条件转换当然也可以指定触发条件 添加trigger类型的参数 新建脚本 123456void Update(){ if (Input.GetKeyUp(KeyCode.Space)){ GetComponent&lt;Animator&gt;().SetTrigger(&quot;start&quot;); }} 将脚本挂接给机器人，运行，默认idle，只有按下空格才依次进入：walk-&gt;run-&gt;jumpup 同样的可以选择立即触发 2.8 blend tree混合树，和transition类似，可以在多个动画片段之间进行叠加和转换，比如走路过渡到跑步。区别在于transition是一个状态到另一个状态，blend tree可以多个状态作用于角色，各动画可以有自己的权重，然后进行叠加。 2.8.1 创建blend tree新建场景，添加机器人，新建Animator controller，创建BlendTree状态 双击打开，对BlendTree右键可以新建motion，这里建3个 添加motion如下：分别是猫腰走（蹲走），正常走和跑步，同时这里修改了参数名称 在右上角可以看到blend默认是一维的1D，将controller拖拽到机器人身上，运行，运行过程中可以不断调整Speed，就可以发现在三个动作之间平滑的转换动作了。 因此1D的混合树实际效果和transition差不多，只是可能更直观一些。 2.8.2 direct类型下面我们将1D改成Direct 从每个动作右边栏的变化可以看出，Direct是可以为每个动作添加自己的权重的，我们可以建立3个参数分别赋值给三个动作 运行，我们可以在运行的过程中调整各自到合适的权重，运行起来有点奇怪，因为是叠加 我们可以对它归一化 这样我们就可以自由组合出：猫腰跑，慢跑（或者更像竞走）之类的动作 2.8.3 二维笛卡尔坐标是以x y轴的二维布点方式，点和点中间的空白通过插值进行。 这里我们xy轴设置的好，可以当成俯视图来进行布点，因此轴的意义定义很重要 运行并调参，向左向右跑步或者走路 简单的做一个脚本进行交互 12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityStandardAssets.CrossPlatformInput;[RequireComponent(typeof(Animator))]public class BlendTree : MonoBehaviour{ Animator anim = null; // Start is called before the first frame update void Start() { anim = GetComponent&lt;Animator&gt;(); } // Update is called once per frame void Update() { // 跨平台的wsad控制 float h = CrossPlatformInputManager.GetAxis(&quot;Horizontal&quot;); float v = CrossPlatformInputManager.GetAxis(&quot;Vertical&quot;); Vector3 move = v * Vector3.forward + h * Vector3.right; if (Input.GetKey(KeyCode.LeftShift)) move.z *= 0.5f; // 当按下左shift键时从跑步变为走路，变慢 float turn = move.x; float forward = move.z; anim.SetFloat(&quot;Speed&quot;, forward, 0.1f, Time.deltaTime); anim.SetFloat(&quot;turn&quot;, turn, 0.1f, Time.deltaTime); }} 拖拽给机器人，运行，按下wad，和左shift，自己体验吧 3. 图形渲染3.1 全局光照明效果光照分为方向光（新建场景时默认那个太阳就是方向光），点光源，聚光灯和面积光 前三种都属于直接光源，也就是对物体表面产生了直接的影响，用于实时光照，计算量小 为了渲染出更加真实的效果，面积光可以进行预计算，这种计算量很大，通常用于静态渲染，因为物体移动了就会破坏预计算的效果。 当我们创建一种光照的时候，是没有阴影的，如果需要阴影可以自己打开 soft会模糊阴影的边缘。 对于预计算的光照，结果会被烘焙成light map保存，在window-&gt;rendering-&gt;lighting中可以看到auto general这个框框，如果打上，会对场景中勾选了static的物体进行自动烘焙，当然，为了开发时的性能，可以关闭，在发布之前进行一次烘焙。因此，对于不动的物体，我们最好设置为static，可以得到光照效果的优化。 如下图，可以看到设置成static后，绿的的物体的阴影有一点点的绿色，其他物体也一样，更加富有表现力，如果没有static的物体，是不参与这种晕染的 3.2 材质，着色器和纹理光影计算中很重要的三个概念：material，shader，texture 新建一个材质，可以看见材质中包含了shader和uv纹理贴图等各种信息 着色器：像素着色器是负责渲染材质颜色的程序片段，顶点着色器就负责材质表面纹理，法线贴图（粗糙程度），反射率等东西。默认是标准 rendering mode：Opaque是不透明，cutout可以选透明度，fade是消隐可以实现淡入淡出，transparent是透明可以设置透明通道 albedo是基本的颜色，点击圆圈可以选纹理 cutout透明，可以调节透明度 fade，可以根据alpha通道（RGBA中的A）逐步消隐掉物体，跟多的用于魔法效果 transparent也一样，不过会保留光照信息，更多的用于玻璃效果 metallic可以控制金属效果 smoothness可以控制平滑程度，更加接近镜面 normal map保存了法线信息，用于法线贴图 height map 和法线贴图类似，需要和nomal map结合使用，normalmap只是效果改变了，而heightmap使得几何体实际表面受到影响 当然上述所有效果都是基于standard的shader，unity其实自带了许多比如卡通效果，手绘或者简笔画效果等着色器 3.3 摄像机设置可以建立多个摄像机（比如很多游戏的小地图其实是个顶视角摄像机），创建方法和创建普通GameObject一样。 默认主相机main camera会被覆盖，是根据depth覆盖的，主相机的depth是最小的-1，后面建立的相机依次是0，1，2… 如果要多个相机并存，只需要缩小其他摄像机的宽高。因为原理是这样的：其实相机覆盖，就是有一个宽度和默认相机一样的视图直接覆盖了底部的…（我觉得unity是不是有点随便？？） 3.4 剔除也就是不渲染相机看不到的地方 点击右下角的bake，unity会对static物体进行剔除（消隐），注意一定要是static的 除了视野外，还有遮挡，试试创建一个巨大的物体挡住相机并重新bake一下，发现也挡住了 当把物体去除后需要重新bake，否则会维持原效果 3.5 后处理效果PostProcess又叫做全屏幕处理效果，在真正渲染到屏幕之前对后备缓存里的图像处理。可以添加一些比如色调啊之类的。 1.为摄像机添加后处理层 Component-&gt;Rendering-&gt;Post-Process Layer 如果没有这个组件，先在package manager下载 Layer选择PostProcessing，没有就自己新建自定义一个 2.在场景中添加后处理体 是一个大大的绿色cube，不过多了box collider组件 而Profile就是具体的后处理方法，直接新建，双击定位，打开 双击后如下图添加一个， 3.6 探针预处理只能用于静态物体，对于非静态物体，如果需要效果优化，可以使用探针。 探针是在场景中提前布点，如果运动物体移动到了探针区域内，就进行渲染效果优化。 3.6.1 光照探针建立如下场景 为框框中的两个物体添加左右移动动画，接下来添加探针组 这些黄色的点就是探针，场景复杂的时候可以添加的密一点（探针组属性页面可以看到add probe选项，添加探针） 想改变探针布点位置或者添加探针都要先点上图那个允许修改，下面运行，可以看到物体移动时会检测受影响的探针 移动的物体左边有轻微的晕染绿色，右边有轻微的晕染红色效果 3.6.2 反射探针需要注意的是开启全局光照烘焙，最好一直都开（虽然很吃电脑性能），否则看不到反射效果，将圆变为透明度反射球体 运行，透明球效果比较生硬，不会改变 点击添加多个反射探针 运行，发现移动时反射球会改变了 不管是反射探针还是光照探针，其实就是预处理渲染信息存储在探针中，等到运行的时候将附近各探针的存储的信息进行一个叠加融合作为当前运动到某个位置时的渲染信息，从而提高场景的真实感。 3.7 视频播放选中墙壁平面，component-&gt;video-&gt;video player，视频播放的原理是改变了墙壁的材质.. 也可以选择URL 当然，以上不涉及到视频的控制，但有时候我们需要对视频进行控制。比如空格暂停 新建c#脚本 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Video;public class VedioCOntrol : MonoBehaviour{ VideoPlayer videoPlayer; // Start is called before the first frame update void Start() { videoPlayer = GetComponent&lt;VideoPlayer&gt;(); Debug.Assert(videoPlayer); } // Update is called once per frame void Update() { if (Input.GetKeyDown(KeyCode.Space)) { if (videoPlayer.isPlaying) videoPlayer.Pause(); else videoPlayer.Play(); } }} 3.8 粒子系统用于廉价而实用的特效，比如爆炸，烟雾，沙尘。会比直接贴多帧图效果好很多 直接就能看到效果，雪花往上飘 我们制作别的效果只需要编辑参数，比如制作火焰 右边很多选项卡的 基本选项卡：start speed 往上升的速度慢点，start color颜色调为火焰色 shape选项卡：angle是往上升的时候的散发度，调为0，radius是出生点那个圈的范围大小，适当调小，使得火焰更集中 随时间的函数选项卡： 可以为其添加子GameObject橙色点光源就可以照亮，也可以将火焰的纹理拖拽给它，是图片的形式，背景要透明，类似布告板，虽然是图片，但是面向摄像机，效果就好像立体的。 当然这样做出来的效果都比较简单，标准资源包有一些预实现，可以拉出来看看，做的很完备，像什么爆炸呀，火焰呀，沙尘暴，烟雾之类的 4. UIUI不是指3D的物体，而是游戏开始界面的按钮呀，图片呀，文字之类的，当然游戏里面也有。 新建GameObject-&gt;UI-&gt;Text/Image/Button 为Text新建脚本，内容是一个函数，当函数调用时改变文本 选中button，属性框onclick点击+号，选择Text控件，并选择刚刚写的函数 canvas有个属性叫render mode 可以选择是delay永远显示在屏幕空间，还是camera某个相机的屏幕空间，还是世界空间（虽然是二维的，实际上变成了3D的物体） 5. 物理系统5.1 物理仿真基础collider：碰撞检测 regid：刚体（比如重力，或者其他力） 新建如下场景，为墙壁添加材质并画好颜色 给小球添加rigid body 运行，小球会自由落体 在collider里可以看到材质，这个材质不同于普通材质，叫做物理材质，类比生活来说，这个应该叫做“材料”，而普通材质应该对应“涂料” 添加物理材质 拖拽给球体可以自动复制material，双击可以设置摩擦力和弹跳，弹跳为0~1 运行，可以看见皮球效果 为小球添加一个恒力（固定方向的力） 这四个力参数依次是世界空间，局部空间，世界空间力矩，局部空间力矩 可以把小球靠近一点墙，在掉落过程中撞到地面，运行 发现坐标轴会来回转动，这是因为小球落地后会有摩擦和滚动效果（是的添加材质后就自动带有这些功能），导致局部的坐标一直随着滚动变化 可以在rigid body属性中进行约束，阻止滚动 5.2 仿真子弹效果制作根据蓄力发射子弹的效果，蓄力时间越长射的越远 5.2.1 预制件将小球直接拖拽到unity资源管理器窗口即可让某个GameObject及其附带的所有属性称为一个可复用的预制件 新建脚本，脚本完成的功能是：利用子弹的恒力组件来施加蓄力效果 利用射线查询功能计算生成的子弹方向 1234567891011121314151617181920212223242526272829303132333435public class fire : MonoBehaviour{ public ConstantForce bullet; // bullet不能用Transform，而是ConstantForce属性 private float pressedTime = 0f; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { if (Input.GetButton(&quot;Fire1&quot;)) { pressedTime += Time.deltaTime; } if (Input.GetButtonUp(&quot;Fire1&quot;)) { // 从摄像机到鼠标点生成一条射线 Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; //存储射线和xx的交点 if (Physics.Raycast(ray, out hit)) { // 不能是GetComponent而是Instantiate表示从预制件复制出一个子弹，起始位置为射线的起点（相机），方向为射线方向 ConstantForce cf = Instantiate&lt;ConstantForce&gt;(bullet, ray.origin, Quaternion.LookRotation(hit.point - ray.origin)); // 添加局部空间恒力 cf.relativeForce = new Vector3(0f, 0f, pressedTime * 10); } pressedTime = 0f; } }} 如果子弹偏了是因为预制件复制的子弹默认恒力不是z轴的10 5.3 关节结构joint可以约束一些物理运动 使用空物体作为约束体 建立两个空物体并分别赋予hinge和spring的joint属性 hinge jointhinge joint就是类似肘关节这样的关节，绕轴转，或者理解为能挂在空气中的挂钩/钉子 hinge自带rigid body，其中的connected body是要约束的物体 新建一个cube并赋予rigid body属性，放在hinge joint附近位置，拖拽进入connected body spring joint空间中的弹簧，能够悬挂物体，操作都类似 悬挂物体后，可以对物体进行子弹打击，尤其是弹簧悬挂的物体，效果很有趣 破坏jointjoint有个break force属性，就是说收到多少力的时候断开约束，我们可以给hinge一个较大的断开力比如1000，spring joint设置为30 运行，就能发现spring joint悬挂的方块被子弹一打击就掉落，而hinge悬挂的方块需要一定的蓄力才能打掉 脚本，破坏事件可以通过脚本捕获到，我们写一个脚本捕获打击的力度 这里直接在unity控制台打印 1234private void OnJointBreak(float breakForce){ Debug.Log(&quot;this force is: &quot; + breakForce);} 运行 当然可以试试使用UI空间在屏幕空间右上角记录分数等简单游戏 5.4 碰撞事件比如我们玩游戏时遇到的反弹或者突然加速效果，本质都是检测到碰撞之后施加特殊的物理效果。新建一个cube并赋予透明材质 cube有个属性叫isTrigger 也就是触发碰撞，如果勾选，那么碰撞时物体不会碰撞而是会穿透物体，适合做一些水面效果。 下面我们模拟一个加速带效果：当穿透这个半透明物体时给子弹进行一个赋力，使子弹加速 首先给子弹添加tag，方便我们控制所有子弹 新建脚本 1234567891011121314private void OnCollisionEnter(Collision collision) { if (collision.gameObject.tag != &quot;Bullet&quot;) return; Destroy(collision.gameObject); } private void OnTriggerStay(Collider other) { if (other.tag != &quot;Bullet&quot;) return; if (other.attachedRigidbody) other.attachedRigidbody.AddForce(Vector3.up * 30); } 运行，碰到半透明方块时就会弹起 6. 人工智能6.1 自动寻路先建立如下场景，胶囊体模拟小人 同时为小人添加NavMeshAgent属性 接下来我们编写一个脚本让小人移动到指定位置，需要用到一个AI库中的NavMeshAgent属性 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class Actor : MonoBehaviour{ public Transform goal; // 目标 private NavMeshAgent agent; //AI库的一个寻路属性类 // Start is called before the first frame update void Start() { agent = GetComponent&lt;NavMeshAgent&gt;(); agent.destination = goal.position; } // Update is called once per frame void Update() { }} 将脚本挂接到胶囊身上，可以看到有个public的参数，也就是目标，我们可以创建一个空GameObject作为目标 现在运行还不会自动寻路，还需要一些预计算： 也就是说，所谓的自动寻路算法需要对现有场景进行烘焙（预计算），那么我们就需要将一些不动的物体设置为static属性（地面，障碍物等），如果障碍物没有被静态烘焙，那么会直接穿过去（也就是没有绕过障碍物进行寻路） 运行，就能自动寻路了，除了避障之外，还会自动寻找最短的路径 修改脚本，实现点击移动到鼠标指定位置 123456789void Update(){ if (Input.GetMouseButtonDown(0)) { RaycastHit hit; if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100)) { agent.destination = hit.point; } }} 运行点击鼠标左键可以看到效果 台阶跳跃当我们点击高台的时候发现不能跳上去，只能寻路到离高台最近的位置 方式1：设置set height属性框有个设置跳跃高度，每次设置完都要bake 当我们看到bake后线没了就说明能跳上去了 方式2：使用off mesh link连接如果觉得方式1的跳跃不够真实，或者想实现部分游戏里的传送效果（参考马里奥大炮，lol娱乐模式大炮，远程跳跃或者不能直接连接），off mesh link就是这样建立两个物体之间的曲线 下面我们实现直接从地面跳跃到蓝色物体 场景中建立跳跃的起点和终点（cube，终点最好是看得见的..方便演示） 并给其中一个跳跃点添加off mesh link组件 拖入起点和终点 移动的障碍物对于移动的障碍物，没有办法设置static，需要通过nav mesh obstacle 在场景中新建一面墙，我们都知道如果不配置static的话运动路线穿过墙的话就会直接穿过去。因此我们为墙添加nav mesh obstacle组件 运行，就能避开这个非static的物体了（虽然这个墙并没有为其添加animation，可以自己添加） 说一下carve属性，carve属性能让动态物体也加入烘焙当中 勾选以后我们可以看到bake时这面墙周围也有禁止触碰的区域了 我们都知道bake是提前计算一些复杂的渲染效果，运行时就可以不再计算，那非static的物体勾选这个carve有什么用呢？那就是针对动态生成但生成以后静止的物体 综上： static：静止物体 非static：移动物体 非static但carve：动态生成但生成以后静止的物体 6.2 敌人巡逻通常游戏里的敌人都有巡逻逻辑，固定的移动某些空间点，遇到玩家后就会追赶，玩家离开范围后回到自己的巡逻路径 在场景中建立敌人，并建立几个巡逻路径点，左上角的为敌人，右下角的为玩家，用一个父GameObject来管理路径点，路径点位置大致如下 下面通过脚本使其能按规定移动到各个巡逻点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class Enemy : MonoBehaviour{ public float patrolSpeed = 3f; // 巡逻移动速度 public float patrolWaitTime = 0.5f; // 到达每个巡逻点停一下 public Transform patrolWayPoints; // 巡逻点都在这个父物体里了，我们直接获取父物体 private NavMeshAgent agent; private float patrolTimer = 0f; // 记录已经停留的时间，大于patrolWaitTime就移动到下一个巡逻点 private int wayPointIndex = 0; // 巡逻点下标 // Start is called before the first frame update void Start() { agent = GetComponent&lt;NavMeshAgent&gt;(); } // Update is called once per frame void Update() { Patrolling(); } private void Patrolling() { agent.isStopped = false; agent.speed = patrolSpeed; // 判断是否到达某个巡逻点(agent考虑了误差，所以是范围小于该停止的范围) if (agent.remainingDistance &lt; agent.stoppingDistance) { patrolTimer += Time.deltaTime; if(patrolTimer &gt; patrolWaitTime) { if (wayPointIndex == patrolWayPoints.childCount - 1) wayPointIndex = 0; else wayPointIndex++; patrolTimer = 0f; } } else { patrolTimer = 0f; } agent.destination = patrolWayPoints.GetChild(wayPointIndex).position; }} 关于第34行的那个stopping distance是误差范围判断，其实是nav mesh agent提供的一个误差判断，在脚本挂接到敌人后，还需要调整stopping distance的属性值，最好大于0，以为地形可能有高有矮之类的，存在误差，寻路算法可能没有办法完全达到 6.3 敌人视野下面实现敌人发现玩家的功能 视野功能的本质是collider 创建一个空物体作为敌人的子物体（视野），添加box collider并调整到合适的视野大小，勾选isTrigger仅作为触发器使用，可以避免物理碰撞 编写脚本，注意脚本是给这个EnemySight的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using System.Collections;using System.Collections.Generic;using UnityEngine;public class EnemySight : MonoBehaviour{ public float filedOfView = 100f; // 视野角度 public bool playerInsight = false; // 是否发现 public Vector3 playerLastPos; // 玩家最后位置 public Vector3 resetPos = Vector3.back; // 玩家默认位置 private BoxCollider col; // 敌人视野碰撞体 private GameObject player; // 玩家 // Start is called before the first frame update void Start() { col = GetComponent&lt;BoxCollider&gt;(); player = GameObject.FindGameObjectWithTag(&quot;Player&quot;); playerLastPos = resetPos; } // 碰撞体检测函数 void OnTriggerStay(Collider other) { if(other.gameObject == player) { playerInsight = false; // 获得玩家和敌人的连线 Vector3 dir = other.transform.position - transform.position; // 判断该连线和敌人前方的向量夹角，若大于视野角度的一半（左右两边），就说明玩家可能被看到了 float angle = Vector3.Angle(dir, transform.forward); if(angle &lt;= filedOfView * 0.5) { // 只是可能被看到而已，还需要判断是否有障碍物，可以构造一条射线，raycast是否仅有玩家而没有别的物体 RaycastHit hit; if(Physics.Raycast(transform.position + transform.up, dir.normalized, out hit, col.size.z)) { if(hit.collider.gameObject == player) { playerInsight = true; playerLastPos = player.transform.position; Debug.Log(&quot;Find Player&quot;); } } } } } private void OnTriggerExit(Collider other) { if(other.gameObject == player) { playerInsight = false; } } // Update is called once per frame void Update() { }} 需要注意，collider碰撞检测，当然要求player持有rigid body属性，因此要注意给玩家和敌人添加rigid body属性，除此之外还要勾选isKinematic，表示不受动力学影响（比如被墙壁撞开后受了推力，直接被撞开到地图外） 6.4 攻击与追踪我们将要修改敌人的脚本逻辑，使其除了巡逻功能外还能拥有追踪和射击动作 整个过程如下：1敌人巡逻，2视野发现玩家，3掉头朝向玩家，4开枪射击，5玩家脱离视野，6敌人追踪，返回2直至追不上，返回1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class Enemy : MonoBehaviour{ public float patrolSpeed = 3f; // 巡逻移动速度 public float patrolWaitTime = 0.5f; // 到达每个巡逻点停一下 public Transform patrolWayPoints; // 巡逻点都在这个父物体里了，我们直接获取父物体 private NavMeshAgent agent; private float patrolTimer = 0f; // 记录已经停留的时间，大于patrolWaitTime就移动到下一个巡逻点 private int wayPointIndex = 0; // 巡逻点下标 public float chaseSpeed = 6f; // 追踪速度 public float chaseWaitTime = 5f; // 允许追踪时间（超过就判定为追不到） private float chaseTimer = 0f; // 已经追踪的时间 public float sqrPlayerDist = 4f; // 距离平方，平方是为了简化计算 private bool chase = false; // 是否追到 public float shootRotSpeed = 4f; // 发现敌人要先掉头 public float shootFreeTime = 2f; // 子弹冷却时间（换弹），不能无线发射子弹 private float shootTimer = 0f; // 已经冷却的时间 private EnemySight enemySight; // 直接获取视野所用脚本 private Transform player; // 玩家 public Rigidbody bullet; // 子弹 // Start is called before the first frame update void Start() { agent = GetComponent&lt;NavMeshAgent&gt;(); enemySight = transform.Find(&quot;EnemySight&quot;).GetComponent&lt;EnemySight&gt;(); player = GameObject.FindGameObjectWithTag(&quot;Player&quot;).transform; } // Update is called once per frame void Update() { // 在视野内：射击，没视野了：追踪，追不上了：巡逻 if(enemySight.playerInsight) { Shoting(); // 射击 chase = true; } else if(chase) { Chasing(); // 追踪 } else { Patrolling(); // 巡逻 } }} 射击函数 1234567891011121314151617181920private void Shoting(){ // 首先掉头朝向玩家 Vector3 lookPos = player.position; lookPos.y = transform.position.y; // 这里为了简便不进行抬头低头 Vector3 targetDir = lookPos - transform.position; transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(targetDir), Mathf.Min(1f, Time.deltaTime * shootRotSpeed)); // 使用四元数在xx时间内变成指定方向 agent.isStopped = true; // 寻路过程暂时停止 // 发动攻击 if(Vector3.Angle(transform.forward, targetDir) &lt; 2) // 不一定要完全面向玩家，大家都会动，允许一定误差 { if(shootTimer &gt; shootFreeTime) { Instantiate(bullet, transform.position, Quaternion.LookRotation(player.position - transform.position)); // 从预制件中创建子弹，并指定位置和方向 shootTimer = 0f; } shootTimer += Time.deltaTime; }} 制作子弹和预制件 子弹不要太大，调整缩放 子弹不受物理系统的碰撞影响，勾选isTrigger 为了方便子弹不受重力影响，取消勾选gravity 给子弹一个往前的恒力，局部坐标z为5 为子弹编写脚本 12345678private void OnTriggerEnter(Collider other){ if(other.tag == &quot;Player&quot;) { GameObject.Destroy(other.gameObject); // 一枪直接能打爆玩家狗头 GameObject.Destroy(gameObject); // 销毁子弹本身 }} 挂接给子弹，然后创建预制件并删除默认子弹 将子弹预制件作为参数拖拽给Enemy脚本中的bullet参数 现在运行可以看到敌人发射子弹打死玩家了，但是敌人还不会追踪，且射击函数让寻路功能暂停，所以视野捕捉到玩家后就会停下 追踪函数 1234567891011121314151617181920212223242526private void Chasing(){ // 寻路 agent.isStopped = false; // 重新打开寻路功能 Vector3 sightDeltaVec = enemySight.playerLastPos - transform.position; if(sightDeltaVec.sqrMagnitude &gt; sqrPlayerDist) // 计算当前敌人和玩家的距离，其实玩家是上一帧因为不可能知道玩家0.几帧的位置 { agent.destination = enemySight.playerLastPos; } agent.speed = chaseSpeed; // 将巡逻速度换成追踪速度 if (agent.remainingDistance &lt; agent.stoppingDistance) { // 走到目标destination的位置时，四处张望一下，如果玩家不见了，就回到巡逻 chaseTimer += Time.deltaTime; if (chaseTimer &gt; chaseWaitTime) { chase = false; chaseTimer = 0f; } } else chaseTimer = 0f; // 一直处于追踪状态，不可能因为时间就不追了，一直归0 enemySight.playerInsight = false; return;} 运行，可以看到敌人可以巡逻，追踪，射击，重新巡逻 7. 音频7.1 音频基础可以直接将音频文件拖拽到场景，会自动建立一个GameObject，附带Audio Source组件，其中的AudioClip属性就是这段音频，而output可以指定一个audio listener，audio listener是音频接收器来模拟人的耳朵，添加音频时默认为main camera添加一个audio listener组件 3D音效：spatial blend拉成3D就可以，运行时镜头的位置决定了声音方向在哪里 mute：暂时静音 Bypass Effects：忽略音效（音效和音量是不一样的） Play On Awake：自动播放 Loop：循环播放 Priority：优先级0~256 Volume：音量 Pitch：声音播放频率（倍速） Stereo Pan：声音方向，只对2D声音有影响，3D情况下只跟位置有关 Reverb Zone Mix：决定多少输出信号给回声区域 Doppler Level：多普勒效应 https://baike.baidu.com/item/%E5%A4%9A%E6%99%AE%E5%8B%92%E6%95%88%E5%BA%94/115710?fr=aladdin Spread：3D音源的发射角度 Volume Rolloff：距离和音量的函数 Max Distance：声音传播最大距离 7.2 混音器对多个声音进行控制 可以通过不同的组来控制不同的音源（属性中的output对应这里不同的组） 运行，就可以发现多个组对应的音源同时播放了，可以编辑各个组的音频文件的权重，达到混音效果。 父group的调整会影响他的所有子物体 SMB按钮的意思是 S：solo单独播放 M：mute静音 B：bypass取消音效 当我们调整到觉得适合的混音效果时，可以点击Snapshots，保存当前的参数快照 Views：也是可以保存多份，但是保存的是group可见性的自由组合，比如第一份屏蔽了effect，第二份屏蔽了background Mixer也可以有层次关系：一个混音器控制另一个混音器，比如我们想玩家点空格的时候一种音效，点回车的时候另一种音效 首先拖拽两个音源shoot和explode模拟开枪和跳跃，并管理在父controller下（译为玩家控制音频），创建一个audio mixer对应这个控制音频（这里名字是SoundEffect），两个音频都将output设置为SoundEffect 接下来添加一个组PlayerSound，再将刚才的SoundEffect混音器作为Music混音器的子混音器，并选择组为PlayerSound 当然，交互需要脚本 123456789101112public class Controller : MonoBehaviour { public AudioSource shootSnd; public AudioSource explodeSnd; // Update is called once per frame void Update () { if (Input.GetMouseButtonDown(0)) shootSnd.Play(); if (Input.GetKeyDown(KeyCode.Space)) explodeSnd.Play(); }} 挂接给controller并将对应的音源GameObject作为参数传递进去，运行，便可以发现既有背景音乐，也有子物体（用户操作时的音源）了 7.3 音效音效和音频不一样，音频是一段mp3，音效是比如回音，空旷，人声之类的 新建场景，拖入背景音乐音频，并创建一个混音器（这里叫AudioEffectDemo），混音器添加两个group分别作为音乐和音效 将music作为音频的output，运行测试music的参数是否能调整声音大小 下面对effect组点击Add添加音效，unity为我们提供了许多内置音效，这里选择SFX Reverb（回声） 回声需要知道来自什么的回声，所以我们给effects添加一个Receive，给music添加一个send 有了接口后，点击music，在send里选择effects的Receive接口，就可以把音频发送给接收者 注意，音效是有处理顺序的，必须先接收，再回声，因此要调整顺序如下图 运行，还不行，需要点击这里调整回声强度 如果回声效果不明显，可以调整SFX Reverb的参数，比如Room房间大小和Reverb回声强度 除了回声效果，unity也提供了许多其他音效，比如低通滤波器（可以过滤低音保留高音）等等，自己可以尝试，但是要注意顺序，music要先低通再send回音，否则回音接受到的是原音 脚本控制以上，都是在unity编辑器中设置的，那如果需要动态设置呢？，比如在游戏场景中人物可以调整某个收音机的音量之类，因此可以暴露混音器设置给脚本 因为master可以控制所有子音频，所以我们暴露master的控制脚本，注意是对着Volume点右键而不是对着Attention点右键 完成之后这里会出现一个Exposed Parameters，也就是自定义参数 新建脚本，这里通过键盘上下键来控制音量 12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class Adjust : MonoBehaviour { public AudioMixer audioMixer; // Update is called once per frame void Update () { float v; audioMixer.GetFloat(&quot;MyVolume&quot;, out v); Debug.Log(v); if (Input.GetKeyDown(KeyCode.UpArrow)) audioMixer.SetFloat(&quot;MyVolume&quot;, v + 1); if (Input.GetKeyDown(KeyCode.DownArrow)) audioMixer.SetFloat(&quot;MyVolume&quot;, v - 1); }} 脚本挂接到main canera，mix audio作为参数 运行，通过键盘↑↓调整音量大小 至此音效介绍完毕 8. 网络2019以后的unity版本现在这里点击一下安装 8.1 双玩家连线 双玩家连线：这种模式下，服务端其实也是其中一个客户端（也是一个unity程序），也就是说，客户端操作一个小人，服务端也有操作小人的功能。但是还是必须先启动服务端。 多玩家连线：这种模式下，服务端通常只做数据的接收、转发和广播，本身并不具有客户端的功能，但是会存储客户端的列表，操作对应的数据是单播还是广播 添加网络管理器 新建场景，添加一个第三人称预实现小人，添加一个空object，为空物体添加network manager和network manager HUD组件 为人物添加网络实体和网络广播 为小人复制出预制件 对小人添加 networkIdentity组件，表示该小人是网络实体 勾选下面这个选项，由于在网络游戏中，不宜传输太多数据，比如人物可以在自己本地可以控制的，一个客户端只有一个玩家。只需要向网络广播自己的一些信息即可，因此就可以勾选下面这个选项。 那勾选了本地操作之后，怎么向网络广播自己的位置信息呢？ 为小人添加network transform组件 就可以向网络中发送自己的transform了 完成之后，点击apply all可以应用到对应的预制件 现在运行并不是真正的网络数据，还需要修改人物脚本，进入这个脚本 打开可以看到MonoBehaviour，这是单人游戏的意思 需要改成如下：网络游戏 这个类就可以调用一些联网功能 我们对其修改，目的是：人物动作只在本地，但是一些位置等信息需要向网络广播 保存，apply all后就可以删除场景中的小人了，咱们只保留预制件，小人交由服务端生成 \\3. 服务端生成预制件 刚刚说了小人应该在服务端生成而不是一开始就在客户端中 \\4. 运行 现在一切已经就绪，那么我们怎么模拟联机呢，当然可以找两台同一wifi/局域网下的电脑，也可以本机模拟，我们直接build一下作为一个，然后编辑器中运行作为另一个（当然你也可以build后运行两个）。总之无论如何，打开两个就行了 需要注意的是，必须先启动服务端，再启动客户端连接它 我们可以看到成功联机了，但是只有位置联机了，动作没有改变（A端自己的小人会在B端移动，但不会在B端做动作） unity为网络游戏优化的规则就是默认不传输所有数据，至于位置信息是因为我们添加了network transform组件才进行传输 怎么样才能让动作也作为网络数据传输呢？动作其实就是动画animation，到这里就明白了：network animation，是的 踩坑：预制件的修改但是要修改预制件的东西，最好先将预制件拖入场景中变为实体，改动完再apply all，再删除场景中的GameObject 因为参数通常是传入GameObject，如下 如果只有Player预制件没有生成一个Player的GameObject实体，那么这里会发现没有Player可选 将上述所有修改完成再apply all，删除场景中的实体即可 重新build，联机，发现动作也有了，延迟取决于网络！！！！ 8.2 联网子弹准备工作：单机子弹和发射 下面制作子弹，先创建一个球体，属性如下 并作为预制件，将场景中的子弹删除 编辑player脚本，使其可以发射子弹 1234void Fire(){ GameObject bullet = Instantiate(bulletPrefab, transform.position + transform.up + transform.forward * 2, transform.rotation);} 这时候已经完成了单机发射子弹了，可以运行测试 下面继续制作联网子弹 将子弹预制件拖拽到场景编辑，添加network identity和network transform 由于我们不希望子弹的位置自动传输，因此将send rate设置为0 apply 将子弹预制件纳入到网络管理器的生成列表种，使得子弹由网络生成 需要注意的是，由网络生成的列表必须带有[Command]，而有Command的函数必须是以Cmd开头 新建血量脚本 我们想做一个功能是当血量为0时，重新生成一个玩家，我们知道现在Player是在服务端生成的，但是生成后是交给客户端来对这个Player执行 unity提供了一个由服务端调用，客户端执行的函数 为子弹建立脚本，碰撞检测和调用血条减少（总的来说就是造成伤害） 12345private void OnTriggerEnter(Collider other){ // 通过SendMessage方法尝试调用gameobject名为TakeDamage的脚本函数，如果该gameobject没有这个函数则DontRequireReceiver不执行 other.gameObject.SendMessage(&quot;takeDamage&quot;, 60, SendMessageOptions.DontRequireReceiver);} 这里说明一下，为什么没有用if(other.gameobject == “player”)，因为这个碰撞检测可能对player有效，对enemey也有效，后期可能对其他的物体也有效，那么这样设计是比较麻烦的，unity提供的这种消息机制就可以让所有的物体都接收，然后尝试调用TakeDamage方法，如果物品没有这个方法就不作为，如果物品有这个方法就调用。 将脚本拖拽给bullet预制件，将health脚本拖拽给player，运行 8.3 NPCNPC就是共同的敌人，（或者在某些游戏中不是敌人，总之共同的就对了） 重新制作预制件 拖拽一个小人到场景中，重命名为NPC，并修改材质使其看起来有区别于enemy和player 重新制作预制件并命名为NPC预制件，并将场景中的小人删除 为NPC添加网络管理器 新建空物体，添加network identity组件，勾选server only（NPC应该设置为仅由服务端生成，不受客户端控制） 动态随机生成多个NPC脚本 12345678910111213141516171819public class NPCSpawner : NetworkBehaviour{ public GameObject NPCPrefab; public int numOfNPC; // 服务端启动时的一个生命周期虚函数 public override void OnStartServer() { for(int i = 0; i &lt; numOfNPC; i++) { // 随机位置和朝向 Vector3 spawnPos = new Vector3(Random.Range(-5f, 5f), 0f, Random.Range(-5f, 5f)); Quaternion spawnRot = Quaternion.Euler(0, Random.Range(0, 180), 0f); // 更习惯用欧拉角 GameObject NPC = Instantiate(NPCPrefab, spawnPos, spawnRot); NetworkServer.Spawn(NPC); } base.OnStartServer(); }} 拖拽给生成器gameobject 填入参数 注册到网络生成器列表 为NPC添加血条效果 现在运行可以正常生成NPC但不会收到伤害，因为Health是客户端的脚本功能 修改如下 运行，可以联网打怪 9. 时间轴9.2 创建time line先来看看如何创建一个时间轴创建一个timeline 9.1 和动画的异同timeline是引擎后来提供的一个新功能。相比于animation，timeline可以认为是控制场景的整体动画，既可以对单个物体也可以控制多个物体协同运动，同时可以播放声音，粒子效果，摄像机跟踪等等。而animation只可以控制单个物体，且该物体的多个动画片段需要animation controller协调进行叠加或者混合，多个物体的动画需要各自的animation。可以理解成timeline是横向的，一个object控制多个物体同时播放动画，animation是纵向的，每个物体能在自己的时刻播放自己的动画。 动画轨道新建一个空物体，添加Playable Director组件，另一种方式是window-&gt;timeline-&gt;create（这种方式就类似于animation） 如下图操作，拖拽两个物体进入animation轨道，由Director这个timeline物体的timeline组件控制 在各自的轨道上创建自己的animation，可以像animation一样录制，也可以如下直接植入预制动画片段 需要注意的是：录制的话，对动画中需要变动的transform属性进行右键add key 录制完后，可以对某一段动画进行封装成一个完整的片段 除了动画轨道，还可以有音频轨道和控制轨道 音频轨道audio track和动画类似，创建音源，创建轨道，添加声音片段，可以融合 控制轨道 control track可以动态生成一个物体 自定义轨道Playeable track可以接收自定义脚本，脚本类需要集成PlayableAsset 下面实现一个UI空间Text显示当前轨道的播放状态 123456789101112131415161718192021222324252627282930313233using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Playables;using UnityEngine.UI;public class MyplayableAsset : PlayableAsset { public ExposedReference&lt;Text&gt; myText; public override Playable CreatePlayable(PlayableGraph graph, GameObject owner) { var playable = ScriptPlayable&lt;MyplayableBehaviour&gt;.Create(graph); playable.GetBehaviour().status = myText.Resolve(graph.GetResolver()); return playable; }}public class MyplayableBehaviour:PlayableBehaviour{ public Text status; public override void OnBehaviourPlay(Playable playable, FrameData info) { if(status != null) { status.text = &quot;Playing&quot;; } } public override void OnBehaviourPause(Playable playable, FrameData info) { if(status != null) { status.text = &quot;End playing&quot;; } }} 简单来说，timeline绑定了Text类型的控件，能够允许这个控件在某段时间生效，至于代码可能是固定写法，日后再探究 创建UI空间Text并拖入，运行 9.3 角色动画拖拽一个第三人称小人预实现，取消脚本和animator controller，运行，此时小人相当于静态模型，添加timeline，动画依次为idle-&gt;walk-&gt;run，运行，此时发现有两个问题 1.角色不能掉头，即使调整场景中的小人rotY为180，但是运行的时候还是会背对相机，这是因为角色的transform已经交给目前出于激活状态的timeline控制，需要在这个地方调整 2.动画被重置，尤其是walk-&gt;run，walk已经走了一段距离，但是run的时候会自动先回到原点，而不是接着walk的位置跑。右击run片段选中如下选项 3.动画过渡太僵硬，回顾之前animation的融合，timeline也提供了非常方便的过渡功能。只需要将两个动画片段交叉即可自动过渡。 细节：由于动画片段的独立性，由于速度不同或者其他问题，导致自动融合中会出现比如walk-&gt;run时出现滑步的现象，自己对位置做一些微调即可 可以像animation一样进行动画的叠加，比如在动画1的时候添加转身，遮罩（身体的某个部位做不一样的动画） 如果动作部位冲突又没有遮罩的话，后面的轨道会覆盖前面的轨道 9.4 脚本控制通常timeline都是达到某个场景触发，下面我们模拟脚本控制timeline的触发，新建空物体并为其创建脚本如下 关于第8行，其实写public也行，只是提一下有这么一种写法，既是private又可以在unity编辑器中暴露参数，像button一样传入参数 运行，依次按下QE 9.5 Cinemachine转场动画中经常见到的多摄像机动画。比如在游戏开始前，相机先展示敌人和一些特殊道具的位置，随后镜头才给到主角。其实就是Cinemachine在多个摄像机之间的转换。 timeline对多摄像机有很专业的动画调控支持 第一次使用需要先安装一下 新建cinemachine track 添加后发现多了一个track，新建它 cinemachine其实是采用了虚拟摄像机来模拟多摄像机效果 为主摄像机添加cinemachint brain组件 \\3. 新建虚拟摄像机 如下，可以创建一个简单的虚拟摄像机，unity也为我们提供了许多具备一定功能的摄像机，这里我们选择一个freelook：这个虚拟摄像机允许我们角度自由的观察一些物体。 再建立一个带轨道的推拉摄像机：这个虚拟摄像机可以对一个物体前后推拉达到远近变化观察的效果 调整虚拟摄像机达到预期效果 咱们目的是让推拉带轨道摄像机沿着设定的轨道移动，并时刻注释红色物体，自由摄像机注释蓝色物体。并在timeline中设置为先观察蓝物体，再观察红物体的效果 推拉摄像机的路径设置如下 推拉摄像机参数设置如下：其中Path offset设置成0表示摄像机严格按轨道移动 设置完成后，推拉摄像机就可以在轨道上找到最近的点去观察红色物体了 另外，这里为了方便看到效果，要让红蓝物体在动画开始时自动运动（之前设置了要按下QE） 调高main camera的优先级 自己可以对比观察一下，是这样的，camerachine所谓的虚拟摄像机并不记录画面，而是将虚拟摄像机看到的画面传输给camera（类似于无人机，无人机在飞，拍到的画面是发送到操控者的屏幕上，无人机自己并没有保存照片的功能）。 如果不调高main camera的优先级，那么会显示虚拟摄像机开始的位置观察的画面，因为虚拟摄像机只有第一帧的画面，后面的画面不记录不更新，而是发送给了main camera，因此我们看到的就是虚拟摄像机似乎没动。所以我们应该一直看main camera，要将main camera的优先级调高，覆盖其他摄像机。 timeline控制两个camerachine 运行观看效果 10. 2D游戏unity新建工程的时候，如果想要创建二维工程，需要在创建时点击2D 长这样 可以看见工具栏有个2D视图，其实只要换成3D就变成3D工程了，所谓2D游戏不过是把z轴去掉 10.1 精灵2D游戏中的纹理默认是精灵类型，2D游戏就是由一个个的图片（或者说纹理或者说精灵）+移动+脚本制作的 将一张图片拖拽到unity，可以看到默认是精灵类型 如果图片本身就具有alpha透明通道，那么图片可能会不显示（透明嘛），可以如上图去除透明通道，记得点击apply 拖拽两个物体进入场景，发现被覆盖，可以手动调整sorting layer，下面的order in layer表示即使是同一层也有遮挡顺序 点击三角形，点击add layer，并添加自定义层，下面的优先级高于上面 编辑好后，将场景中的物体应用到各自的层，坦克就不会被背景遮住了 当我们拖拽子弹后，发现是一连串的 但我们知道这其实是多帧连续播放的动图，unity给我们提供了一个非常简便的切割方式 其中slice提供了很多切割模式 automatic是自动切割，采用了最小包围盒算法 size是指定长和宽的像素 count是指定几行几列 完成后记得点击apply 此时再拖拽到场景，会自动提示创建animation 创建完动画后运行即可看到效果 多个物体批量调整大小 创建发射子弹脚本 12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using UnityEngine;[RequireComponent(typeof(Rigidbody2D))]public class Bullet : MonoBehaviour{ [SerializeField] private float speed = 2.0f; private Rigidbody2D body; // Start is called before the first frame update void Start() { body = GetComponent&lt;Rigidbody2D&gt;(); } // Update is called once per frame void Update() { body.MovePosition(transform.position - transform.right * speed * Time.deltaTime); } private void OnCollisionEnter2D(Collision2D collision) { if(collision.gameObject .tag == &quot;Player&quot;) { GameObject.Destroy(collision.gameObject); GameObject.Destroy(gameObject); } }} 挂接到子弹，子弹会自动添加rigid body组件，还需要手动添加一个box collider组件用于碰撞检测，同时还需要把重力取消 接下来完成坦克生成子弹，因此需要制作预制件，并reset位置（到时候作为坦克的子物体） 新建发射脚本 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;public class Spawner : MonoBehaviour{ [SerializeField] private float shootTimer = 3f; // 冷却时间 float timer = 0f; // 已经冷却时间 [SerializeField] GameObject bullet; // 实例化的子弹 // Update is called once per frame void Update() { if(timer &gt; shootTimer) { Instantiate(bullet, transform); // 从transform位置生成子弹 timer = 0f; } timer += Time.deltaTime; }} 挂接给Spawner发射器，并将子弹预制件参数拖拽进去，运行 颜色： 可以调整color属性 光照： 2D游戏默认没有光照，因为材质默认不会受到光照效果，可以手动添加光源，并添加材质，选择漫反射 将材质拖拽给2D物体，就可以看到光照效果，如果没有，注意光源是否离得太远（调整z值）和角度（这个要注意，比如点光源默认rotX是90，建议切换成3D视图来调整） 10.2 瓦片地图tilemap，是为了2D游戏经常需要的一种格子排列布局 但是这样很费时间，于是有了瓦片地图功能 新建瓦片地图tilemap 除了tilemap，下面还有六边形等 记得将这个tilemap图层覆盖在background之上 调出瓦片调色板tile palette 拖拽到调色板 用笔刷刷出连续的效果 点击edit可以调整调色板上的瓦片效果，可以用多个物体组装成一个瓦片，鼠标框选后作为一个整体再使用笔刷 10.2.1 碰撞体 可以为tilemap中的每一片瓦片里的每一个方块都添加碰撞体 这时候我们可能需要进行一些碰撞体的融合 添加这个会自动添加rigid body，如果是地形的话，不受重力影响，最好直接设置成静态 tilemap允许使用碰撞组合 10.3 角色控制下面我们学习2D下的游戏角色控制 先添加资源包，只需要添加这几张图片就行 如果打开sprite editer就可以发现都切割好了 拖拽idle动画（一定要记得是拖拽到场景而不能是Hierarchy），起名Player作为角色，修改为actor层，设置tag为Player，添加capsule collider 2D并调整大小到包裹小人范围，添加rigid body2D组件，不希望旋转所以锁定旋转轴 动画修改 不多说了，编辑ide的状态机，添加walk run jump 并创建三个参数，添加转换条件 speed：速度，Ground：是否触碰地面，vSpeed：纵向跳跃速度 idel-&gt;walk：速度大于0.01 反之亦然 walk-&gt;run：速度大于0.1，反之亦然 最后状态机如下图 添加对应的Motion（如果没有的话就先将几个png拉入场景，因为这个不是从资源包弄出来的动画，而是从png里面通过sprite editor切割出来的） 创建player脚本 这个脚本比较复杂，但目的只有一个，就是通过按键改变animator动画中这几个参数，剩下的不用理会，动画都做好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System.Collections;using System.Collections.Generic;using UnityEngine;public class Character : MonoBehaviour{ [SerializeField] float maxSpeed = 10f; [SerializeField] float jumpForce = 400f; [SerializeField] LayerMask whatIsGround; // 哪些层需要地面检测 Transform groundCheck; // 我们会在小人脚的位置建立一个空子物体用于碰撞检测 float groundRadius = 0.5f; // 距离地面多少判断为着地 bool grounded = false; Animator anim; Rigidbody2D body; bool facingRight; // 面朝右边 bool jump = true; // 是否在跳跃 private void Awake() { // 这里没有用start而是用awake groundCheck = transform.Find(&quot;GroundCheck&quot;); anim = GetComponent&lt;Animator&gt;(); body = GetComponent&lt;Rigidbody2D&gt;(); } private void FixedUpdate() { grounded = false; // OverlapCircleAll的作用是从某个点开始，在多大范围内（二维平面的圈），在某个层是否有相交物体 Collider2D[] colliders = Physics2D.OverlapCircleAll(groundCheck.position, groundRadius, whatIsGround); foreach (Collider2D collider in colliders) { if (collider.gameObject != gameObject) // 养成习惯，碰撞体不是自己，其实这里还要检测是否是敌人或者别的什么 grounded = true; // 总之这里就先简单的认为碰撞了且不是自己就说明是地面 } anim.SetBool(&quot;Ground&quot;, grounded); anim.SetFloat(&quot;vSpeed&quot;, body.velocity.y); // 这个可以获取速度 float h = Input.GetAxis(&quot;Horizontal&quot;); // 这个可以获取用户是按下←（-1）还是→（1） if (!jump) // 这样做可以禁止连跳 { jump = Input.GetButtonDown(&quot;Jump&quot;); // 这个可以获取用户是否按下↑ } Move(h, jump); // 移动函数，在下面给出实现 jump = false; } /** * 移动函数，判断move是往左还是往右，有没有发生跳跃 */ void Move(float move, bool jumping) { if (grounded) // 很细节，着地了才判断速度，否则在空中速度够了就跑起来了，打断了跳跃动作 { anim.SetFloat(&quot;Speed&quot;, Mathf.Abs(move)); body.velocity = new Vector2(move * maxSpeed, body.velocity.y); // 新速度 // 改变朝向 if (move &gt; 0 &amp;&amp; !facingRight) { Flip(); // 掉头方法 } else if (move &lt; 0 &amp;&amp; facingRight) { Flip(); } // 跳跃判断 if (jumping &amp;&amp; anim.GetBool(&quot;Ground&quot;)) { grounded = false; anim.SetBool(&quot;Ground&quot;, false); body.AddForce(new Vector2(0f, jumpForce)); } } } /** * 掉头方法 */ void Flip() { facingRight = !facingRight; Vector3 scale = transform.localScale; scale.x *= -1; transform.localScale = scale; }} 脚本挂接给小人 这里为了方便我们先选Everything，如果游戏做的细的话可以是地面Terrain和一些被认为地面的一些层 添加脚本中提到的用于碰撞检测的子物体 运行发现有延迟，应该把转换调成立即转换 相机跟随 这个比较简单的一种做法是让main camera作为Player的子物体 当然这里由于子弹碰撞后销毁Player及其子物体导致撞到子弹后报如下错误，这里先不管他（解决方法是要么碰撞时判断不销毁相机，要么摄像机的移动不采用这种方式，而是脚本移动相机的transform的position） 单方向碰撞检测 通常这种2D游戏都是可以从下面穿上去的，unity为我们提供了这个功能 选中两个tilemap并添加如下组件 勾选如下两个选项 运行 11. 天空盒 12. 忽略碰撞检测部分物体是不需要碰撞检测的，unity提供了非常方便的选项供我们忽略而不需要在脚本中判断。 首先我们添加一个tag专门标识忽略碰撞检测的物体比如IgnoreCollider 如下图 矩阵少一半，说明不支持单向碰撞检测（A可以碰撞B，B不可以碰撞A），因此如果有其他复杂的需要仍然通过脚本实现，只推荐勾选图片中的一个，除非确定某物体完全不受碰撞","link":"/games/Unity3D-note/"},{"title":"Line-It 节点编辑器","text":"在wy的时候有推广过一个工具，是使用节点编辑器工具来完成一些程序化布景，称之为程序化工作流，不过那个工具主要是针对场编和美术策划相关的场景，而本人的工作是工具和自动化测试。当时就在想自动化测试应该是符合流水线一样执行的，能不能把两样东西结合起来，通过节点编辑器来完成自动化测试相关工作流，于是现在离职后就尝试实现一下 前言节点编辑器已经是老东西了，网上各种实现五花八门，之前只接触过web前后端，本着学习和练手的目的，选择了客户端+qt(pyside，c++写不来)。由于本人没接触过qt，也是踩了很多坑。基于blenderfreak大佬的实现（https://gitlab.com/pavel.krupala/pyqt-node-editor）基础上进行开发 开贴记录一下，帖子里的内容并不能面面俱到，如果有不清楚的可以clone下面的仓库代码对着看。 github仓库地址https://github.com/wjwABCDEFG/LineIt 画布/图元这种可以自由绘制画板的方式，写起来和以往的一般的控件不同，需要补充一点前置知识，基于图元绘制主要是三个类： QGraphicsScene：背景画布格子线条QGraphicsView：背景画布绘制模式（抗锯齿，全量更新）、鼠标键盘事件处理（滚轮放大缩小，中键画布拖拽）QGraphicsItem：绘制正方形/圆形/曲线等基本元素，用来完成node/edge/socket等设计 格子绘制 QGraphicsScene的drawBackground函数每次背景变动都会出发重新绘制，把当前的rect画满 1234567891011121314151617181920212223242526272829def drawBackground(self, painter, rect): \"\"\"每次背景变动都会触发\"\"\" super().drawBackground(painter, rect) # grid left = int(math.floor(rect.left())) right = int(math.ceil(rect.right())) top = int(math.floor(rect.top())) bottom = int(math.ceil(rect.bottom())) first_left = left - (left % self.gridSize) first_top = top - (top % self.gridSize) # compute all lines to be drawn lines_light, lines_dark = [], [] for x in range(first_left, right, self.gridSize): if (x % (self.gridSize*self.gridSquares) != 0): lines_light.append(QLine(x, top, x, bottom)) else: lines_dark.append(QLine(x, top, x, bottom)) for y in range(first_top, bottom, self.gridSize): if (y % (self.gridSize*self.gridSquares) != 0): lines_light.append(QLine(left, y, right, y)) else: lines_dark.append(QLine(left, y, right, y)) # draw the lines painter.setPen(self._pen_light) painter.drawLines(lines_light) painter.setPen(self._pen_dark) painter.drawLines(lines_dark) 节点图形 元素比较简单一个矩形，左右两边的插槽（socket）构成的node QGraphicsItem的paint函数中绘制节点，分为上面的title和content两个矩形，并加上了圆角，这部分都是固定写法，需要注意的就是content的height实际上是从[title_height, height-title_height] 吐槽，虽然是固定写法，但是qt这个写起来也太麻烦了 ui和逻辑的互操架构blenderfreak大佬的实现中给了一个设计图，这也是我看了几个节点编辑器后觉得这个最好的原因，总体就是这几个部分： Scene的QWidget类保存了scene的QGraphicsView对象 Node的QWidget类保存了node和content的QGraphicsItem对象 Edge的QWidget类保存了edge的QGraphicsItem对象 Socket的QWidget类保存了socket的QGraphicsItem对象 同时，又在Graph的构造中传入了Widget对象，互相保存，在下面的节点设计中展示了具体的伪代码，总之有点类似安卓的context ui部分就到这里，qt的很多代码看起来很繁杂，但都是固定写法，比如图元绘制的addRoundedRect/addRect/setPen/setBrush/drawPath，但归根到底都是些api的调用 对于节点编辑器，后续的socket逻辑才是大头 节点的设计基本结构ui和逻辑分离，ui部分使用qt的QGraphicsItem绘制，逻辑在Node类中 为了方便互操，ui对象作为Node的成员，同时构造的时候会将本对象self传入ui对象中作为成员（这个操作类似android经常会将activity的this传入fragment中， 不过安卓中形参称之为context上下文，这里没有过多专业的名词，不过本质上是一样的） 123456789class QDMGraphicsNode(QGraphicsItem): def __init__(self, node: 'Node'): super().__init__(parent) self.node = nodeclass Node: def __init__(self): super().__init__() self.grNode = QDMGraphicsNode(self) 和socket/edge关联socket就是node左右两边的连接点，node里面保存了inputs和outputs节点，保存了所有的socket，这是整个编辑器最复杂的地方，因为socket实际上是连接node和edge的媒介，设计时要考虑的东西很多，但我并不想在这里单独开一章，原来大佬的设计很精彩，但我这里的重点是整体的功能 socket的属性包括： node：所在node的引用，和之前说的一样，类似context互操 edges: 连接的所有edge，注意，input socket只能连接一根线，但是output socket可以连接多根线 index：第几个socket，同一侧可能有多个，用于绘制时计算位置和序列化时使用 position：即使在同一侧，也可以选择左上中下，右上中下几种，也是用于绘制 socket_type：这部分我认为原本的设计存在不足，代码里写的Constant defining type(color) of this socket，也就是说只是一个color，我估计原本作者的想法应该是像unity shader或者ue蓝图一样，根据输出的值类型变化颜色，让用户知道什么output能连接什么input，不允许乱连接，但由于作者最后是做了一个计算器，所以都是int没有细化这部分 is_input：通过这个来区分是输入还是输出 edge的属性包括： start_socket和end_socket edge_type：贝塞尔曲线/直线 当一个节点要找前面/后面节点的时候，实际上的链路为：node -&gt; (for)output_socket -&gt; (for)edge -&gt; end_socket -&gt; next_node 动态注册为了方便用户添加自定义节点，需要动态注册的方式。后续如使用pyinstaller打包时，也可以通过配置.spec文件跳过对nodes文件夹下的打包，以方便用户自定义和参考原有node 通过@register_node(“DIV”)装饰器把这个class添加到字典CALC_NODES = {}中保存动态，所有需要添加的节点都可以通过这个装饰器添加进节点编辑器中，方便用户自定义和扩展节点 使用__all__注册整个包下的py文件，后续打包时可以屏蔽这个文件夹，用户便可以在这个文件夹下自由的编写自定义节点 计算节点 如四则运算节点，父节点CalcNode抽象出一个evalImplementation/evalOperation方法，子节点类都需要实现 数据存储：每个节点有一个value字段用于存储，当想要计算时，通过getInput(idx)方法从指定的输入端口（inputs[idx]）找到对应的上游节点拿其value，完成计算后也要将结果放置在当前节点的value中 向后计算：向后计算时，对着当前节点点击eval，会调用eval后，调用evalChildren遍历当前节点所有output，找到其下一层子节点并调用其eval方法，需要注意的是整个计算顺序应该是dfs 1234567def evalChildren(self): \"\"\" 使用这个完成计算，每次计算完，找到下一个节点继续计算 每个eval里面要实现从input端口的上一个连接节点拿数据，计算，把结果放到value中 \"\"\" for node in self.getChildrenNodes(): node.eval() 向前计算：向前计算时，比如output，对着output点击eval，往前找所有的input，并调用其eval函数，可以自动向前完成计算，其过程也是dfs 1234def evalImplementation(self): input_node = self.getInput(0) # 如果input端口不止一个也可以遍历inputs val = input_node.eval() return val 序列化/反序列化要实现graph的持久化保存，或数据传输，甚至是redo/undo功能，都必须完成序列化和反序列化工作，通过字符串完整表达graph中的数据 serialize需要序列化的东西包括如下几个部分： 场景：id、画布的大小 节点（列表）：节点id、标题、位置、inputs输入点列表（id、idx、位置、类型）、outputs输出点列表（id、idx、位置、类型）、内容 边（列表）：边的id、起点和终点的节点id 因此整个序列化和反序列化过程是一个自顶向下的结构，完成如上所述的整个场景的序列化，实际上是分别对node和edge进行序列化，最终返回一个dict方便后续的json直接保存成字符串： 12345678910111213# 场景序列化伪代码def serialize(self): nodes, edges = [], [] for node in self.nodes: nodes.append(node.serialize()) # node序列化 for edge in self.edges: edges.append(edge.serialize()) # edge序列化 return { 'id', self.id, 'scene_width', self.scene_width, 'scene_height', self.scene_height, 'nodes', nodes, 'edges', edges, } node和edge的serialize实现也是按上面我们所说的保存相应的信息到dict 当然，上述伪代码写的是dict，最终的实现是OrderedDict，保证了每次保存数据key的顺序是一样的 deserialize反序列化即是根据dict信息构造出整个画布，deserialize和serialize结构类似，也是分别对node和edge进行反序列化，反序列化的过程实际上就是根据信息创建node和edge对象的过程。但是需要注意以下关键点 id的存储，按理来说，即使没有id也可以完全复刻一个长得一模一样的场景，为什么还要记录id呢？因为创建出来的node只是位置和内容相同并非原来的node（内存地址不同），而边的序列化信息又需要记录起点和终点是哪个node的哪个socket，我们没有办法在同样的内存地址中创建对象，因此这个id只能当成成员变量记录起来 12345678# deserialize伪代码def Node: def __init__(self): self.id = id(self) def deserialize(self, data: dict, hashmap: dict={}) -&gt; bool: if restore_id: self.id = data['id'] # ... 这样一来，虽然新旧节点内存地址不一样，但self.id是一样的，在edge反序列化的时候就可以通过起点终点id来找到是哪个node的哪个socket了 注意到形参这里有个hashmap，算是一个优化点，node和socket反序列化时就加入{id: obj}进hashmap，这样edge序列化的时候就可以直接通过id寻找socket了不需要遍历查找 undo/redo功能这里的一个误区在于：我们首先会想到一个操作栈history_stack，把所有的操作都入栈，看起来undo就是弹出过程，redo就是栈恢复的过程。但这样做从实现的角度是非常复杂的 实际上，设计应该如下： 我们并不会用到栈stack这种存储结构，因为在多次undo后每次弹出的内容还不能抛弃，因为可能又多次redo，因此如果使用stack实现，需要用另一个栈来存储，因此我们history_stack实际上采用的是数组队列+下标指针 存储的不应该是操作，因为操作需要正向和反向，比如undo删除对应redo创建，由于操作非常多，这是不合理的。因此实际上history_stack是存储整个面板的serialize数据，整个过程为：“变动” -&gt; store(serialized_data) -&gt; undo/redo -&gt; restore(serialized_data)，这样undo和redo实际上都是重绘整个画布，只是在移动cur_idx指针，逻辑统一实现简单 “变动”包括：节点（新建/移动/删除），边（新建/删除），选中和取消选中 刚开始创建/打开节点文件的时候要记录一次 当undo几次后，如果不是redo而是storeHistory插入，那么就会丢弃原本可以redo的部分，就像丫字形，视为开始新的一条岔路 剪贴板功能利用QApplication.instance().clip实现，在复制(ctrl+c)和剪贴(ctrl+x)的时候序列化并存入剪贴板，粘贴(ctrl+v)的时候反序列化 注意： 粘贴的时候，需要给node、socket和edge添加一个新的id，否则id重复。由于序列化/反序列化所有节点都存储于一个hashmap中，会导致key重复 剪切（删除）节点后，如果剪贴板的边有未连接的节点，需要剔除，如果view中剩余的边有未连接的节点，也需要剔除 MDI窗口Multiple Document Interface多文档界面，即一个窗口下通过tab分割多个子窗口，文档型工具通常不会只打开一个文件，如下所示 可以极大的提高生产力和便利性，据说是由微软提出的用于excel多表编辑，但不知道为什么后来的excel弃用了，多表采用多窗口 mdi窗口现在有大量通用的参考，QT也有预制的实现QMdiArea，关键点： 原来QMainWindow.CentralWidget = QWidget对象，现在中间添加了一层QMdiArea，变为QMainWindow.CentralWidget = QMdiArea对象，然后通过mdiArea.addSubWindow(QWidget)添加每个tab项里的QWidget对象 几个api并不复杂，关键点在于每次操作里面的widget的时候，记得先通过mdiArea.activeSubWindow().widget()来获取当前的widget 这也侧面说明了为什么history_stack要放在Widget而不是window中的原因，因为每个graph的history_stack是独立的，同理保存等操作也是独立的，记得先获取当前激活的窗口 Details面板某一个节点可能有需要配置的东西，不好直接在一个节点的content里展示，显得非常凌乱，所以在右侧加入了details面板，这样方便用户配置自己的属性 考虑到用户可能会自定义节点，因此在node_base中也暴露了detailsInfo:属性， 类型为List[QWidget]，自定义节点时，可以通过往该属性中不断append widget，即可在Details面板中看到需要的属性 需要注意的是，这个面板里的参数如果需要保存，应该加入到序列化的value中 开关在自动化测试中，根据以往的经验，有几次可能要执行某一段代码，而有几次又要不执行某一段代码。因此为每个节点设计了开关，如果关闭，则此次执行跳过该节点 eval执行流程设计考虑自动化需求，重新实现了计算流程，a -&gt; b -&gt; c -&gt; d，有可能需要先执行到c出错了，此时希望不重复执行ab，而是从c开始继续执行，由于前面已经实现了前向计算和后向计算的基本操作，这里考虑如下设计方案 方案一（向后执行）： 将c mark dirty，会把后续的子节点都mark dirty，对着c或者b进行eval向后执行 方案二（向前执行）： 将c mark dirty，会把后续的子节点都mark dirty，对着d进行eval向前执行，此方案会导致一个问题，如果c出现了分叉c-&gt;d同时还有c-&gt;e，没法执行到c-&gt;e 方案三（向前执行修正）： 将c mark dirty，会把后续的子节点都mark dirty，对着d进行eval，不要向前执行而是改为往前找到已经ok的节点b，再从该节点开始向后执行 暂时是方案二啊，我意识到有问题，后面再改 方案一和方案三相比，方案三更加符合正常人的操作习惯，因为连接完节点后习惯于从最后的节点开始点击执行 Store节点在之前使用节点编辑器的时候就发现了一个问题，对于正常编写程序，逻辑本就不是像流水线一样线性的，难免存在如下代码： 123456789a = 1xxx 中间一大段b = 2xxx 中间一大段c = a + b 如果a b c分别在不同的节点，a -&gt; b -&gt;c 那么c想使用a的时候，就得把a先传给b，再把b传给c 在以前工作时使用的节点编辑器中，爷爷节点的数据需要一路传下来，链路上保存的数据就越来越多，而且每次都得往下传！！（即使这个节点编辑器的数据是不在链路上而在节点中，但依然存在这个问题），虽然自动化测试更加接近流水线一点，但使用历史数据问题肯定是在所难免的，因此要解决这个设计缺陷 Store节点，本质上是往一个空的global_data存东西，这里用的是模块，有点数据总线的味道~ 由于output socket本身就可以连接多根线，所以不用担心从哪个socket出来的问题，在LineIt中，本身output大概率就只有一个socket 接口类型颜色也许在上一个节点value的类型转换成颜色值，下一个的getInput里面验证，不一样类型的就不允许连接 TODO，暂时搁置，很多连接点其实是没有类型传输给下个节点的，不确定这种功能是否会导致操作不便，需要再仔细考量 动态增加ouput数量TODO，在LineIt中，本身output大概率就只有一个socket，所以可能没多大用处，暂时搁置 节点列表既然是做自动化了，那就尝试性的把一些功能封装成节点吧 移动设备操作类这里要注意尽量兼容多平台，主流就是android/iOS，android使用adb，iOS使用tidevice/wda，相当于做了之前airtest的一些工作，但是这样更加原生一点，也避免引入了很多不必要的东西 Nodes 作用 设计 设备列表 显示通过usb连接的android和iOS设备 开两个线程，分别通过adb和tidevice检测设备连接情况，然后emit到该node更新信息即可 打开应用 打开app / 截屏 截屏 / 性能数据 监测性能数据 单独开个widget对每台已连接设备展示性能数据，2s一次即可 安装应用 / / TODO模拟操作 单机/双击/滑动？ 暂时不做，如果做了感觉有点像appium/airtest了？或者后面直接集成呢？ https://blog.csdn.net/qq_27672101/article/details/143996095 https://zhuanlan.zhihu.com/p/3422441811 文件类 Nodes 作用 设计 文件列表 用于配合下面的节点批量操作 重命名 搭配文件列表进行批量重命名 windows的会变成a_1.png，a_1_1.png，不用我多说了吧 TODO复制 暂时不做，意义不大，如果后续有生成文件时再补充 TODO移动 暂时不做，意义不大，如果后续有生成文件时再补充 图像类 Nodes 作用 设计 TODO，后续搞点超分辨率或者stable diffusion相关的？ TODO，也许针对图片后期处理这部分有得做，滤镜/对比度/高光/曝光色调这些 工具类 Nodes 作用 设计 等待 sleep(s) 有些时候打开应用这种操作，没有回调，就没办法知道打开没有的，sleep个几秒看看 store 全局存储节点 用于非流水线式的变量取值 python 有些人就说：哎呀我就不想打开破编辑器写自定义节点，我就想简单写两行验证一下 行，双击node还可以打开vscode 可能存在的问题以及后续的规划节点通用性问题要思考封装的节点是否具有通用性，否则容易变成这一套节点只能用于这一套graph。为了避免出现这种问题，封装节点可以思考如下几点： 该节点是否能想到第二种连接方式搭配使用，如果是，则存在合理性 是否以“功能”/“操作”为单位，如果是，则存在合理性 本次编写的所有节点链路是否需要合并成一个节点，如果是，则不合理 避免在eval相关的函数中操作界面并行化改造后，eval可能由于父节点不在同一线程，此时操作界面可能会导致界面无法更新或者无法显示的问题，并且这本来也是不好的习惯。如果要在eval中修改界面，请通过信号槽机制来修改。这点非常重要 并行化改造存在的问题关于并行化改造，目前还存在问题，本来应该使用多进程multiprocess操作安卓设备的，在python中，创建多进程在linux下是使用fork，而在windows中使用的是pickle进行序列化+反序列化，但是pyqt/pyside中QObject实际上是c++对象，于是无法pickle会报错 这算是pyside的坑，暂时没有解决 pyside的坑(知乎)，答主介绍了一种重写__repr__魔法方法使pickle序列化的解决方案，太深 for循环问题这种情况在纯coding中肯定是存在的，而在节点编辑器中处理起来又很麻烦不优雅，目前市面上的节点编辑器也没有找到合适的方案，比如comfyui是单张图片的工作流而不是面向“批量化”处理，ShaderGraph是面对gpu的并行化操作本身没有for逻辑，UE蓝图倒是有WhileLoop/ForLoop节点，可以参考，但ue蓝图是面向程序的，参数给到了节点上，而LineIt是面向工作流的，需要重新设计 假设有如下操作 1234for item in list: doA doB doC 在没有for循环节点的情况下，变成了 1234567891011//node1for item in list: doA //node2for item in list: doB //node3for item in list: doC 复杂度也会由O(n)变成O(3n) 参数节点化问题后续可以做一个功能，允许把detailsInfo的参数变成输入节点，这样可能更加灵活一些 暂定的设计：右键节点-&gt;暴露参数-&gt;选择detailsInfo中的参数列表-&gt;扩展input节点 如果做这个的话，每个socket可能还要带一个label标签注明这个socket的作用","link":"/Others/line-it-node-editor/"}],"tags":[{"name":"力扣","slug":"力扣","link":"/tags/%E5%8A%9B%E6%89%A3/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"剑指offer","slug":"剑指offer","link":"/tags/%E5%89%91%E6%8C%87offer/"},{"name":"lintcode","slug":"lintcode","link":"/tags/lintcode/"},{"name":"游戏和引擎","slug":"游戏和引擎","link":"/tags/%E6%B8%B8%E6%88%8F%E5%92%8C%E5%BC%95%E6%93%8E/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"笔试面试","slug":"笔试面试","link":"/tags/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"},{"name":"加密","slug":"加密","link":"/tags/%E5%8A%A0%E5%AF%86/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"笔试","slug":"笔试","link":"/tags/%E7%AC%94%E8%AF%95/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"DL/ML","slug":"DL-ML","link":"/tags/DL-ML/"},{"name":"学习记录","slug":"学习记录","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"数据结构和算法","slug":"algorithms","link":"/categories/algorithms/"},{"name":"生活随笔","slug":"life","link":"/categories/life/"},{"name":"游戏和引擎","slug":"games","link":"/categories/games/"},{"name":"Util工具类","slug":"util","link":"/categories/util/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"前端","slug":"frontend","link":"/categories/frontend/"},{"name":"Mysql","slug":"Mysql","link":"/categories/Mysql/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/categories/SpringCloud/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"玄学","slug":"deeplearning","link":"/categories/deeplearning/"},{"name":"设计模式","slug":"designpattern","link":"/categories/designpattern/"},{"name":"计算机基础","slug":"cs","link":"/categories/cs/"}]}